pub fn Register(comptime R: type) type {
    return RegisterRW(R, R);
}

pub fn RegisterRW(comptime Read: type, comptime Write: type) type {
    return struct {
        raw_ptr: *volatile u32,

        const Self = @This();

        pub fn init(address: usize) Self {
            return Self{ .raw_ptr = @intToPtr(*volatile u32, address) };
        }

        pub fn initRange(address: usize, comptime dim_increment: usize, comptime num_registers: usize) [num_registers]Self {
            var registers: [num_registers]Self = undefined;
            var i: usize = 0;
            while (i < num_registers) : (i += 1) {
                registers[i] = Self.init(address + (i * dim_increment));
            }
            return registers;
        }

        pub fn read(self: Self) Read {
            return @bitCast(Read, self.raw_ptr.*);
        }

        pub fn write(self: Self, value: Write) void {
            self.raw_ptr.* = @bitCast(u32, value);
        }

        pub fn modify(self: Self, new_value: anytype) void {
            if (Read != Write) {
                @compileError("Can't modify because read and write types for this register aren't the same.");
            }
            var old_value = self.read();
            const info = @typeInfo(@TypeOf(new_value));
            inline for (info.Struct.fields) |field| {
                @field(old_value, field.name) = @field(new_value, field.name);
            }
            self.write(old_value);
        }

        pub fn read_raw(self: Self) u32 {
            return self.raw_ptr.*;
        }

        pub fn write_raw(self: Self, value: u32) void {
            self.raw_ptr.* = value;
        }

        pub fn default_read_value(self: Self) Read {
            return Read{};
        }

        pub fn default_write_value(self: Self) Write {
            return Write{};
        }
    };
}

pub fn RepeatedFields(comptime num_fields: usize, comptime field_name: []const u8, comptime T: type) type {
    var info = @typeInfo(packed struct { f: T });
    var fields: [num_fields]std.builtin.TypeInfo.StructField = undefined;
    var field_ix: usize = 0;
    while (field_ix < num_fields) : (field_ix += 1) {
        var field = info.Struct.fields[0];

        // awkward workaround for lack of comptime allocator
        @setEvalBranchQuota(100000);
        var field_ix_buffer: [field_name.len + 16]u8 = undefined;
        var stream = std.io.FixedBufferStream([]u8){ .buffer = &field_ix_buffer, .pos = 0 };
        std.fmt.format(stream.writer(), "{}{}", .{ field_name, field_ix }) catch unreachable;
        field.name = stream.getWritten();

        field.default_value = T.default_value;

        fields[field_ix] = field;
    }

    // TODO this might not be safe to set
    info.Struct.is_tuple = true;

    info.Struct.fields = &fields;
    return @Type(info);
}

///Factory information configuration registers
pub const ficr = struct {

    //////////////////////////
    ///CODEPAGESIZE
    const codepagesize_val = packed struct {
        ///CODEPAGESIZE [0:31]
        ///Code memory page size
        codepagesize: u32 = 4294967295,
    };
    ///Code memory page size
    pub const codepagesize = RegisterRW(codepagesize_val, void).init(0x10000000 + 0x010);

    //////////////////////////
    ///CODESIZE
    const codesize_val = packed struct {
        ///CODESIZE [0:31]
        ///Code memory size in number of pages
        codesize: u32 = 4294967295,
    };
    ///Code memory size
    pub const codesize = RegisterRW(codesize_val, void).init(0x10000000 + 0x014);

    //////////////////////////
    ///DEVICEID[%s]
    const deviceid_val = packed struct {
        ///DEVICEID [0:31]
        ///64 bit unique device identifier
        deviceid: u32 = 4294967295,
    };
    ///Description collection: Device identifier
    pub const deviceid = RegisterRW(deviceid_val, void).initRange(0x10000000 + 0x060, 4, 2);

    //////////////////////////
    ///ER[%s]
    const er_val = packed struct {
        ///ER [0:31]
        ///Encryption root, word n
        er: u32 = 4294967295,
    };
    ///Description collection: Encryption root, word n
    pub const er = RegisterRW(er_val, void).initRange(0x10000000 + 0x080, 4, 4);

    //////////////////////////
    ///IR[%s]
    const ir_val = packed struct {
        ///IR [0:31]
        ///Identity Root, word n
        ir: u32 = 4294967295,
    };
    ///Description collection: Identity Root, word n
    pub const ir = RegisterRW(ir_val, void).initRange(0x10000000 + 0x090, 4, 4);

    //////////////////////////
    ///DEVICEADDRTYPE
    const deviceaddrtype_val = packed struct {
        ///DEVICEADDRTYPE [0:0]
        ///Device address type
        deviceaddrtype: packed enum(u1) {
            ///Public address
            public = 0,
            ///Random address
            random = 1,
        } = .random,
        _unused1: u31 = 0,
    };
    ///Device address type
    pub const deviceaddrtype = RegisterRW(deviceaddrtype_val, void).init(0x10000000 + 0x0A0);

    //////////////////////////
    ///DEVICEADDR[%s]
    const deviceaddr_val = packed struct {
        ///DEVICEADDR [0:31]
        ///48 bit device address
        deviceaddr: u32 = 4294967295,
    };
    ///Description collection: Device address n
    pub const deviceaddr = RegisterRW(deviceaddr_val, void).initRange(0x10000000 + 0x0A4, 4, 2);

    //////////////////////////
    ///PRODTEST[%s]
    const prodtest_val = packed struct {
        ///PRODTEST [0:31]
        ///Production test signature n
        prodtest: packed enum(u32) {
            ///Production tests done
            done = 0xBB42319F,
            ///Production tests not done
            not_done = 0xFFFFFFFF,
            _zero = 0,
        } = ._zero,
    };
    ///Description collection: Production test signature n
    pub const prodtest = RegisterRW(prodtest_val, void).initRange(0x10000000 + 0x350, 4, 3);
};

///User information configuration registers
pub const uicr = struct {

    //////////////////////////
    ///NRFFW[%s]
    const nrffw_val = packed struct {
        ///NRFFW [0:31]
        ///Reserved for Nordic firmware design
        nrffw: u32 = 4294967295,
    };
    ///Description collection: Reserved for Nordic firmware design
    pub const nrffw = Register(nrffw_val).initRange(0x10001000 + 0x014, 4, 13);

    //////////////////////////
    ///NRFHW[%s]
    const nrfhw_val = packed struct {
        ///NRFHW [0:31]
        ///Reserved for Nordic hardware design
        nrfhw: u32 = 4294967295,
    };
    ///Description collection: Reserved for Nordic hardware design
    pub const nrfhw = Register(nrfhw_val).initRange(0x10001000 + 0x050, 4, 12);

    //////////////////////////
    ///CUSTOMER[%s]
    const customer_val = packed struct {
        ///CUSTOMER [0:31]
        ///Reserved for customer
        customer: u32 = 4294967295,
    };
    ///Description collection: Reserved for customer
    pub const customer = Register(customer_val).initRange(0x10001000 + 0x080, 4, 32);

    //////////////////////////
    ///PSELRESET[%s]
    const pselreset_val = packed struct {
        ///PIN [0:4]
        ///GPIO pin number onto which nRESET is exposed
        pin: u5 = 31,
        ///PORT [5:5]
        ///Port number onto which nRESET is exposed
        port: u1 = 1,
        _unused6: u25 = 0,
        ///CONNECT [31:31]
        ///Connection
        connect: packed enum(u1) {
            ///Disconnect
            disconnected = 1,
            ///Connect
            connected = 0,
        } = .disconnected,
    };
    ///Description collection: Mapping of the nRESET function (see POWER chapter for details)
    pub const pselreset = Register(pselreset_val).initRange(0x10001000 + 0x200, 4, 2);

    //////////////////////////
    ///APPROTECT
    const approtect_val = packed struct {
        ///PALL [0:7]
        ///Enable or disable access port protection.
        pall: packed enum(u8) {
            ///Disable
            disabled = 0xFF,
            ///Enable
            enabled = 0x00,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///Access port protection
    pub const approtect = Register(approtect_val).init(0x10001000 + 0x208);

    //////////////////////////
    ///NFCPINS
    const nfcpins_val = packed struct {
        ///PROTECT [0:0]
        ///Setting of pins dedicated to NFC functionality
        protect: packed enum(u1) {
            ///Operation as GPIO pins. Same protection as normal GPIO pins
            disabled = 0,
            ///Operation as NFC antenna pins. Configures the protection for NFC operation
            nfc = 1,
        } = .nfc,
        _unused1: u31 = 0,
    };
    ///Setting of pins dedicated to NFC functionality: NFC antenna or GPIO
    pub const nfcpins = Register(nfcpins_val).init(0x10001000 + 0x20C);

    //////////////////////////
    ///DEBUGCTRL
    const debugctrl_val = packed struct {
        ///CPUNIDEN [0:7]
        ///Configure CPU non-intrusive debug features
        cpuniden: packed enum(u8) {
            ///Enable CPU ITM and ETM functionality (default behavior)
            enabled = 0xFF,
            ///Disable CPU ITM and ETM functionality
            disabled = 0x00,
            _zero = 0,
        } = ._zero,
        ///CPUFPBEN [8:15]
        ///Configure CPU flash patch and breakpoint (FPB) unit behavior
        cpufpben: packed enum(u8) {
            ///Enable CPU FPB unit (default behavior)
            enabled = 0xFF,
            ///Disable CPU FPB unit. Writes into the FPB registers will be ignored.
            disabled = 0x00,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Processor debug control
    pub const debugctrl = Register(debugctrl_val).init(0x10001000 + 0x210);

    //////////////////////////
    ///REGOUT0
    const regout0_val = packed struct {
        ///VOUT [0:2]
        ///Output voltage from REG0 regulator stage.
        vout: packed enum(u3) {
            ///1.8 V
            _1v8 = 0,
            ///2.1 V
            _2v1 = 1,
            ///2.4 V
            _2v4 = 2,
            ///2.7 V
            _2v7 = 3,
            ///3.0 V
            _3v0 = 4,
            ///3.3 V
            _3v3 = 5,
            ///Default voltage: 1.8 V
            default = 7,
        } = .default,
        _unused3: u29 = 0,
    };
    ///Output voltage from REG0 regulator stage. The maximum output voltage from this stage is given as VDDH - VREG0DROP.
    pub const regout0 = Register(regout0_val).init(0x10001000 + 0x304);
};

///Clock control
pub const clock = struct {

    //////////////////////////
    ///TASKS_HFCLKSTART
    const tasks_hfclkstart_val = packed struct {
        ///TASKS_HFCLKSTART [0:0]
        ///Start HFXO crystal oscillator
        tasks_hfclkstart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start HFXO crystal oscillator
    pub const tasks_hfclkstart = RegisterRW(void, tasks_hfclkstart_val).init(0x40000000 + 0x000);

    //////////////////////////
    ///TASKS_HFCLKSTOP
    const tasks_hfclkstop_val = packed struct {
        ///TASKS_HFCLKSTOP [0:0]
        ///Stop HFXO crystal oscillator
        tasks_hfclkstop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop HFXO crystal oscillator
    pub const tasks_hfclkstop = RegisterRW(void, tasks_hfclkstop_val).init(0x40000000 + 0x004);

    //////////////////////////
    ///TASKS_LFCLKSTART
    const tasks_lfclkstart_val = packed struct {
        ///TASKS_LFCLKSTART [0:0]
        ///Start LFCLK
        tasks_lfclkstart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start LFCLK
    pub const tasks_lfclkstart = RegisterRW(void, tasks_lfclkstart_val).init(0x40000000 + 0x008);

    //////////////////////////
    ///TASKS_LFCLKSTOP
    const tasks_lfclkstop_val = packed struct {
        ///TASKS_LFCLKSTOP [0:0]
        ///Stop LFCLK
        tasks_lfclkstop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop LFCLK
    pub const tasks_lfclkstop = RegisterRW(void, tasks_lfclkstop_val).init(0x40000000 + 0x00C);

    //////////////////////////
    ///TASKS_CAL
    const tasks_cal_val = packed struct {
        ///TASKS_CAL [0:0]
        ///Start calibration of LFRC
        tasks_cal: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start calibration of LFRC
    pub const tasks_cal = RegisterRW(void, tasks_cal_val).init(0x40000000 + 0x010);

    //////////////////////////
    ///TASKS_CTSTART
    const tasks_ctstart_val = packed struct {
        ///TASKS_CTSTART [0:0]
        ///Start calibration timer
        tasks_ctstart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start calibration timer
    pub const tasks_ctstart = RegisterRW(void, tasks_ctstart_val).init(0x40000000 + 0x014);

    //////////////////////////
    ///TASKS_CTSTOP
    const tasks_ctstop_val = packed struct {
        ///TASKS_CTSTOP [0:0]
        ///Stop calibration timer
        tasks_ctstop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop calibration timer
    pub const tasks_ctstop = RegisterRW(void, tasks_ctstop_val).init(0x40000000 + 0x018);

    //////////////////////////
    ///EVENTS_HFCLKSTARTED
    const events_hfclkstarted_val = packed struct {
        ///EVENTS_HFCLKSTARTED [0:0]
        ///HFXO crystal oscillator started
        events_hfclkstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///HFXO crystal oscillator started
    pub const events_hfclkstarted = Register(events_hfclkstarted_val).init(0x40000000 + 0x100);

    //////////////////////////
    ///EVENTS_LFCLKSTARTED
    const events_lfclkstarted_val = packed struct {
        ///EVENTS_LFCLKSTARTED [0:0]
        ///LFCLK started
        events_lfclkstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///LFCLK started
    pub const events_lfclkstarted = Register(events_lfclkstarted_val).init(0x40000000 + 0x104);

    //////////////////////////
    ///EVENTS_DONE
    const events_done_val = packed struct {
        ///EVENTS_DONE [0:0]
        ///Calibration of LFRC completed
        events_done: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Calibration of LFRC completed
    pub const events_done = Register(events_done_val).init(0x40000000 + 0x10C);

    //////////////////////////
    ///EVENTS_CTTO
    const events_ctto_val = packed struct {
        ///EVENTS_CTTO [0:0]
        ///Calibration timer timeout
        events_ctto: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Calibration timer timeout
    pub const events_ctto = Register(events_ctto_val).init(0x40000000 + 0x110);

    //////////////////////////
    ///EVENTS_CTSTARTED
    const events_ctstarted_val = packed struct {
        ///EVENTS_CTSTARTED [0:0]
        ///Calibration timer has been started and is ready to process new tasks
        events_ctstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Calibration timer has been started and is ready to process new tasks
    pub const events_ctstarted = Register(events_ctstarted_val).init(0x40000000 + 0x128);

    //////////////////////////
    ///EVENTS_CTSTOPPED
    const events_ctstopped_val = packed struct {
        ///EVENTS_CTSTOPPED [0:0]
        ///Calibration timer has been stopped and is ready to process new tasks
        events_ctstopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Calibration timer has been stopped and is ready to process new tasks
    pub const events_ctstopped = Register(events_ctstopped_val).init(0x40000000 + 0x12C);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///HFCLKSTARTED [0:0]
        ///Write '1' to enable interrupt for event HFCLKSTARTED
        hfclkstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LFCLKSTARTED [1:1]
        ///Write '1' to enable interrupt for event LFCLKSTARTED
        lfclkstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u1 = 0,
        ///DONE [3:3]
        ///Write '1' to enable interrupt for event DONE
        done: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CTTO [4:4]
        ///Write '1' to enable interrupt for event CTTO
        ctto: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u5 = 0,
        ///CTSTARTED [10:10]
        ///Write '1' to enable interrupt for event CTSTARTED
        ctstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CTSTOPPED [11:11]
        ///Write '1' to enable interrupt for event CTSTOPPED
        ctstopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused12: u20 = 0,
    };
    const intenset_val_write = packed struct {
        ///HFCLKSTARTED [0:0]
        ///Write '1' to enable interrupt for event HFCLKSTARTED
        hfclkstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///LFCLKSTARTED [1:1]
        ///Write '1' to enable interrupt for event LFCLKSTARTED
        lfclkstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u1 = 0,
        ///DONE [3:3]
        ///Write '1' to enable interrupt for event DONE
        done: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CTTO [4:4]
        ///Write '1' to enable interrupt for event CTTO
        ctto: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u5 = 0,
        ///CTSTARTED [10:10]
        ///Write '1' to enable interrupt for event CTSTARTED
        ctstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CTSTOPPED [11:11]
        ///Write '1' to enable interrupt for event CTSTOPPED
        ctstopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused12: u20 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40000000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///HFCLKSTARTED [0:0]
        ///Write '1' to disable interrupt for event HFCLKSTARTED
        hfclkstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LFCLKSTARTED [1:1]
        ///Write '1' to disable interrupt for event LFCLKSTARTED
        lfclkstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u1 = 0,
        ///DONE [3:3]
        ///Write '1' to disable interrupt for event DONE
        done: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CTTO [4:4]
        ///Write '1' to disable interrupt for event CTTO
        ctto: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u5 = 0,
        ///CTSTARTED [10:10]
        ///Write '1' to disable interrupt for event CTSTARTED
        ctstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CTSTOPPED [11:11]
        ///Write '1' to disable interrupt for event CTSTOPPED
        ctstopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused12: u20 = 0,
    };
    const intenclr_val_write = packed struct {
        ///HFCLKSTARTED [0:0]
        ///Write '1' to disable interrupt for event HFCLKSTARTED
        hfclkstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///LFCLKSTARTED [1:1]
        ///Write '1' to disable interrupt for event LFCLKSTARTED
        lfclkstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u1 = 0,
        ///DONE [3:3]
        ///Write '1' to disable interrupt for event DONE
        done: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CTTO [4:4]
        ///Write '1' to disable interrupt for event CTTO
        ctto: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u5 = 0,
        ///CTSTARTED [10:10]
        ///Write '1' to disable interrupt for event CTSTARTED
        ctstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CTSTOPPED [11:11]
        ///Write '1' to disable interrupt for event CTSTOPPED
        ctstopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused12: u20 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40000000 + 0x308);

    //////////////////////////
    ///HFCLKRUN
    const hfclkrun_val = packed struct {
        ///STATUS [0:0]
        ///HFCLKSTART task triggered or not
        status: packed enum(u1) {
            ///Task not triggered
            not_triggered = 0,
            ///Task triggered
            triggered = 1,
        } = .not_triggered,
        _unused1: u31 = 0,
    };
    ///Status indicating that HFCLKSTART task has been triggered
    pub const hfclkrun = RegisterRW(hfclkrun_val, void).init(0x40000000 + 0x408);

    //////////////////////////
    ///HFCLKSTAT
    const hfclkstat_val = packed struct {
        ///SRC [0:0]
        ///Source of HFCLK
        src: packed enum(u1) {
            ///64 MHz internal oscillator (HFINT)
            rc = 0,
            ///64 MHz crystal oscillator (HFXO)
            xtal = 1,
        } = .rc,
        _unused1: u15 = 0,
        ///STATE [16:16]
        ///HFCLK state
        state: packed enum(u1) {
            ///HFCLK not running
            not_running = 0,
            ///HFCLK running
            running = 1,
        } = .not_running,
        _unused17: u15 = 0,
    };
    ///HFCLK status
    pub const hfclkstat = RegisterRW(hfclkstat_val, void).init(0x40000000 + 0x40C);

    //////////////////////////
    ///LFCLKRUN
    const lfclkrun_val = packed struct {
        ///STATUS [0:0]
        ///LFCLKSTART task triggered or not
        status: packed enum(u1) {
            ///Task not triggered
            not_triggered = 0,
            ///Task triggered
            triggered = 1,
        } = .not_triggered,
        _unused1: u31 = 0,
    };
    ///Status indicating that LFCLKSTART task has been triggered
    pub const lfclkrun = RegisterRW(lfclkrun_val, void).init(0x40000000 + 0x414);

    //////////////////////////
    ///LFCLKSTAT
    const lfclkstat_val = packed struct {
        ///SRC [0:1]
        ///Source of LFCLK
        src: packed enum(u2) {
            ///32.768 kHz RC oscillator (LFRC)
            rc = 0,
            ///32.768 kHz crystal oscillator (LFXO)
            xtal = 1,
            ///32.768 kHz synthesized from HFCLK (LFSYNT)
            synth = 2,
        } = .rc,
        _unused2: u14 = 0,
        ///STATE [16:16]
        ///LFCLK state
        state: packed enum(u1) {
            ///LFCLK not running
            not_running = 0,
            ///LFCLK running
            running = 1,
        } = .not_running,
        _unused17: u15 = 0,
    };
    ///LFCLK status
    pub const lfclkstat = RegisterRW(lfclkstat_val, void).init(0x40000000 + 0x418);

    //////////////////////////
    ///LFCLKSRCCOPY
    const lfclksrccopy_val = packed struct {
        ///SRC [0:1]
        ///Clock source
        src: packed enum(u2) {
            ///32.768 kHz RC oscillator (LFRC)
            rc = 0,
            ///32.768 kHz crystal oscillator (LFXO)
            xtal = 1,
            ///32.768 kHz synthesized from HFCLK (LFSYNT)
            synth = 2,
        } = .rc,
        _unused2: u30 = 0,
    };
    ///Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
    pub const lfclksrccopy = RegisterRW(lfclksrccopy_val, void).init(0x40000000 + 0x41C);

    //////////////////////////
    ///LFCLKSRC
    const lfclksrc_val = packed struct {
        ///SRC [0:1]
        ///Clock source
        src: packed enum(u2) {
            ///32.768 kHz RC oscillator (LFRC)
            rc = 0,
            ///32.768 kHz crystal oscillator (LFXO)
            xtal = 1,
            ///32.768 kHz synthesized from HFCLK (LFSYNT)
            synth = 2,
        } = .rc,
        _unused2: u14 = 0,
        ///BYPASS [16:16]
        ///Enable or disable bypass of LFCLK crystal oscillator with external clock source
        bypass: packed enum(u1) {
            ///Disable (use with Xtal or low-swing external source)
            disabled = 0,
            ///Enable (use with rail-to-rail external source)
            enabled = 1,
        } = .disabled,
        ///EXTERNAL [17:17]
        ///Enable or disable external source for LFCLK
        external: packed enum(u1) {
            ///Disable external source (use with Xtal)
            disabled = 0,
            ///Enable use of external source instead of Xtal (SRC needs to be set to Xtal)
            enabled = 1,
        } = .disabled,
        _unused18: u14 = 0,
    };
    ///Clock source for the LFCLK
    pub const lfclksrc = Register(lfclksrc_val).init(0x40000000 + 0x518);

    //////////////////////////
    ///HFXODEBOUNCE
    const hfxodebounce_val = packed struct {
        ///HFXODEBOUNCE [0:7]
        ///HFXO debounce time. Debounce time = HFXODEBOUNCE * 16 us.
        hfxodebounce: packed enum(u8) {
            ///256 us debounce time. Recommended for 1.6 mm x 2.0 mm crystals and larger.
            db256us = 0x10,
            ///1024 us debounce time. Recommended for 1.6 mm x 1.2 mm crystals and smaller.
            db1024us = 0x40,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///HFXO debounce time. The HFXO is started by triggering the TASKS_HFCLKSTART task.
    pub const hfxodebounce = Register(hfxodebounce_val).init(0x40000000 + 0x528);

    //////////////////////////
    ///LFXODEBOUNCE
    const lfxodebounce_val = packed struct {
        ///LFXODEBOUNCE [0:0]
        ///LFXO debounce time.
        lfxodebounce: packed enum(u1) {
            ///8192 32.768 kHz periods, or 0.25 s. Recommended for normal Operating Temperature conditions.
            normal = 0,
            ///16384 32.768 kHz periods, or 0.5 s. Recommended for Extended Operating Temperature conditions.
            extended = 1,
        } = .normal,
        _unused1: u31 = 0,
    };
    ///LFXO debounce time. The LFXO is started by triggering the TASKS_LFCLKSTART task when the LFCLKSRC register is configured for Xtal.
    pub const lfxodebounce = Register(lfxodebounce_val).init(0x40000000 + 0x52C);

    //////////////////////////
    ///CTIV
    const ctiv_val = packed struct {
        ///CTIV [0:6]
        ///Calibration timer interval in multiple of 0.25 seconds. Range: 0.25 seconds to 31.75 seconds.
        ctiv: u7 = 0,
        _unused7: u25 = 0,
    };
    ///Calibration timer interval
    pub const ctiv = Register(ctiv_val).init(0x40000000 + 0x538);

    //////////////////////////
    ///TRACECONFIG
    const traceconfig_val = packed struct {
        ///TRACEPORTSPEED [0:1]
        ///Speed of trace port clock. Note that the TRACECLK pin will output this clock divided by two.
        traceportspeed: packed enum(u2) {
            ///32 MHz trace port clock (TRACECLK = 16 MHz)
            _32mhz = 0,
            ///16 MHz trace port clock (TRACECLK = 8 MHz)
            _16mhz = 1,
            ///8 MHz trace port clock (TRACECLK = 4 MHz)
            _8mhz = 2,
            ///4 MHz trace port clock (TRACECLK = 2 MHz)
            _4mhz = 3,
        } = ._32mhz,
        _unused2: u14 = 0,
        ///TRACEMUX [16:17]
        ///Pin multiplexing of trace signals. See pin assignment chapter for more details.
        tracemux: packed enum(u2) {
            ///No trace signals routed to pins. All pins can be used as regular GPIOs.
            gpio = 0,
            ///SWO trace signal routed to pin. Remaining pins can be used as regular GPIOs.
            serial = 1,
            ///All trace signals (TRACECLK and TRACEDATA[n]) routed to pins.
            parallel = 2,
        } = .gpio,
        _unused18: u14 = 0,
    };
    ///Clocking options for the trace port debug interface
    pub const traceconfig = Register(traceconfig_val).init(0x40000000 + 0x55C);
};

///Power control
pub const power = struct {

    //////////////////////////
    ///TASKS_CONSTLAT
    const tasks_constlat_val = packed struct {
        ///TASKS_CONSTLAT [0:0]
        ///Enable Constant Latency mode
        tasks_constlat: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Enable Constant Latency mode
    pub const tasks_constlat = RegisterRW(void, tasks_constlat_val).init(0x40000000 + 0x78);

    //////////////////////////
    ///TASKS_LOWPWR
    const tasks_lowpwr_val = packed struct {
        ///TASKS_LOWPWR [0:0]
        ///Enable Low-power mode (variable latency)
        tasks_lowpwr: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Enable Low-power mode (variable latency)
    pub const tasks_lowpwr = RegisterRW(void, tasks_lowpwr_val).init(0x40000000 + 0x7C);

    //////////////////////////
    ///EVENTS_POFWARN
    const events_pofwarn_val = packed struct {
        ///EVENTS_POFWARN [0:0]
        ///Power failure warning
        events_pofwarn: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Power failure warning
    pub const events_pofwarn = Register(events_pofwarn_val).init(0x40000000 + 0x108);

    //////////////////////////
    ///EVENTS_SLEEPENTER
    const events_sleepenter_val = packed struct {
        ///EVENTS_SLEEPENTER [0:0]
        ///CPU entered WFI/WFE sleep
        events_sleepenter: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///CPU entered WFI/WFE sleep
    pub const events_sleepenter = Register(events_sleepenter_val).init(0x40000000 + 0x114);

    //////////////////////////
    ///EVENTS_SLEEPEXIT
    const events_sleepexit_val = packed struct {
        ///EVENTS_SLEEPEXIT [0:0]
        ///CPU exited WFI/WFE sleep
        events_sleepexit: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///CPU exited WFI/WFE sleep
    pub const events_sleepexit = Register(events_sleepexit_val).init(0x40000000 + 0x118);

    //////////////////////////
    ///EVENTS_USBDETECTED
    const events_usbdetected_val = packed struct {
        ///EVENTS_USBDETECTED [0:0]
        ///Voltage supply detected on VBUS
        events_usbdetected: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Voltage supply detected on VBUS
    pub const events_usbdetected = Register(events_usbdetected_val).init(0x40000000 + 0x11C);

    //////////////////////////
    ///EVENTS_USBREMOVED
    const events_usbremoved_val = packed struct {
        ///EVENTS_USBREMOVED [0:0]
        ///Voltage supply removed from VBUS
        events_usbremoved: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Voltage supply removed from VBUS
    pub const events_usbremoved = Register(events_usbremoved_val).init(0x40000000 + 0x120);

    //////////////////////////
    ///EVENTS_USBPWRRDY
    const events_usbpwrrdy_val = packed struct {
        ///EVENTS_USBPWRRDY [0:0]
        ///USB 3.3 V supply ready
        events_usbpwrrdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///USB 3.3 V supply ready
    pub const events_usbpwrrdy = Register(events_usbpwrrdy_val).init(0x40000000 + 0x124);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u2 = 0,
        ///POFWARN [2:2]
        ///Write '1' to enable interrupt for event POFWARN
        pofwarn: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u2 = 0,
        ///SLEEPENTER [5:5]
        ///Write '1' to enable interrupt for event SLEEPENTER
        sleepenter: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SLEEPEXIT [6:6]
        ///Write '1' to enable interrupt for event SLEEPEXIT
        sleepexit: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///USBDETECTED [7:7]
        ///Write '1' to enable interrupt for event USBDETECTED
        usbdetected: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///USBREMOVED [8:8]
        ///Write '1' to enable interrupt for event USBREMOVED
        usbremoved: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///USBPWRRDY [9:9]
        ///Write '1' to enable interrupt for event USBPWRRDY
        usbpwrrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u22 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u2 = 0,
        ///POFWARN [2:2]
        ///Write '1' to enable interrupt for event POFWARN
        pofwarn: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u2 = 0,
        ///SLEEPENTER [5:5]
        ///Write '1' to enable interrupt for event SLEEPENTER
        sleepenter: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SLEEPEXIT [6:6]
        ///Write '1' to enable interrupt for event SLEEPEXIT
        sleepexit: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///USBDETECTED [7:7]
        ///Write '1' to enable interrupt for event USBDETECTED
        usbdetected: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///USBREMOVED [8:8]
        ///Write '1' to enable interrupt for event USBREMOVED
        usbremoved: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///USBPWRRDY [9:9]
        ///Write '1' to enable interrupt for event USBPWRRDY
        usbpwrrdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u22 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40000000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u2 = 0,
        ///POFWARN [2:2]
        ///Write '1' to disable interrupt for event POFWARN
        pofwarn: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u2 = 0,
        ///SLEEPENTER [5:5]
        ///Write '1' to disable interrupt for event SLEEPENTER
        sleepenter: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SLEEPEXIT [6:6]
        ///Write '1' to disable interrupt for event SLEEPEXIT
        sleepexit: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///USBDETECTED [7:7]
        ///Write '1' to disable interrupt for event USBDETECTED
        usbdetected: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///USBREMOVED [8:8]
        ///Write '1' to disable interrupt for event USBREMOVED
        usbremoved: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///USBPWRRDY [9:9]
        ///Write '1' to disable interrupt for event USBPWRRDY
        usbpwrrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u22 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u2 = 0,
        ///POFWARN [2:2]
        ///Write '1' to disable interrupt for event POFWARN
        pofwarn: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u2 = 0,
        ///SLEEPENTER [5:5]
        ///Write '1' to disable interrupt for event SLEEPENTER
        sleepenter: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SLEEPEXIT [6:6]
        ///Write '1' to disable interrupt for event SLEEPEXIT
        sleepexit: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///USBDETECTED [7:7]
        ///Write '1' to disable interrupt for event USBDETECTED
        usbdetected: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///USBREMOVED [8:8]
        ///Write '1' to disable interrupt for event USBREMOVED
        usbremoved: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///USBPWRRDY [9:9]
        ///Write '1' to disable interrupt for event USBPWRRDY
        usbpwrrdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u22 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40000000 + 0x308);

    //////////////////////////
    ///RESETREAS
    const resetreas_val = packed struct {
        ///RESETPIN [0:0]
        ///Reset from pin-reset detected
        resetpin: packed enum(u1) {
            ///Not detected
            not_detected = 0,
            ///Detected
            detected = 1,
        } = .not_detected,
        ///DOG [1:1]
        ///Reset from watchdog detected
        dog: packed enum(u1) {
            ///Not detected
            not_detected = 0,
            ///Detected
            detected = 1,
        } = .not_detected,
        ///SREQ [2:2]
        ///Reset from soft reset detected
        sreq: packed enum(u1) {
            ///Not detected
            not_detected = 0,
            ///Detected
            detected = 1,
        } = .not_detected,
        ///LOCKUP [3:3]
        ///Reset from CPU lock-up detected
        lockup: packed enum(u1) {
            ///Not detected
            not_detected = 0,
            ///Detected
            detected = 1,
        } = .not_detected,
        _unused4: u12 = 0,
        ///OFF [16:16]
        ///Reset due to wake up from System OFF mode when wakeup is triggered from DETECT signal from GPIO
        off: packed enum(u1) {
            ///Not detected
            not_detected = 0,
            ///Detected
            detected = 1,
        } = .not_detected,
        ///LPCOMP [17:17]
        ///Reset due to wake up from System OFF mode when wakeup is triggered from ANADETECT signal from LPCOMP
        lpcomp: packed enum(u1) {
            ///Not detected
            not_detected = 0,
            ///Detected
            detected = 1,
        } = .not_detected,
        ///DIF [18:18]
        ///Reset due to wake up from System OFF mode when wakeup is triggered from entering into debug interface mode
        dif: packed enum(u1) {
            ///Not detected
            not_detected = 0,
            ///Detected
            detected = 1,
        } = .not_detected,
        ///NFC [19:19]
        ///Reset due to wake up from System OFF mode by NFC field detect
        nfc: packed enum(u1) {
            ///Not detected
            not_detected = 0,
            ///Detected
            detected = 1,
        } = .not_detected,
        ///VBUS [20:20]
        ///Reset due to wake up from System OFF mode by VBUS rising into valid range
        vbus: packed enum(u1) {
            ///Not detected
            not_detected = 0,
            ///Detected
            detected = 1,
        } = .not_detected,
        _unused21: u11 = 0,
    };
    ///Reset reason
    pub const resetreas = Register(resetreas_val).init(0x40000000 + 0x400);

    //////////////////////////
    ///RAMSTATUS
    const ramstatus_val = packed struct {
        ///RAMBLOCK0 [0:0]
        ///RAM block 0 is on or off/powering up
        ramblock0: packed enum(u1) {
            ///Off
            off = 0,
            ///On
            on = 1,
        } = .off,
        ///RAMBLOCK1 [1:1]
        ///RAM block 1 is on or off/powering up
        ramblock1: packed enum(u1) {
            ///Off
            off = 0,
            ///On
            on = 1,
        } = .off,
        ///RAMBLOCK2 [2:2]
        ///RAM block 2 is on or off/powering up
        ramblock2: packed enum(u1) {
            ///Off
            off = 0,
            ///On
            on = 1,
        } = .off,
        ///RAMBLOCK3 [3:3]
        ///RAM block 3 is on or off/powering up
        ramblock3: packed enum(u1) {
            ///Off
            off = 0,
            ///On
            on = 1,
        } = .off,
        _unused4: u28 = 0,
    };
    ///Deprecated register - RAM status register
    pub const ramstatus = RegisterRW(ramstatus_val, void).init(0x40000000 + 0x428);

    //////////////////////////
    ///USBREGSTATUS
    const usbregstatus_val = packed struct {
        ///VBUSDETECT [0:0]
        ///VBUS input detection status (USBDETECTED and USBREMOVED events are derived from this information)
        vbusdetect: packed enum(u1) {
            ///VBUS voltage below valid threshold
            no_vbus = 0,
            ///VBUS voltage above valid threshold
            vbus_present = 1,
        } = .no_vbus,
        ///OUTPUTRDY [1:1]
        ///USB supply output settling time elapsed
        outputrdy: packed enum(u1) {
            ///USBREG output settling time not elapsed
            not_ready = 0,
            ///USBREG output settling time elapsed (same information as USBPWRRDY event)
            ready = 1,
        } = .not_ready,
        _unused2: u30 = 0,
    };
    ///USB supply status
    pub const usbregstatus = RegisterRW(usbregstatus_val, void).init(0x40000000 + 0x438);

    //////////////////////////
    ///SYSTEMOFF
    const systemoff_val = packed struct {
        ///SYSTEMOFF [0:0]
        ///Enable System OFF mode
        systemoff: packed enum(u1) {
            ///Enable System OFF mode
            enter = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///System OFF register
    pub const systemoff = RegisterRW(void, systemoff_val).init(0x40000000 + 0x500);

    //////////////////////////
    ///POFCON
    const pofcon_val = packed struct {
        ///POF [0:0]
        ///Enable or disable power failure warning
        pof: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///THRESHOLD [1:4]
        ///Power-fail comparator threshold setting. This setting applies both for normal voltage mode (supply connected to both VDD and VDDH) and high voltage mode (supply connected to VDDH only). Values 0-3 set threshold below 1.7 V and should not be used as brown out detection will be activated before power failure warning on such low voltages.
        threshold: packed enum(u4) {
            ///Set threshold to 1.7 V
            v17 = 4,
            ///Set threshold to 1.8 V
            v18 = 5,
            ///Set threshold to 1.9 V
            v19 = 6,
            ///Set threshold to 2.0 V
            v20 = 7,
            ///Set threshold to 2.1 V
            v21 = 8,
            ///Set threshold to 2.2 V
            v22 = 9,
            ///Set threshold to 2.3 V
            v23 = 10,
            ///Set threshold to 2.4 V
            v24 = 11,
            ///Set threshold to 2.5 V
            v25 = 12,
            ///Set threshold to 2.6 V
            v26 = 13,
            ///Set threshold to 2.7 V
            v27 = 14,
            ///Set threshold to 2.8 V
            v28 = 15,
            _zero = 0,
        } = ._zero,
        _unused5: u3 = 0,
        ///THRESHOLDVDDH [8:11]
        ///Power-fail comparator threshold setting for high voltage mode (supply connected to VDDH only). This setting does not apply for normal voltage mode (supply connected to both VDD and VDDH).
        thresholdvddh: packed enum(u4) {
            ///Set threshold to 2.7 V
            v27 = 0,
            ///Set threshold to 2.8 V
            v28 = 1,
            ///Set threshold to 2.9 V
            v29 = 2,
            ///Set threshold to 3.0 V
            v30 = 3,
            ///Set threshold to 3.1 V
            v31 = 4,
            ///Set threshold to 3.2 V
            v32 = 5,
            ///Set threshold to 3.3 V
            v33 = 6,
            ///Set threshold to 3.4 V
            v34 = 7,
            ///Set threshold to 3.5 V
            v35 = 8,
            ///Set threshold to 3.6 V
            v36 = 9,
            ///Set threshold to 3.7 V
            v37 = 10,
            ///Set threshold to 3.8 V
            v38 = 11,
            ///Set threshold to 3.9 V
            v39 = 12,
            ///Set threshold to 4.0 V
            v40 = 13,
            ///Set threshold to 4.1 V
            v41 = 14,
            ///Set threshold to 4.2 V
            v42 = 15,
        } = .v27,
        _unused12: u20 = 0,
    };
    ///Power-fail comparator configuration
    pub const pofcon = Register(pofcon_val).init(0x40000000 + 0x510);

    //////////////////////////
    ///GPREGRET
    const gpregret_val = packed struct {
        ///GPREGRET [0:7]
        ///General purpose retention register
        gpregret: u8 = 0,
        _unused8: u24 = 0,
    };
    ///General purpose retention register
    pub const gpregret = Register(gpregret_val).init(0x40000000 + 0x51C);

    //////////////////////////
    ///GPREGRET2
    const gpregret2_val = packed struct {
        ///GPREGRET [0:7]
        ///General purpose retention register
        gpregret: u8 = 0,
        _unused8: u24 = 0,
    };
    ///General purpose retention register
    pub const gpregret2 = Register(gpregret2_val).init(0x40000000 + 0x520);

    //////////////////////////
    ///DCDCEN
    const dcdcen_val = packed struct {
        ///DCDCEN [0:0]
        ///Enable DC/DC converter for REG1 stage.
        dcdcen: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Enable DC/DC converter for REG1 stage
    pub const dcdcen = Register(dcdcen_val).init(0x40000000 + 0x578);

    //////////////////////////
    ///MAINREGSTATUS
    const mainregstatus_val = packed struct {
        ///MAINREGSTATUS [0:0]
        ///Main supply status
        mainregstatus: packed enum(u1) {
            ///Normal voltage mode. Voltage supplied on VDD.
            normal = 0,
            ///High voltage mode. Voltage supplied on VDDH.
            high = 1,
        } = .normal,
        _unused1: u31 = 0,
    };
    ///Main supply status
    pub const mainregstatus = RegisterRW(mainregstatus_val, void).init(0x40000000 + 0x640);
};

///GPIO Port 1
pub const p0 = struct {

    //////////////////////////
    ///OUT
    const out_val = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
    };
    ///Write GPIO port
    pub const out = Register(out_val).init(0x50000000 + 0x504);

    //////////////////////////
    ///OUTSET
    const outset_val_read = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
    };
    const outset_val_write = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
    };
    ///Set individual bits in GPIO port
    pub const outset = RegisterRW(outset_val_read, outset_val_write).init(0x50000000 + 0x508);

    //////////////////////////
    ///OUTCLR
    const outclr_val_read = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
    };
    const outclr_val_write = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
    };
    ///Clear individual bits in GPIO port
    pub const outclr = RegisterRW(outclr_val_read, outclr_val_write).init(0x50000000 + 0x50C);

    //////////////////////////
    ///IN
    const in_val = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
    };
    ///Read GPIO port
    pub const in = RegisterRW(in_val, void).init(0x50000000 + 0x510);

    //////////////////////////
    ///DIR
    const dir_val = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
    };
    ///Direction of GPIO pins
    pub const dir = Register(dir_val).init(0x50000000 + 0x514);

    //////////////////////////
    ///DIRSET
    const dirset_val_read = packed struct {
        ///PIN0 [0:0]
        ///Set as output pin 0
        pin0: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN1 [1:1]
        ///Set as output pin 1
        pin1: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN2 [2:2]
        ///Set as output pin 2
        pin2: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN3 [3:3]
        ///Set as output pin 3
        pin3: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN4 [4:4]
        ///Set as output pin 4
        pin4: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN5 [5:5]
        ///Set as output pin 5
        pin5: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN6 [6:6]
        ///Set as output pin 6
        pin6: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN7 [7:7]
        ///Set as output pin 7
        pin7: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN8 [8:8]
        ///Set as output pin 8
        pin8: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN9 [9:9]
        ///Set as output pin 9
        pin9: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN10 [10:10]
        ///Set as output pin 10
        pin10: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN11 [11:11]
        ///Set as output pin 11
        pin11: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN12 [12:12]
        ///Set as output pin 12
        pin12: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN13 [13:13]
        ///Set as output pin 13
        pin13: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN14 [14:14]
        ///Set as output pin 14
        pin14: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN15 [15:15]
        ///Set as output pin 15
        pin15: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN16 [16:16]
        ///Set as output pin 16
        pin16: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN17 [17:17]
        ///Set as output pin 17
        pin17: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN18 [18:18]
        ///Set as output pin 18
        pin18: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN19 [19:19]
        ///Set as output pin 19
        pin19: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN20 [20:20]
        ///Set as output pin 20
        pin20: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN21 [21:21]
        ///Set as output pin 21
        pin21: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN22 [22:22]
        ///Set as output pin 22
        pin22: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN23 [23:23]
        ///Set as output pin 23
        pin23: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN24 [24:24]
        ///Set as output pin 24
        pin24: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN25 [25:25]
        ///Set as output pin 25
        pin25: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN26 [26:26]
        ///Set as output pin 26
        pin26: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN27 [27:27]
        ///Set as output pin 27
        pin27: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN28 [28:28]
        ///Set as output pin 28
        pin28: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN29 [29:29]
        ///Set as output pin 29
        pin29: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN30 [30:30]
        ///Set as output pin 30
        pin30: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN31 [31:31]
        ///Set as output pin 31
        pin31: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
    };
    const dirset_val_write = packed struct {
        ///PIN0 [0:0]
        ///Set as output pin 0
        pin0: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN1 [1:1]
        ///Set as output pin 1
        pin1: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN2 [2:2]
        ///Set as output pin 2
        pin2: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN3 [3:3]
        ///Set as output pin 3
        pin3: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN4 [4:4]
        ///Set as output pin 4
        pin4: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN5 [5:5]
        ///Set as output pin 5
        pin5: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN6 [6:6]
        ///Set as output pin 6
        pin6: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN7 [7:7]
        ///Set as output pin 7
        pin7: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN8 [8:8]
        ///Set as output pin 8
        pin8: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN9 [9:9]
        ///Set as output pin 9
        pin9: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN10 [10:10]
        ///Set as output pin 10
        pin10: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN11 [11:11]
        ///Set as output pin 11
        pin11: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN12 [12:12]
        ///Set as output pin 12
        pin12: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN13 [13:13]
        ///Set as output pin 13
        pin13: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN14 [14:14]
        ///Set as output pin 14
        pin14: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN15 [15:15]
        ///Set as output pin 15
        pin15: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN16 [16:16]
        ///Set as output pin 16
        pin16: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN17 [17:17]
        ///Set as output pin 17
        pin17: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN18 [18:18]
        ///Set as output pin 18
        pin18: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN19 [19:19]
        ///Set as output pin 19
        pin19: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN20 [20:20]
        ///Set as output pin 20
        pin20: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN21 [21:21]
        ///Set as output pin 21
        pin21: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN22 [22:22]
        ///Set as output pin 22
        pin22: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN23 [23:23]
        ///Set as output pin 23
        pin23: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN24 [24:24]
        ///Set as output pin 24
        pin24: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN25 [25:25]
        ///Set as output pin 25
        pin25: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN26 [26:26]
        ///Set as output pin 26
        pin26: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN27 [27:27]
        ///Set as output pin 27
        pin27: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN28 [28:28]
        ///Set as output pin 28
        pin28: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN29 [29:29]
        ///Set as output pin 29
        pin29: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN30 [30:30]
        ///Set as output pin 30
        pin30: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN31 [31:31]
        ///Set as output pin 31
        pin31: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
    };
    ///DIR set register
    pub const dirset = RegisterRW(dirset_val_read, dirset_val_write).init(0x50000000 + 0x518);

    //////////////////////////
    ///DIRCLR
    const dirclr_val_read = packed struct {
        ///PIN0 [0:0]
        ///Set as input pin 0
        pin0: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN1 [1:1]
        ///Set as input pin 1
        pin1: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN2 [2:2]
        ///Set as input pin 2
        pin2: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN3 [3:3]
        ///Set as input pin 3
        pin3: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN4 [4:4]
        ///Set as input pin 4
        pin4: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN5 [5:5]
        ///Set as input pin 5
        pin5: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN6 [6:6]
        ///Set as input pin 6
        pin6: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN7 [7:7]
        ///Set as input pin 7
        pin7: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN8 [8:8]
        ///Set as input pin 8
        pin8: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN9 [9:9]
        ///Set as input pin 9
        pin9: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN10 [10:10]
        ///Set as input pin 10
        pin10: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN11 [11:11]
        ///Set as input pin 11
        pin11: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN12 [12:12]
        ///Set as input pin 12
        pin12: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN13 [13:13]
        ///Set as input pin 13
        pin13: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN14 [14:14]
        ///Set as input pin 14
        pin14: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN15 [15:15]
        ///Set as input pin 15
        pin15: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN16 [16:16]
        ///Set as input pin 16
        pin16: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN17 [17:17]
        ///Set as input pin 17
        pin17: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN18 [18:18]
        ///Set as input pin 18
        pin18: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN19 [19:19]
        ///Set as input pin 19
        pin19: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN20 [20:20]
        ///Set as input pin 20
        pin20: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN21 [21:21]
        ///Set as input pin 21
        pin21: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN22 [22:22]
        ///Set as input pin 22
        pin22: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN23 [23:23]
        ///Set as input pin 23
        pin23: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN24 [24:24]
        ///Set as input pin 24
        pin24: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN25 [25:25]
        ///Set as input pin 25
        pin25: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN26 [26:26]
        ///Set as input pin 26
        pin26: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN27 [27:27]
        ///Set as input pin 27
        pin27: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN28 [28:28]
        ///Set as input pin 28
        pin28: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN29 [29:29]
        ///Set as input pin 29
        pin29: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN30 [30:30]
        ///Set as input pin 30
        pin30: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN31 [31:31]
        ///Set as input pin 31
        pin31: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
    };
    const dirclr_val_write = packed struct {
        ///PIN0 [0:0]
        ///Set as input pin 0
        pin0: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN1 [1:1]
        ///Set as input pin 1
        pin1: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN2 [2:2]
        ///Set as input pin 2
        pin2: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN3 [3:3]
        ///Set as input pin 3
        pin3: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN4 [4:4]
        ///Set as input pin 4
        pin4: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN5 [5:5]
        ///Set as input pin 5
        pin5: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN6 [6:6]
        ///Set as input pin 6
        pin6: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN7 [7:7]
        ///Set as input pin 7
        pin7: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN8 [8:8]
        ///Set as input pin 8
        pin8: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN9 [9:9]
        ///Set as input pin 9
        pin9: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN10 [10:10]
        ///Set as input pin 10
        pin10: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN11 [11:11]
        ///Set as input pin 11
        pin11: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN12 [12:12]
        ///Set as input pin 12
        pin12: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN13 [13:13]
        ///Set as input pin 13
        pin13: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN14 [14:14]
        ///Set as input pin 14
        pin14: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN15 [15:15]
        ///Set as input pin 15
        pin15: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN16 [16:16]
        ///Set as input pin 16
        pin16: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN17 [17:17]
        ///Set as input pin 17
        pin17: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN18 [18:18]
        ///Set as input pin 18
        pin18: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN19 [19:19]
        ///Set as input pin 19
        pin19: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN20 [20:20]
        ///Set as input pin 20
        pin20: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN21 [21:21]
        ///Set as input pin 21
        pin21: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN22 [22:22]
        ///Set as input pin 22
        pin22: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN23 [23:23]
        ///Set as input pin 23
        pin23: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN24 [24:24]
        ///Set as input pin 24
        pin24: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN25 [25:25]
        ///Set as input pin 25
        pin25: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN26 [26:26]
        ///Set as input pin 26
        pin26: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN27 [27:27]
        ///Set as input pin 27
        pin27: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN28 [28:28]
        ///Set as input pin 28
        pin28: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN29 [29:29]
        ///Set as input pin 29
        pin29: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN30 [30:30]
        ///Set as input pin 30
        pin30: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN31 [31:31]
        ///Set as input pin 31
        pin31: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
    };
    ///DIR clear register
    pub const dirclr = RegisterRW(dirclr_val_read, dirclr_val_write).init(0x50000000 + 0x51C);

    //////////////////////////
    ///LATCH
    const latch_val = packed struct {
        ///PIN0 [0:0]
        ///Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear.
        pin0: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN1 [1:1]
        ///Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear.
        pin1: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN2 [2:2]
        ///Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear.
        pin2: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN3 [3:3]
        ///Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear.
        pin3: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN4 [4:4]
        ///Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear.
        pin4: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN5 [5:5]
        ///Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear.
        pin5: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN6 [6:6]
        ///Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear.
        pin6: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN7 [7:7]
        ///Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear.
        pin7: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN8 [8:8]
        ///Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear.
        pin8: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN9 [9:9]
        ///Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear.
        pin9: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN10 [10:10]
        ///Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear.
        pin10: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN11 [11:11]
        ///Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear.
        pin11: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN12 [12:12]
        ///Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear.
        pin12: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN13 [13:13]
        ///Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear.
        pin13: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN14 [14:14]
        ///Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear.
        pin14: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN15 [15:15]
        ///Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear.
        pin15: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN16 [16:16]
        ///Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear.
        pin16: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN17 [17:17]
        ///Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear.
        pin17: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN18 [18:18]
        ///Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear.
        pin18: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN19 [19:19]
        ///Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear.
        pin19: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN20 [20:20]
        ///Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear.
        pin20: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN21 [21:21]
        ///Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear.
        pin21: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN22 [22:22]
        ///Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear.
        pin22: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN23 [23:23]
        ///Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear.
        pin23: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN24 [24:24]
        ///Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear.
        pin24: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN25 [25:25]
        ///Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear.
        pin25: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN26 [26:26]
        ///Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear.
        pin26: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN27 [27:27]
        ///Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear.
        pin27: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN28 [28:28]
        ///Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear.
        pin28: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN29 [29:29]
        ///Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear.
        pin29: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN30 [30:30]
        ///Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear.
        pin30: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN31 [31:31]
        ///Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear.
        pin31: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
    };
    ///Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers
    pub const latch = Register(latch_val).init(0x50000000 + 0x520);

    //////////////////////////
    ///DETECTMODE
    const detectmode_val = packed struct {
        ///DETECTMODE [0:0]
        ///Select between default DETECT signal behaviour and LDETECT mode
        detectmode: packed enum(u1) {
            ///DETECT directly connected to PIN DETECT signals
            default = 0,
            ///Use the latched LDETECT behaviour
            ldetect = 1,
        } = .default,
        _unused1: u31 = 0,
    };
    ///Select between default DETECT signal behaviour and LDETECT mode
    pub const detectmode = Register(detectmode_val).init(0x50000000 + 0x524);

    //////////////////////////
    ///PIN_CNF[%s]
    const pin_cnf_val = packed struct {
        ///DIR [0:0]
        ///Pin direction. Same physical register as DIR register
        dir: packed enum(u1) {
            ///Configure pin as an input pin
            input = 0,
            ///Configure pin as an output pin
            output = 1,
        } = .input,
        ///INPUT [1:1]
        ///Connect or disconnect input buffer
        input: packed enum(u1) {
            ///Connect input buffer
            connect = 0,
            ///Disconnect input buffer
            disconnect = 1,
        } = .disconnect,
        ///PULL [2:3]
        ///Pull configuration
        pull: packed enum(u2) {
            ///No pull
            disabled = 0,
            ///Pull down on pin
            pulldown = 1,
            ///Pull up on pin
            pullup = 3,
        } = .disabled,
        _unused4: u4 = 0,
        ///DRIVE [8:10]
        ///Drive configuration
        drive: packed enum(u3) {
            ///Standard '0', standard '1'
            s0s1 = 0,
            ///High drive '0', standard '1'
            h0s1 = 1,
            ///Standard '0', high drive '1'
            s0h1 = 2,
            ///High drive '0', high 'drive '1''
            h0h1 = 3,
            ///Disconnect '0' standard '1' (normally used for wired-or connections)
            d0s1 = 4,
            ///Disconnect '0', high drive '1' (normally used for wired-or connections)
            d0h1 = 5,
            ///Standard '0'. disconnect '1' (normally used for wired-and connections)
            s0d1 = 6,
            ///High drive '0', disconnect '1' (normally used for wired-and connections)
            h0d1 = 7,
        } = .s0s1,
        _unused11: u5 = 0,
        ///SENSE [16:17]
        ///Pin sensing mechanism
        sense: packed enum(u2) {
            ///Disabled
            disabled = 0,
            ///Sense for high level
            high = 2,
            ///Sense for low level
            low = 3,
        } = .disabled,
        _unused18: u14 = 0,
    };
    ///Description collection: Configuration of GPIO pins
    pub const pin_cnf = Register(pin_cnf_val).initRange(0x50000000 + 0x700, 4, 32);
};

///GPIO Port 2
pub const p1 = struct {

    //////////////////////////
    ///OUT
    const out_val = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Pin driver is low
            low = 0,
            ///Pin driver is high
            high = 1,
        } = .low,
    };
    ///Write GPIO port
    pub const out = Register(out_val).init(0x50000300 + 0x504);

    //////////////////////////
    ///OUTSET
    const outset_val_read = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
    };
    const outset_val_write = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Write: writing a '1' sets the pin high; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
    };
    ///Set individual bits in GPIO port
    pub const outset = RegisterRW(outset_val_read, outset_val_write).init(0x50000300 + 0x508);

    //////////////////////////
    ///OUTCLR
    const outclr_val_read = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Read: pin driver is low
            low = 0,
            ///Read: pin driver is high
            high = 1,
        } = .low,
    };
    const outclr_val_write = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Write: writing a '1' sets the pin low; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
    };
    ///Clear individual bits in GPIO port
    pub const outclr = RegisterRW(outclr_val_read, outclr_val_write).init(0x50000300 + 0x50C);

    //////////////////////////
    ///IN
    const in_val = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Pin input is low
            low = 0,
            ///Pin input is high
            high = 1,
        } = .low,
    };
    ///Read GPIO port
    pub const in = RegisterRW(in_val, void).init(0x50000300 + 0x510);

    //////////////////////////
    ///DIR
    const dir_val = packed struct {
        ///PIN0 [0:0]
        ///Pin 0
        pin0: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN1 [1:1]
        ///Pin 1
        pin1: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN2 [2:2]
        ///Pin 2
        pin2: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN3 [3:3]
        ///Pin 3
        pin3: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN4 [4:4]
        ///Pin 4
        pin4: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN5 [5:5]
        ///Pin 5
        pin5: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN6 [6:6]
        ///Pin 6
        pin6: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN7 [7:7]
        ///Pin 7
        pin7: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN8 [8:8]
        ///Pin 8
        pin8: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN9 [9:9]
        ///Pin 9
        pin9: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN10 [10:10]
        ///Pin 10
        pin10: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN11 [11:11]
        ///Pin 11
        pin11: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN12 [12:12]
        ///Pin 12
        pin12: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN13 [13:13]
        ///Pin 13
        pin13: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN14 [14:14]
        ///Pin 14
        pin14: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN15 [15:15]
        ///Pin 15
        pin15: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN16 [16:16]
        ///Pin 16
        pin16: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN17 [17:17]
        ///Pin 17
        pin17: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN18 [18:18]
        ///Pin 18
        pin18: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN19 [19:19]
        ///Pin 19
        pin19: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN20 [20:20]
        ///Pin 20
        pin20: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN21 [21:21]
        ///Pin 21
        pin21: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN22 [22:22]
        ///Pin 22
        pin22: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN23 [23:23]
        ///Pin 23
        pin23: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN24 [24:24]
        ///Pin 24
        pin24: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN25 [25:25]
        ///Pin 25
        pin25: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN26 [26:26]
        ///Pin 26
        pin26: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN27 [27:27]
        ///Pin 27
        pin27: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN28 [28:28]
        ///Pin 28
        pin28: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN29 [29:29]
        ///Pin 29
        pin29: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN30 [30:30]
        ///Pin 30
        pin30: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
        ///PIN31 [31:31]
        ///Pin 31
        pin31: packed enum(u1) {
            ///Pin set as input
            input = 0,
            ///Pin set as output
            output = 1,
        } = .input,
    };
    ///Direction of GPIO pins
    pub const dir = Register(dir_val).init(0x50000300 + 0x514);

    //////////////////////////
    ///DIRSET
    const dirset_val_read = packed struct {
        ///PIN0 [0:0]
        ///Set as output pin 0
        pin0: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN1 [1:1]
        ///Set as output pin 1
        pin1: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN2 [2:2]
        ///Set as output pin 2
        pin2: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN3 [3:3]
        ///Set as output pin 3
        pin3: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN4 [4:4]
        ///Set as output pin 4
        pin4: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN5 [5:5]
        ///Set as output pin 5
        pin5: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN6 [6:6]
        ///Set as output pin 6
        pin6: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN7 [7:7]
        ///Set as output pin 7
        pin7: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN8 [8:8]
        ///Set as output pin 8
        pin8: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN9 [9:9]
        ///Set as output pin 9
        pin9: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN10 [10:10]
        ///Set as output pin 10
        pin10: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN11 [11:11]
        ///Set as output pin 11
        pin11: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN12 [12:12]
        ///Set as output pin 12
        pin12: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN13 [13:13]
        ///Set as output pin 13
        pin13: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN14 [14:14]
        ///Set as output pin 14
        pin14: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN15 [15:15]
        ///Set as output pin 15
        pin15: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN16 [16:16]
        ///Set as output pin 16
        pin16: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN17 [17:17]
        ///Set as output pin 17
        pin17: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN18 [18:18]
        ///Set as output pin 18
        pin18: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN19 [19:19]
        ///Set as output pin 19
        pin19: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN20 [20:20]
        ///Set as output pin 20
        pin20: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN21 [21:21]
        ///Set as output pin 21
        pin21: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN22 [22:22]
        ///Set as output pin 22
        pin22: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN23 [23:23]
        ///Set as output pin 23
        pin23: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN24 [24:24]
        ///Set as output pin 24
        pin24: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN25 [25:25]
        ///Set as output pin 25
        pin25: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN26 [26:26]
        ///Set as output pin 26
        pin26: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN27 [27:27]
        ///Set as output pin 27
        pin27: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN28 [28:28]
        ///Set as output pin 28
        pin28: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN29 [29:29]
        ///Set as output pin 29
        pin29: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN30 [30:30]
        ///Set as output pin 30
        pin30: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN31 [31:31]
        ///Set as output pin 31
        pin31: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
    };
    const dirset_val_write = packed struct {
        ///PIN0 [0:0]
        ///Set as output pin 0
        pin0: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN1 [1:1]
        ///Set as output pin 1
        pin1: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN2 [2:2]
        ///Set as output pin 2
        pin2: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN3 [3:3]
        ///Set as output pin 3
        pin3: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN4 [4:4]
        ///Set as output pin 4
        pin4: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN5 [5:5]
        ///Set as output pin 5
        pin5: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN6 [6:6]
        ///Set as output pin 6
        pin6: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN7 [7:7]
        ///Set as output pin 7
        pin7: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN8 [8:8]
        ///Set as output pin 8
        pin8: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN9 [9:9]
        ///Set as output pin 9
        pin9: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN10 [10:10]
        ///Set as output pin 10
        pin10: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN11 [11:11]
        ///Set as output pin 11
        pin11: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN12 [12:12]
        ///Set as output pin 12
        pin12: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN13 [13:13]
        ///Set as output pin 13
        pin13: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN14 [14:14]
        ///Set as output pin 14
        pin14: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN15 [15:15]
        ///Set as output pin 15
        pin15: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN16 [16:16]
        ///Set as output pin 16
        pin16: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN17 [17:17]
        ///Set as output pin 17
        pin17: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN18 [18:18]
        ///Set as output pin 18
        pin18: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN19 [19:19]
        ///Set as output pin 19
        pin19: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN20 [20:20]
        ///Set as output pin 20
        pin20: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN21 [21:21]
        ///Set as output pin 21
        pin21: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN22 [22:22]
        ///Set as output pin 22
        pin22: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN23 [23:23]
        ///Set as output pin 23
        pin23: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN24 [24:24]
        ///Set as output pin 24
        pin24: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN25 [25:25]
        ///Set as output pin 25
        pin25: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN26 [26:26]
        ///Set as output pin 26
        pin26: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN27 [27:27]
        ///Set as output pin 27
        pin27: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN28 [28:28]
        ///Set as output pin 28
        pin28: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN29 [29:29]
        ///Set as output pin 29
        pin29: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN30 [30:30]
        ///Set as output pin 30
        pin30: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PIN31 [31:31]
        ///Set as output pin 31
        pin31: packed enum(u1) {
            ///Write: writing a '1' sets pin to output; writing a '0' has no effect
            set = 1,
            _zero = 0,
        } = ._zero,
    };
    ///DIR set register
    pub const dirset = RegisterRW(dirset_val_read, dirset_val_write).init(0x50000300 + 0x518);

    //////////////////////////
    ///DIRCLR
    const dirclr_val_read = packed struct {
        ///PIN0 [0:0]
        ///Set as input pin 0
        pin0: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN1 [1:1]
        ///Set as input pin 1
        pin1: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN2 [2:2]
        ///Set as input pin 2
        pin2: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN3 [3:3]
        ///Set as input pin 3
        pin3: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN4 [4:4]
        ///Set as input pin 4
        pin4: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN5 [5:5]
        ///Set as input pin 5
        pin5: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN6 [6:6]
        ///Set as input pin 6
        pin6: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN7 [7:7]
        ///Set as input pin 7
        pin7: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN8 [8:8]
        ///Set as input pin 8
        pin8: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN9 [9:9]
        ///Set as input pin 9
        pin9: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN10 [10:10]
        ///Set as input pin 10
        pin10: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN11 [11:11]
        ///Set as input pin 11
        pin11: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN12 [12:12]
        ///Set as input pin 12
        pin12: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN13 [13:13]
        ///Set as input pin 13
        pin13: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN14 [14:14]
        ///Set as input pin 14
        pin14: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN15 [15:15]
        ///Set as input pin 15
        pin15: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN16 [16:16]
        ///Set as input pin 16
        pin16: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN17 [17:17]
        ///Set as input pin 17
        pin17: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN18 [18:18]
        ///Set as input pin 18
        pin18: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN19 [19:19]
        ///Set as input pin 19
        pin19: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN20 [20:20]
        ///Set as input pin 20
        pin20: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN21 [21:21]
        ///Set as input pin 21
        pin21: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN22 [22:22]
        ///Set as input pin 22
        pin22: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN23 [23:23]
        ///Set as input pin 23
        pin23: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN24 [24:24]
        ///Set as input pin 24
        pin24: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN25 [25:25]
        ///Set as input pin 25
        pin25: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN26 [26:26]
        ///Set as input pin 26
        pin26: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN27 [27:27]
        ///Set as input pin 27
        pin27: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN28 [28:28]
        ///Set as input pin 28
        pin28: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN29 [29:29]
        ///Set as input pin 29
        pin29: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN30 [30:30]
        ///Set as input pin 30
        pin30: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
        ///PIN31 [31:31]
        ///Set as input pin 31
        pin31: packed enum(u1) {
            ///Read: pin set as input
            input = 0,
            ///Read: pin set as output
            output = 1,
        } = .input,
    };
    const dirclr_val_write = packed struct {
        ///PIN0 [0:0]
        ///Set as input pin 0
        pin0: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN1 [1:1]
        ///Set as input pin 1
        pin1: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN2 [2:2]
        ///Set as input pin 2
        pin2: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN3 [3:3]
        ///Set as input pin 3
        pin3: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN4 [4:4]
        ///Set as input pin 4
        pin4: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN5 [5:5]
        ///Set as input pin 5
        pin5: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN6 [6:6]
        ///Set as input pin 6
        pin6: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN7 [7:7]
        ///Set as input pin 7
        pin7: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN8 [8:8]
        ///Set as input pin 8
        pin8: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN9 [9:9]
        ///Set as input pin 9
        pin9: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN10 [10:10]
        ///Set as input pin 10
        pin10: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN11 [11:11]
        ///Set as input pin 11
        pin11: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN12 [12:12]
        ///Set as input pin 12
        pin12: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN13 [13:13]
        ///Set as input pin 13
        pin13: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN14 [14:14]
        ///Set as input pin 14
        pin14: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN15 [15:15]
        ///Set as input pin 15
        pin15: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN16 [16:16]
        ///Set as input pin 16
        pin16: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN17 [17:17]
        ///Set as input pin 17
        pin17: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN18 [18:18]
        ///Set as input pin 18
        pin18: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN19 [19:19]
        ///Set as input pin 19
        pin19: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN20 [20:20]
        ///Set as input pin 20
        pin20: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN21 [21:21]
        ///Set as input pin 21
        pin21: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN22 [22:22]
        ///Set as input pin 22
        pin22: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN23 [23:23]
        ///Set as input pin 23
        pin23: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN24 [24:24]
        ///Set as input pin 24
        pin24: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN25 [25:25]
        ///Set as input pin 25
        pin25: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN26 [26:26]
        ///Set as input pin 26
        pin26: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN27 [27:27]
        ///Set as input pin 27
        pin27: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN28 [28:28]
        ///Set as input pin 28
        pin28: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN29 [29:29]
        ///Set as input pin 29
        pin29: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN30 [30:30]
        ///Set as input pin 30
        pin30: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PIN31 [31:31]
        ///Set as input pin 31
        pin31: packed enum(u1) {
            ///Write: writing a '1' sets pin to input; writing a '0' has no effect
            clear = 1,
            _zero = 0,
        } = ._zero,
    };
    ///DIR clear register
    pub const dirclr = RegisterRW(dirclr_val_read, dirclr_val_write).init(0x50000300 + 0x51C);

    //////////////////////////
    ///LATCH
    const latch_val = packed struct {
        ///PIN0 [0:0]
        ///Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear.
        pin0: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN1 [1:1]
        ///Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear.
        pin1: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN2 [2:2]
        ///Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear.
        pin2: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN3 [3:3]
        ///Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear.
        pin3: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN4 [4:4]
        ///Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear.
        pin4: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN5 [5:5]
        ///Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear.
        pin5: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN6 [6:6]
        ///Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear.
        pin6: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN7 [7:7]
        ///Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear.
        pin7: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN8 [8:8]
        ///Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear.
        pin8: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN9 [9:9]
        ///Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear.
        pin9: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN10 [10:10]
        ///Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear.
        pin10: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN11 [11:11]
        ///Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear.
        pin11: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN12 [12:12]
        ///Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear.
        pin12: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN13 [13:13]
        ///Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear.
        pin13: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN14 [14:14]
        ///Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear.
        pin14: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN15 [15:15]
        ///Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear.
        pin15: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN16 [16:16]
        ///Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear.
        pin16: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN17 [17:17]
        ///Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear.
        pin17: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN18 [18:18]
        ///Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear.
        pin18: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN19 [19:19]
        ///Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear.
        pin19: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN20 [20:20]
        ///Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear.
        pin20: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN21 [21:21]
        ///Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear.
        pin21: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN22 [22:22]
        ///Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear.
        pin22: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN23 [23:23]
        ///Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear.
        pin23: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN24 [24:24]
        ///Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear.
        pin24: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN25 [25:25]
        ///Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear.
        pin25: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN26 [26:26]
        ///Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear.
        pin26: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN27 [27:27]
        ///Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear.
        pin27: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN28 [28:28]
        ///Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear.
        pin28: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN29 [29:29]
        ///Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear.
        pin29: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN30 [30:30]
        ///Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear.
        pin30: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
        ///PIN31 [31:31]
        ///Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear.
        pin31: packed enum(u1) {
            ///Criteria has not been met
            not_latched = 0,
            ///Criteria has been met
            latched = 1,
        } = .not_latched,
    };
    ///Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers
    pub const latch = Register(latch_val).init(0x50000300 + 0x520);

    //////////////////////////
    ///DETECTMODE
    const detectmode_val = packed struct {
        ///DETECTMODE [0:0]
        ///Select between default DETECT signal behaviour and LDETECT mode
        detectmode: packed enum(u1) {
            ///DETECT directly connected to PIN DETECT signals
            default = 0,
            ///Use the latched LDETECT behaviour
            ldetect = 1,
        } = .default,
        _unused1: u31 = 0,
    };
    ///Select between default DETECT signal behaviour and LDETECT mode
    pub const detectmode = Register(detectmode_val).init(0x50000300 + 0x524);

    //////////////////////////
    ///PIN_CNF[%s]
    const pin_cnf_val = packed struct {
        ///DIR [0:0]
        ///Pin direction. Same physical register as DIR register
        dir: packed enum(u1) {
            ///Configure pin as an input pin
            input = 0,
            ///Configure pin as an output pin
            output = 1,
        } = .input,
        ///INPUT [1:1]
        ///Connect or disconnect input buffer
        input: packed enum(u1) {
            ///Connect input buffer
            connect = 0,
            ///Disconnect input buffer
            disconnect = 1,
        } = .disconnect,
        ///PULL [2:3]
        ///Pull configuration
        pull: packed enum(u2) {
            ///No pull
            disabled = 0,
            ///Pull down on pin
            pulldown = 1,
            ///Pull up on pin
            pullup = 3,
        } = .disabled,
        _unused4: u4 = 0,
        ///DRIVE [8:10]
        ///Drive configuration
        drive: packed enum(u3) {
            ///Standard '0', standard '1'
            s0s1 = 0,
            ///High drive '0', standard '1'
            h0s1 = 1,
            ///Standard '0', high drive '1'
            s0h1 = 2,
            ///High drive '0', high 'drive '1''
            h0h1 = 3,
            ///Disconnect '0' standard '1' (normally used for wired-or connections)
            d0s1 = 4,
            ///Disconnect '0', high drive '1' (normally used for wired-or connections)
            d0h1 = 5,
            ///Standard '0'. disconnect '1' (normally used for wired-and connections)
            s0d1 = 6,
            ///High drive '0', disconnect '1' (normally used for wired-and connections)
            h0d1 = 7,
        } = .s0s1,
        _unused11: u5 = 0,
        ///SENSE [16:17]
        ///Pin sensing mechanism
        sense: packed enum(u2) {
            ///Disabled
            disabled = 0,
            ///Sense for high level
            high = 2,
            ///Sense for low level
            low = 3,
        } = .disabled,
        _unused18: u14 = 0,
    };
    ///Description collection: Configuration of GPIO pins
    pub const pin_cnf = Register(pin_cnf_val).initRange(0x50000300 + 0x700, 4, 32);
};

///2.4 GHz radio
pub const radio = struct {

    //////////////////////////
    ///TASKS_TXEN
    const tasks_txen_val = packed struct {
        ///TASKS_TXEN [0:0]
        ///Enable RADIO in TX mode
        tasks_txen: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Enable RADIO in TX mode
    pub const tasks_txen = RegisterRW(void, tasks_txen_val).init(0x40001000 + 0x000);

    //////////////////////////
    ///TASKS_RXEN
    const tasks_rxen_val = packed struct {
        ///TASKS_RXEN [0:0]
        ///Enable RADIO in RX mode
        tasks_rxen: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Enable RADIO in RX mode
    pub const tasks_rxen = RegisterRW(void, tasks_rxen_val).init(0x40001000 + 0x004);

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start RADIO
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start RADIO
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40001000 + 0x008);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop RADIO
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop RADIO
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40001000 + 0x00C);

    //////////////////////////
    ///TASKS_DISABLE
    const tasks_disable_val = packed struct {
        ///TASKS_DISABLE [0:0]
        ///Disable RADIO
        tasks_disable: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Disable RADIO
    pub const tasks_disable = RegisterRW(void, tasks_disable_val).init(0x40001000 + 0x010);

    //////////////////////////
    ///TASKS_RSSISTART
    const tasks_rssistart_val = packed struct {
        ///TASKS_RSSISTART [0:0]
        ///Start the RSSI and take one single sample of the receive signal strength
        tasks_rssistart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start the RSSI and take one single sample of the receive signal strength
    pub const tasks_rssistart = RegisterRW(void, tasks_rssistart_val).init(0x40001000 + 0x014);

    //////////////////////////
    ///TASKS_RSSISTOP
    const tasks_rssistop_val = packed struct {
        ///TASKS_RSSISTOP [0:0]
        ///Stop the RSSI measurement
        tasks_rssistop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop the RSSI measurement
    pub const tasks_rssistop = RegisterRW(void, tasks_rssistop_val).init(0x40001000 + 0x018);

    //////////////////////////
    ///TASKS_BCSTART
    const tasks_bcstart_val = packed struct {
        ///TASKS_BCSTART [0:0]
        ///Start the bit counter
        tasks_bcstart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start the bit counter
    pub const tasks_bcstart = RegisterRW(void, tasks_bcstart_val).init(0x40001000 + 0x01C);

    //////////////////////////
    ///TASKS_BCSTOP
    const tasks_bcstop_val = packed struct {
        ///TASKS_BCSTOP [0:0]
        ///Stop the bit counter
        tasks_bcstop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop the bit counter
    pub const tasks_bcstop = RegisterRW(void, tasks_bcstop_val).init(0x40001000 + 0x020);

    //////////////////////////
    ///TASKS_EDSTART
    const tasks_edstart_val = packed struct {
        ///TASKS_EDSTART [0:0]
        ///Start the energy detect measurement used in IEEE 802.15.4 mode
        tasks_edstart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start the energy detect measurement used in IEEE 802.15.4 mode
    pub const tasks_edstart = RegisterRW(void, tasks_edstart_val).init(0x40001000 + 0x024);

    //////////////////////////
    ///TASKS_EDSTOP
    const tasks_edstop_val = packed struct {
        ///TASKS_EDSTOP [0:0]
        ///Stop the energy detect measurement
        tasks_edstop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop the energy detect measurement
    pub const tasks_edstop = RegisterRW(void, tasks_edstop_val).init(0x40001000 + 0x028);

    //////////////////////////
    ///TASKS_CCASTART
    const tasks_ccastart_val = packed struct {
        ///TASKS_CCASTART [0:0]
        ///Start the clear channel assessment used in IEEE 802.15.4 mode
        tasks_ccastart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start the clear channel assessment used in IEEE 802.15.4 mode
    pub const tasks_ccastart = RegisterRW(void, tasks_ccastart_val).init(0x40001000 + 0x02C);

    //////////////////////////
    ///TASKS_CCASTOP
    const tasks_ccastop_val = packed struct {
        ///TASKS_CCASTOP [0:0]
        ///Stop the clear channel assessment
        tasks_ccastop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop the clear channel assessment
    pub const tasks_ccastop = RegisterRW(void, tasks_ccastop_val).init(0x40001000 + 0x030);

    //////////////////////////
    ///EVENTS_READY
    const events_ready_val = packed struct {
        ///EVENTS_READY [0:0]
        ///RADIO has ramped up and is ready to be started
        events_ready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///RADIO has ramped up and is ready to be started
    pub const events_ready = Register(events_ready_val).init(0x40001000 + 0x100);

    //////////////////////////
    ///EVENTS_ADDRESS
    const events_address_val = packed struct {
        ///EVENTS_ADDRESS [0:0]
        ///Address sent or received
        events_address: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Address sent or received
    pub const events_address = Register(events_address_val).init(0x40001000 + 0x104);

    //////////////////////////
    ///EVENTS_PAYLOAD
    const events_payload_val = packed struct {
        ///EVENTS_PAYLOAD [0:0]
        ///Packet payload sent or received
        events_payload: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Packet payload sent or received
    pub const events_payload = Register(events_payload_val).init(0x40001000 + 0x108);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///Packet sent or received
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Packet sent or received
    pub const events_end = Register(events_end_val).init(0x40001000 + 0x10C);

    //////////////////////////
    ///EVENTS_DISABLED
    const events_disabled_val = packed struct {
        ///EVENTS_DISABLED [0:0]
        ///RADIO has been disabled
        events_disabled: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///RADIO has been disabled
    pub const events_disabled = Register(events_disabled_val).init(0x40001000 + 0x110);

    //////////////////////////
    ///EVENTS_DEVMATCH
    const events_devmatch_val = packed struct {
        ///EVENTS_DEVMATCH [0:0]
        ///A device address match occurred on the last received packet
        events_devmatch: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///A device address match occurred on the last received packet
    pub const events_devmatch = Register(events_devmatch_val).init(0x40001000 + 0x114);

    //////////////////////////
    ///EVENTS_DEVMISS
    const events_devmiss_val = packed struct {
        ///EVENTS_DEVMISS [0:0]
        ///No device address match occurred on the last received packet
        events_devmiss: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///No device address match occurred on the last received packet
    pub const events_devmiss = Register(events_devmiss_val).init(0x40001000 + 0x118);

    //////////////////////////
    ///EVENTS_RSSIEND
    const events_rssiend_val = packed struct {
        ///EVENTS_RSSIEND [0:0]
        ///Sampling of receive signal strength complete
        events_rssiend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Sampling of receive signal strength complete
    pub const events_rssiend = Register(events_rssiend_val).init(0x40001000 + 0x11C);

    //////////////////////////
    ///EVENTS_BCMATCH
    const events_bcmatch_val = packed struct {
        ///EVENTS_BCMATCH [0:0]
        ///Bit counter reached bit count value
        events_bcmatch: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Bit counter reached bit count value
    pub const events_bcmatch = Register(events_bcmatch_val).init(0x40001000 + 0x128);

    //////////////////////////
    ///EVENTS_CRCOK
    const events_crcok_val = packed struct {
        ///EVENTS_CRCOK [0:0]
        ///Packet received with CRC ok
        events_crcok: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Packet received with CRC ok
    pub const events_crcok = Register(events_crcok_val).init(0x40001000 + 0x130);

    //////////////////////////
    ///EVENTS_CRCERROR
    const events_crcerror_val = packed struct {
        ///EVENTS_CRCERROR [0:0]
        ///Packet received with CRC error
        events_crcerror: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Packet received with CRC error
    pub const events_crcerror = Register(events_crcerror_val).init(0x40001000 + 0x134);

    //////////////////////////
    ///EVENTS_FRAMESTART
    const events_framestart_val = packed struct {
        ///EVENTS_FRAMESTART [0:0]
        ///IEEE 802.15.4 length field received
        events_framestart: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///IEEE 802.15.4 length field received
    pub const events_framestart = Register(events_framestart_val).init(0x40001000 + 0x138);

    //////////////////////////
    ///EVENTS_EDEND
    const events_edend_val = packed struct {
        ///EVENTS_EDEND [0:0]
        ///Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register
        events_edend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register
    pub const events_edend = Register(events_edend_val).init(0x40001000 + 0x13C);

    //////////////////////////
    ///EVENTS_EDSTOPPED
    const events_edstopped_val = packed struct {
        ///EVENTS_EDSTOPPED [0:0]
        ///The sampling of energy detection has stopped
        events_edstopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The sampling of energy detection has stopped
    pub const events_edstopped = Register(events_edstopped_val).init(0x40001000 + 0x140);

    //////////////////////////
    ///EVENTS_CCAIDLE
    const events_ccaidle_val = packed struct {
        ///EVENTS_CCAIDLE [0:0]
        ///Wireless medium in idle - clear to send
        events_ccaidle: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Wireless medium in idle - clear to send
    pub const events_ccaidle = Register(events_ccaidle_val).init(0x40001000 + 0x144);

    //////////////////////////
    ///EVENTS_CCABUSY
    const events_ccabusy_val = packed struct {
        ///EVENTS_CCABUSY [0:0]
        ///Wireless medium busy - do not send
        events_ccabusy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Wireless medium busy - do not send
    pub const events_ccabusy = Register(events_ccabusy_val).init(0x40001000 + 0x148);

    //////////////////////////
    ///EVENTS_CCASTOPPED
    const events_ccastopped_val = packed struct {
        ///EVENTS_CCASTOPPED [0:0]
        ///The CCA has stopped
        events_ccastopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The CCA has stopped
    pub const events_ccastopped = Register(events_ccastopped_val).init(0x40001000 + 0x14C);

    //////////////////////////
    ///EVENTS_RATEBOOST
    const events_rateboost_val = packed struct {
        ///EVENTS_RATEBOOST [0:0]
        ///Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit.
        events_rateboost: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit.
    pub const events_rateboost = Register(events_rateboost_val).init(0x40001000 + 0x150);

    //////////////////////////
    ///EVENTS_TXREADY
    const events_txready_val = packed struct {
        ///EVENTS_TXREADY [0:0]
        ///RADIO has ramped up and is ready to be started TX path
        events_txready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///RADIO has ramped up and is ready to be started TX path
    pub const events_txready = Register(events_txready_val).init(0x40001000 + 0x154);

    //////////////////////////
    ///EVENTS_RXREADY
    const events_rxready_val = packed struct {
        ///EVENTS_RXREADY [0:0]
        ///RADIO has ramped up and is ready to be started RX path
        events_rxready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///RADIO has ramped up and is ready to be started RX path
    pub const events_rxready = Register(events_rxready_val).init(0x40001000 + 0x158);

    //////////////////////////
    ///EVENTS_MHRMATCH
    const events_mhrmatch_val = packed struct {
        ///EVENTS_MHRMATCH [0:0]
        ///MAC header match found
        events_mhrmatch: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///MAC header match found
    pub const events_mhrmatch = Register(events_mhrmatch_val).init(0x40001000 + 0x15C);

    //////////////////////////
    ///EVENTS_SYNC
    const events_sync_val = packed struct {
        ///EVENTS_SYNC [0:0]
        ///Preamble indicator
        events_sync: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Preamble indicator
    pub const events_sync = Register(events_sync_val).init(0x40001000 + 0x168);

    //////////////////////////
    ///EVENTS_PHYEND
    const events_phyend_val = packed struct {
        ///EVENTS_PHYEND [0:0]
        ///Generated when last bit is sent on air, or received from air
        events_phyend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Generated when last bit is sent on air, or received from air
    pub const events_phyend = Register(events_phyend_val).init(0x40001000 + 0x16C);

    //////////////////////////
    ///EVENTS_CTEPRESENT
    const events_ctepresent_val = packed struct {
        ///EVENTS_CTEPRESENT [0:0]
        ///CTE is present (early warning right after receiving CTEInfo byte)
        events_ctepresent: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///CTE is present (early warning right after receiving CTEInfo byte)
    pub const events_ctepresent = Register(events_ctepresent_val).init(0x40001000 + 0x170);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///READY_START [0:0]
        ///Shortcut between event READY and task START
        ready_start: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///END_DISABLE [1:1]
        ///Shortcut between event END and task DISABLE
        end_disable: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///DISABLED_TXEN [2:2]
        ///Shortcut between event DISABLED and task TXEN
        disabled_txen: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///DISABLED_RXEN [3:3]
        ///Shortcut between event DISABLED and task RXEN
        disabled_rxen: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///ADDRESS_RSSISTART [4:4]
        ///Shortcut between event ADDRESS and task RSSISTART
        address_rssistart: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///END_START [5:5]
        ///Shortcut between event END and task START
        end_start: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///ADDRESS_BCSTART [6:6]
        ///Shortcut between event ADDRESS and task BCSTART
        address_bcstart: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused7: u1 = 0,
        ///DISABLED_RSSISTOP [8:8]
        ///Shortcut between event DISABLED and task RSSISTOP
        disabled_rssistop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused9: u2 = 0,
        ///RXREADY_CCASTART [11:11]
        ///Shortcut between event RXREADY and task CCASTART
        rxready_ccastart: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///CCAIDLE_TXEN [12:12]
        ///Shortcut between event CCAIDLE and task TXEN
        ccaidle_txen: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///CCABUSY_DISABLE [13:13]
        ///Shortcut between event CCABUSY and task DISABLE
        ccabusy_disable: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///FRAMESTART_BCSTART [14:14]
        ///Shortcut between event FRAMESTART and task BCSTART
        framestart_bcstart: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///READY_EDSTART [15:15]
        ///Shortcut between event READY and task EDSTART
        ready_edstart: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///EDEND_DISABLE [16:16]
        ///Shortcut between event EDEND and task DISABLE
        edend_disable: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///CCAIDLE_STOP [17:17]
        ///Shortcut between event CCAIDLE and task STOP
        ccaidle_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///TXREADY_START [18:18]
        ///Shortcut between event TXREADY and task START
        txready_start: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///RXREADY_START [19:19]
        ///Shortcut between event RXREADY and task START
        rxready_start: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///PHYEND_DISABLE [20:20]
        ///Shortcut between event PHYEND and task DISABLE
        phyend_disable: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///PHYEND_START [21:21]
        ///Shortcut between event PHYEND and task START
        phyend_start: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40001000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///READY [0:0]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ADDRESS [1:1]
        ///Write '1' to enable interrupt for event ADDRESS
        address: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PAYLOAD [2:2]
        ///Write '1' to enable interrupt for event PAYLOAD
        payload: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///END [3:3]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DISABLED [4:4]
        ///Write '1' to enable interrupt for event DISABLED
        disabled: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DEVMATCH [5:5]
        ///Write '1' to enable interrupt for event DEVMATCH
        devmatch: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DEVMISS [6:6]
        ///Write '1' to enable interrupt for event DEVMISS
        devmiss: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RSSIEND [7:7]
        ///Write '1' to enable interrupt for event RSSIEND
        rssiend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u2 = 0,
        ///BCMATCH [10:10]
        ///Write '1' to enable interrupt for event BCMATCH
        bcmatch: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused11: u1 = 0,
        ///CRCOK [12:12]
        ///Write '1' to enable interrupt for event CRCOK
        crcok: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CRCERROR [13:13]
        ///Write '1' to enable interrupt for event CRCERROR
        crcerror: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///FRAMESTART [14:14]
        ///Write '1' to enable interrupt for event FRAMESTART
        framestart: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///EDEND [15:15]
        ///Write '1' to enable interrupt for event EDEND
        edend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///EDSTOPPED [16:16]
        ///Write '1' to enable interrupt for event EDSTOPPED
        edstopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CCAIDLE [17:17]
        ///Write '1' to enable interrupt for event CCAIDLE
        ccaidle: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CCABUSY [18:18]
        ///Write '1' to enable interrupt for event CCABUSY
        ccabusy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CCASTOPPED [19:19]
        ///Write '1' to enable interrupt for event CCASTOPPED
        ccastopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RATEBOOST [20:20]
        ///Write '1' to enable interrupt for event RATEBOOST
        rateboost: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXREADY [21:21]
        ///Write '1' to enable interrupt for event TXREADY
        txready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXREADY [22:22]
        ///Write '1' to enable interrupt for event RXREADY
        rxready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///MHRMATCH [23:23]
        ///Write '1' to enable interrupt for event MHRMATCH
        mhrmatch: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused24: u2 = 0,
        ///SYNC [26:26]
        ///Write '1' to enable interrupt for event SYNC
        sync: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PHYEND [27:27]
        ///Write '1' to enable interrupt for event PHYEND
        phyend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CTEPRESENT [28:28]
        ///Write '1' to enable interrupt for event CTEPRESENT
        ctepresent: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused29: u3 = 0,
    };
    const intenset_val_write = packed struct {
        ///READY [0:0]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ADDRESS [1:1]
        ///Write '1' to enable interrupt for event ADDRESS
        address: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PAYLOAD [2:2]
        ///Write '1' to enable interrupt for event PAYLOAD
        payload: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///END [3:3]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///DISABLED [4:4]
        ///Write '1' to enable interrupt for event DISABLED
        disabled: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///DEVMATCH [5:5]
        ///Write '1' to enable interrupt for event DEVMATCH
        devmatch: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///DEVMISS [6:6]
        ///Write '1' to enable interrupt for event DEVMISS
        devmiss: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RSSIEND [7:7]
        ///Write '1' to enable interrupt for event RSSIEND
        rssiend: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u2 = 0,
        ///BCMATCH [10:10]
        ///Write '1' to enable interrupt for event BCMATCH
        bcmatch: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused11: u1 = 0,
        ///CRCOK [12:12]
        ///Write '1' to enable interrupt for event CRCOK
        crcok: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CRCERROR [13:13]
        ///Write '1' to enable interrupt for event CRCERROR
        crcerror: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///FRAMESTART [14:14]
        ///Write '1' to enable interrupt for event FRAMESTART
        framestart: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///EDEND [15:15]
        ///Write '1' to enable interrupt for event EDEND
        edend: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///EDSTOPPED [16:16]
        ///Write '1' to enable interrupt for event EDSTOPPED
        edstopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CCAIDLE [17:17]
        ///Write '1' to enable interrupt for event CCAIDLE
        ccaidle: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CCABUSY [18:18]
        ///Write '1' to enable interrupt for event CCABUSY
        ccabusy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CCASTOPPED [19:19]
        ///Write '1' to enable interrupt for event CCASTOPPED
        ccastopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RATEBOOST [20:20]
        ///Write '1' to enable interrupt for event RATEBOOST
        rateboost: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TXREADY [21:21]
        ///Write '1' to enable interrupt for event TXREADY
        txready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RXREADY [22:22]
        ///Write '1' to enable interrupt for event RXREADY
        rxready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///MHRMATCH [23:23]
        ///Write '1' to enable interrupt for event MHRMATCH
        mhrmatch: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused24: u2 = 0,
        ///SYNC [26:26]
        ///Write '1' to enable interrupt for event SYNC
        sync: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PHYEND [27:27]
        ///Write '1' to enable interrupt for event PHYEND
        phyend: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CTEPRESENT [28:28]
        ///Write '1' to enable interrupt for event CTEPRESENT
        ctepresent: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused29: u3 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40001000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///READY [0:0]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ADDRESS [1:1]
        ///Write '1' to disable interrupt for event ADDRESS
        address: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PAYLOAD [2:2]
        ///Write '1' to disable interrupt for event PAYLOAD
        payload: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///END [3:3]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DISABLED [4:4]
        ///Write '1' to disable interrupt for event DISABLED
        disabled: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DEVMATCH [5:5]
        ///Write '1' to disable interrupt for event DEVMATCH
        devmatch: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DEVMISS [6:6]
        ///Write '1' to disable interrupt for event DEVMISS
        devmiss: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RSSIEND [7:7]
        ///Write '1' to disable interrupt for event RSSIEND
        rssiend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u2 = 0,
        ///BCMATCH [10:10]
        ///Write '1' to disable interrupt for event BCMATCH
        bcmatch: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused11: u1 = 0,
        ///CRCOK [12:12]
        ///Write '1' to disable interrupt for event CRCOK
        crcok: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CRCERROR [13:13]
        ///Write '1' to disable interrupt for event CRCERROR
        crcerror: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///FRAMESTART [14:14]
        ///Write '1' to disable interrupt for event FRAMESTART
        framestart: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///EDEND [15:15]
        ///Write '1' to disable interrupt for event EDEND
        edend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///EDSTOPPED [16:16]
        ///Write '1' to disable interrupt for event EDSTOPPED
        edstopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CCAIDLE [17:17]
        ///Write '1' to disable interrupt for event CCAIDLE
        ccaidle: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CCABUSY [18:18]
        ///Write '1' to disable interrupt for event CCABUSY
        ccabusy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CCASTOPPED [19:19]
        ///Write '1' to disable interrupt for event CCASTOPPED
        ccastopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RATEBOOST [20:20]
        ///Write '1' to disable interrupt for event RATEBOOST
        rateboost: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXREADY [21:21]
        ///Write '1' to disable interrupt for event TXREADY
        txready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXREADY [22:22]
        ///Write '1' to disable interrupt for event RXREADY
        rxready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///MHRMATCH [23:23]
        ///Write '1' to disable interrupt for event MHRMATCH
        mhrmatch: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused24: u2 = 0,
        ///SYNC [26:26]
        ///Write '1' to disable interrupt for event SYNC
        sync: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PHYEND [27:27]
        ///Write '1' to disable interrupt for event PHYEND
        phyend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CTEPRESENT [28:28]
        ///Write '1' to disable interrupt for event CTEPRESENT
        ctepresent: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused29: u3 = 0,
    };
    const intenclr_val_write = packed struct {
        ///READY [0:0]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ADDRESS [1:1]
        ///Write '1' to disable interrupt for event ADDRESS
        address: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PAYLOAD [2:2]
        ///Write '1' to disable interrupt for event PAYLOAD
        payload: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///END [3:3]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///DISABLED [4:4]
        ///Write '1' to disable interrupt for event DISABLED
        disabled: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///DEVMATCH [5:5]
        ///Write '1' to disable interrupt for event DEVMATCH
        devmatch: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///DEVMISS [6:6]
        ///Write '1' to disable interrupt for event DEVMISS
        devmiss: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RSSIEND [7:7]
        ///Write '1' to disable interrupt for event RSSIEND
        rssiend: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u2 = 0,
        ///BCMATCH [10:10]
        ///Write '1' to disable interrupt for event BCMATCH
        bcmatch: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused11: u1 = 0,
        ///CRCOK [12:12]
        ///Write '1' to disable interrupt for event CRCOK
        crcok: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CRCERROR [13:13]
        ///Write '1' to disable interrupt for event CRCERROR
        crcerror: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///FRAMESTART [14:14]
        ///Write '1' to disable interrupt for event FRAMESTART
        framestart: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///EDEND [15:15]
        ///Write '1' to disable interrupt for event EDEND
        edend: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///EDSTOPPED [16:16]
        ///Write '1' to disable interrupt for event EDSTOPPED
        edstopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CCAIDLE [17:17]
        ///Write '1' to disable interrupt for event CCAIDLE
        ccaidle: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CCABUSY [18:18]
        ///Write '1' to disable interrupt for event CCABUSY
        ccabusy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CCASTOPPED [19:19]
        ///Write '1' to disable interrupt for event CCASTOPPED
        ccastopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RATEBOOST [20:20]
        ///Write '1' to disable interrupt for event RATEBOOST
        rateboost: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TXREADY [21:21]
        ///Write '1' to disable interrupt for event TXREADY
        txready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RXREADY [22:22]
        ///Write '1' to disable interrupt for event RXREADY
        rxready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///MHRMATCH [23:23]
        ///Write '1' to disable interrupt for event MHRMATCH
        mhrmatch: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused24: u2 = 0,
        ///SYNC [26:26]
        ///Write '1' to disable interrupt for event SYNC
        sync: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PHYEND [27:27]
        ///Write '1' to disable interrupt for event PHYEND
        phyend: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CTEPRESENT [28:28]
        ///Write '1' to disable interrupt for event CTEPRESENT
        ctepresent: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused29: u3 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40001000 + 0x308);

    //////////////////////////
    ///CRCSTATUS
    const crcstatus_val = packed struct {
        ///CRCSTATUS [0:0]
        ///CRC status of packet received
        crcstatus: packed enum(u1) {
            ///Packet received with CRC error
            crcerror = 0,
            ///Packet received with CRC ok
            crcok = 1,
        } = .crcerror,
        _unused1: u31 = 0,
    };
    ///CRC status
    pub const crcstatus = RegisterRW(crcstatus_val, void).init(0x40001000 + 0x400);

    //////////////////////////
    ///RXMATCH
    const rxmatch_val = packed struct {
        ///RXMATCH [0:2]
        ///Received address
        rxmatch: u3 = 0,
        _unused3: u29 = 0,
    };
    ///Received address
    pub const rxmatch = RegisterRW(rxmatch_val, void).init(0x40001000 + 0x408);

    //////////////////////////
    ///RXCRC
    const rxcrc_val = packed struct {
        ///RXCRC [0:23]
        ///CRC field of previously received packet
        rxcrc: u24 = 0,
        _unused24: u8 = 0,
    };
    ///CRC field of previously received packet
    pub const rxcrc = RegisterRW(rxcrc_val, void).init(0x40001000 + 0x40C);

    //////////////////////////
    ///DAI
    const dai_val = packed struct {
        ///DAI [0:2]
        ///Device address match index
        dai: u3 = 0,
        _unused3: u29 = 0,
    };
    ///Device address match index
    pub const dai = RegisterRW(dai_val, void).init(0x40001000 + 0x410);

    //////////////////////////
    ///PDUSTAT
    const pdustat_val = packed struct {
        ///PDUSTAT [0:0]
        ///Status on payload length vs. PCNF1.MAXLEN
        pdustat: packed enum(u1) {
            ///Payload less than PCNF1.MAXLEN
            less_than = 0,
            ///Payload greater than PCNF1.MAXLEN
            greater_than = 1,
        } = .less_than,
        ///CISTAT [1:2]
        ///Status on what rate packet is received with in Long Range
        cistat: packed enum(u2) {
            ///Frame is received at 125 kbps
            lr125kbit = 0,
            ///Frame is received at 500 kbps
            lr500kbit = 1,
        } = .lr125kbit,
        _unused3: u29 = 0,
    };
    ///Payload status
    pub const pdustat = RegisterRW(pdustat_val, void).init(0x40001000 + 0x414);

    //////////////////////////
    ///CTESTATUS
    const ctestatus_val = packed struct {
        ///CTETIME [0:4]
        ///CTETime parsed from packet
        ctetime: u5 = 0,
        ///RFU [5:5]
        ///RFU parsed from packet
        rfu: u1 = 0,
        ///CTETYPE [6:7]
        ///CTEType parsed from packet
        ctetype: u2 = 0,
        _unused8: u24 = 0,
    };
    ///CTEInfo parsed from received packet
    pub const ctestatus = RegisterRW(ctestatus_val, void).init(0x40001000 + 0x44C);

    //////////////////////////
    ///DFESTATUS
    const dfestatus_val = packed struct {
        ///SWITCHINGSTATE [0:2]
        ///Internal state of switching state machine
        switchingstate: packed enum(u3) {
            ///Switching state Idle
            idle = 0,
            ///Switching state Offset
            offset = 1,
            ///Switching state Guard
            guard = 2,
            ///Switching state Ref
            ref = 3,
            ///Switching state Switching
            switching = 4,
            ///Switching state Ending
            ending = 5,
        } = .idle,
        _unused3: u1 = 0,
        ///SAMPLINGSTATE [4:4]
        ///Internal state of sampling state machine
        samplingstate: packed enum(u1) {
            ///Sampling state Idle
            idle = 0,
            ///Sampling state Sampling
            sampling = 1,
        } = .idle,
        _unused5: u27 = 0,
    };
    ///DFE status information
    pub const dfestatus = RegisterRW(dfestatus_val, void).init(0x40001000 + 0x458);

    //////////////////////////
    ///PACKETPTR
    const packetptr_val = packed struct {
        ///PACKETPTR [0:31]
        ///Packet pointer
        packetptr: u32 = 0,
    };
    ///Packet pointer
    pub const packetptr = Register(packetptr_val).init(0x40001000 + 0x504);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:6]
        ///Radio channel frequency
        frequency: u7 = 2,
        _unused7: u1 = 0,
        ///MAP [8:8]
        ///Channel map selection.
        map: packed enum(u1) {
            ///Channel map between 2400 MHZ .. 2500 MHz
            default = 0,
            ///Channel map between 2360 MHZ .. 2460 MHz
            low = 1,
        } = .default,
        _unused9: u23 = 0,
    };
    ///Frequency
    pub const frequency = Register(frequency_val).init(0x40001000 + 0x508);

    //////////////////////////
    ///TXPOWER
    const txpower_val = packed struct {
        ///TXPOWER [0:7]
        ///RADIO output power
        txpower: packed enum(u8) {
            ///+8 dBm
            pos8d_bm = 0x8,
            ///+7 dBm
            pos7d_bm = 0x7,
            ///+6 dBm
            pos6d_bm = 0x6,
            ///+5 dBm
            pos5d_bm = 0x5,
            ///+4 dBm
            pos4d_bm = 0x4,
            ///+3 dBm
            pos3d_bm = 0x3,
            ///+2 dBm
            pos2d_bm = 0x2,
            ///0 dBm
            _0d_bm = 0x0,
            ///-4 dBm
            neg4d_bm = 0xFC,
            ///-8 dBm
            neg8d_bm = 0xF8,
            ///-12 dBm
            neg12d_bm = 0xF4,
            ///-16 dBm
            neg16d_bm = 0xF0,
            ///-20 dBm
            neg20d_bm = 0xEC,
            ///Deprecated enumerator -  -40 dBm
            neg30d_bm = 0xE2,
            ///-40 dBm
            neg40d_bm = 0xD8,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///Output power
    pub const txpower = Register(txpower_val).init(0x40001000 + 0x50C);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///MODE [0:3]
        ///Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation.
        mode: packed enum(u4) {
            ///1 Mbps Nordic proprietary radio mode
            nrf_1mbit = 0,
            ///2 Mbps Nordic proprietary radio mode
            nrf_2mbit = 1,
            ///1 Mbps BLE
            ble_1mbit = 3,
            ///2 Mbps BLE
            ble_2mbit = 4,
            ///Long range 125 kbps TX, 125 kbps and 500 kbps RX
            ble_lr125kbit = 5,
            ///Long range 500 kbps TX, 125 kbps and 500 kbps RX
            ble_lr500kbit = 6,
            ///IEEE 802.15.4-2006 250 kbps
            ieee802154_250kbit = 15,
        } = .nrf_1mbit,
        _unused4: u28 = 0,
    };
    ///Data rate and modulation
    pub const mode = Register(mode_val).init(0x40001000 + 0x510);

    //////////////////////////
    ///PCNF0
    const pcnf0_val = packed struct {
        ///LFLEN [0:3]
        ///Length on air of LENGTH field in number of bits.
        lflen: u4 = 0,
        _unused4: u4 = 0,
        ///S0LEN [8:8]
        ///Length on air of S0 field in number of bytes.
        s0len: u1 = 0,
        _unused9: u7 = 0,
        ///S1LEN [16:19]
        ///Length on air of S1 field in number of bits.
        s1len: u4 = 0,
        ///S1INCL [20:20]
        ///Include or exclude S1 field in RAM
        s1incl: packed enum(u1) {
            ///Include S1 field in RAM only if S1LEN &gt; 0
            automatic = 0,
            ///Always include S1 field in RAM independent of S1LEN
            include = 1,
        } = .automatic,
        _unused21: u1 = 0,
        ///CILEN [22:23]
        ///Length of code indicator - long range
        cilen: u2 = 0,
        ///PLEN [24:25]
        ///Length of preamble on air. Decision point: TASKS_START task
        plen: packed enum(u2) {
            ///8-bit preamble
            _8bit = 0,
            ///16-bit preamble
            _16bit = 1,
            ///32-bit zero preamble - used for IEEE 802.15.4
            _32bit_zero = 2,
            ///Preamble - used for BLE long range
            long_range = 3,
        } = ._8bit,
        ///CRCINC [26:26]
        ///Indicates if LENGTH field contains CRC or not
        crcinc: packed enum(u1) {
            ///LENGTH does not contain CRC
            exclude = 0,
            ///LENGTH includes CRC
            include = 1,
        } = .exclude,
        _unused27: u2 = 0,
        ///TERMLEN [29:30]
        ///Length of TERM field in Long Range operation
        termlen: u2 = 0,
        _unused31: u1 = 0,
    };
    ///Packet configuration register 0
    pub const pcnf0 = Register(pcnf0_val).init(0x40001000 + 0x514);

    //////////////////////////
    ///PCNF1
    const pcnf1_val = packed struct {
        ///MAXLEN [0:7]
        ///Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN.
        maxlen: u8 = 0,
        ///STATLEN [8:15]
        ///Static length in number of bytes
        statlen: u8 = 0,
        ///BALEN [16:18]
        ///Base address length in number of bytes
        balen: u3 = 0,
        _unused19: u5 = 0,
        ///ENDIAN [24:24]
        ///On-air endianness of packet, this applies to the S0, LENGTH, S1, and the PAYLOAD fields.
        endian: packed enum(u1) {
            ///Least significant bit on air first
            little = 0,
            ///Most significant bit on air first
            big = 1,
        } = .little,
        ///WHITEEN [25:25]
        ///Enable or disable packet whitening
        whiteen: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused26: u6 = 0,
    };
    ///Packet configuration register 1
    pub const pcnf1 = Register(pcnf1_val).init(0x40001000 + 0x518);

    //////////////////////////
    ///BASE0
    const base0_val = packed struct {
        ///BASE0 [0:31]
        ///Base address 0
        base0: u32 = 0,
    };
    ///Base address 0
    pub const base0 = Register(base0_val).init(0x40001000 + 0x51C);

    //////////////////////////
    ///BASE1
    const base1_val = packed struct {
        ///BASE1 [0:31]
        ///Base address 1
        base1: u32 = 0,
    };
    ///Base address 1
    pub const base1 = Register(base1_val).init(0x40001000 + 0x520);

    //////////////////////////
    ///PREFIX0
    const prefix0_val = packed struct {
        ///AP0 [0:7]
        ///Address prefix 0.
        ap0: u8 = 0,
        ///AP1 [8:15]
        ///Address prefix 1.
        ap1: u8 = 0,
        ///AP2 [16:23]
        ///Address prefix 2.
        ap2: u8 = 0,
        ///AP3 [24:31]
        ///Address prefix 3.
        ap3: u8 = 0,
    };
    ///Prefixes bytes for logical addresses 0-3
    pub const prefix0 = Register(prefix0_val).init(0x40001000 + 0x524);

    //////////////////////////
    ///PREFIX1
    const prefix1_val = packed struct {
        ///AP4 [0:7]
        ///Address prefix 4.
        ap4: u8 = 0,
        ///AP5 [8:15]
        ///Address prefix 5.
        ap5: u8 = 0,
        ///AP6 [16:23]
        ///Address prefix 6.
        ap6: u8 = 0,
        ///AP7 [24:31]
        ///Address prefix 7.
        ap7: u8 = 0,
    };
    ///Prefixes bytes for logical addresses 4-7
    pub const prefix1 = Register(prefix1_val).init(0x40001000 + 0x528);

    //////////////////////////
    ///TXADDRESS
    const txaddress_val = packed struct {
        ///TXADDRESS [0:2]
        ///Transmit address select
        txaddress: u3 = 0,
        _unused3: u29 = 0,
    };
    ///Transmit address select
    pub const txaddress = Register(txaddress_val).init(0x40001000 + 0x52C);

    //////////////////////////
    ///RXADDRESSES
    const rxaddresses_val = packed struct {
        ///ADDR0 [0:0]
        ///Enable or disable reception on logical address 0.
        addr0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ADDR1 [1:1]
        ///Enable or disable reception on logical address 1.
        addr1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ADDR2 [2:2]
        ///Enable or disable reception on logical address 2.
        addr2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ADDR3 [3:3]
        ///Enable or disable reception on logical address 3.
        addr3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ADDR4 [4:4]
        ///Enable or disable reception on logical address 4.
        addr4: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ADDR5 [5:5]
        ///Enable or disable reception on logical address 5.
        addr5: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ADDR6 [6:6]
        ///Enable or disable reception on logical address 6.
        addr6: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ADDR7 [7:7]
        ///Enable or disable reception on logical address 7.
        addr7: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    ///Receive address select
    pub const rxaddresses = Register(rxaddresses_val).init(0x40001000 + 0x530);

    //////////////////////////
    ///CRCCNF
    const crccnf_val = packed struct {
        ///LEN [0:1]
        ///CRC length in number of bytes.
        len: packed enum(u2) {
            ///CRC length is zero and CRC calculation is disabled
            disabled = 0,
            ///CRC length is one byte and CRC calculation is enabled
            one = 1,
            ///CRC length is two bytes and CRC calculation is enabled
            two = 2,
            ///CRC length is three bytes and CRC calculation is enabled
            three = 3,
        } = .disabled,
        _unused2: u6 = 0,
        ///SKIPADDR [8:9]
        ///Include or exclude packet address field out of CRC calculation.
        skipaddr: packed enum(u2) {
            ///CRC calculation includes address field
            include = 0,
            ///CRC calculation does not include address field. The CRC calculation will start at the first byte after the address.
            skip = 1,
            ///CRC calculation as per 802.15.4 standard. Starting at first byte after length field.
            ieee802154 = 2,
        } = .include,
        _unused10: u22 = 0,
    };
    ///CRC configuration
    pub const crccnf = Register(crccnf_val).init(0x40001000 + 0x534);

    //////////////////////////
    ///CRCPOLY
    const crcpoly_val = packed struct {
        ///CRCPOLY [0:23]
        ///CRC polynomial
        crcpoly: u24 = 0,
        _unused24: u8 = 0,
    };
    ///CRC polynomial
    pub const crcpoly = Register(crcpoly_val).init(0x40001000 + 0x538);

    //////////////////////////
    ///CRCINIT
    const crcinit_val = packed struct {
        ///CRCINIT [0:23]
        ///CRC initial value
        crcinit: u24 = 0,
        _unused24: u8 = 0,
    };
    ///CRC initial value
    pub const crcinit = Register(crcinit_val).init(0x40001000 + 0x53C);

    //////////////////////////
    ///TIFS
    const tifs_val = packed struct {
        ///TIFS [0:9]
        ///Interframe spacing in us
        tifs: u10 = 0,
        _unused10: u22 = 0,
    };
    ///Interframe spacing in us
    pub const tifs = Register(tifs_val).init(0x40001000 + 0x544);

    //////////////////////////
    ///RSSISAMPLE
    const rssisample_val = packed struct {
        ///RSSISAMPLE [0:6]
        ///RSSI sample
        rssisample: u7 = 0,
        _unused7: u25 = 0,
    };
    ///RSSI sample
    pub const rssisample = RegisterRW(rssisample_val, void).init(0x40001000 + 0x548);

    //////////////////////////
    ///STATE
    const state_val = packed struct {
        ///STATE [0:3]
        ///Current radio state
        state: packed enum(u4) {
            ///RADIO is in the Disabled state
            disabled = 0,
            ///RADIO is in the RXRU state
            rx_ru = 1,
            ///RADIO is in the RXIDLE state
            rx_idle = 2,
            ///RADIO is in the RX state
            rx = 3,
            ///RADIO is in the RXDISABLED state
            rx_disable = 4,
            ///RADIO is in the TXRU state
            tx_ru = 9,
            ///RADIO is in the TXIDLE state
            tx_idle = 10,
            ///RADIO is in the TX state
            tx = 11,
            ///RADIO is in the TXDISABLED state
            tx_disable = 12,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Current radio state
    pub const state = RegisterRW(state_val, void).init(0x40001000 + 0x550);

    //////////////////////////
    ///DATAWHITEIV
    const datawhiteiv_val = packed struct {
        ///DATAWHITEIV [0:6]
        ///Data whitening initial value. Bit 6 is hardwired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'.
        datawhiteiv: u7 = 64,
        _unused7: u25 = 0,
    };
    ///Data whitening initial value
    pub const datawhiteiv = Register(datawhiteiv_val).init(0x40001000 + 0x554);

    //////////////////////////
    ///BCC
    const bcc_val = packed struct {
        ///BCC [0:31]
        ///Bit counter compare
        bcc: u32 = 0,
    };
    ///Bit counter compare
    pub const bcc = Register(bcc_val).init(0x40001000 + 0x560);

    //////////////////////////
    ///DAB[%s]
    const dab_val = packed struct {
        ///DAB [0:31]
        ///Device address base segment n
        dab: u32 = 0,
    };
    ///Description collection: Device address base segment n
    pub const dab = Register(dab_val).initRange(0x40001000 + 0x600, 4, 8);

    //////////////////////////
    ///DAP[%s]
    const dap_val = packed struct {
        ///DAP [0:15]
        ///Device address prefix n
        dap: u16 = 0,
        _unused16: u16 = 0,
    };
    ///Description collection: Device address prefix n
    pub const dap = Register(dap_val).initRange(0x40001000 + 0x620, 4, 8);

    //////////////////////////
    ///DACNF
    const dacnf_val = packed struct {
        ///ENA0 [0:0]
        ///Enable or disable device address matching using device address 0
        ena0: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///ENA1 [1:1]
        ///Enable or disable device address matching using device address 1
        ena1: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///ENA2 [2:2]
        ///Enable or disable device address matching using device address 2
        ena2: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///ENA3 [3:3]
        ///Enable or disable device address matching using device address 3
        ena3: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///ENA4 [4:4]
        ///Enable or disable device address matching using device address 4
        ena4: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///ENA5 [5:5]
        ///Enable or disable device address matching using device address 5
        ena5: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///ENA6 [6:6]
        ///Enable or disable device address matching using device address 6
        ena6: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///ENA7 [7:7]
        ///Enable or disable device address matching using device address 7
        ena7: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///TXADD0 [8:8]
        ///TxAdd for device address 0
        txadd0: u1 = 0,
        ///TXADD1 [9:9]
        ///TxAdd for device address 1
        txadd1: u1 = 0,
        ///TXADD2 [10:10]
        ///TxAdd for device address 2
        txadd2: u1 = 0,
        ///TXADD3 [11:11]
        ///TxAdd for device address 3
        txadd3: u1 = 0,
        ///TXADD4 [12:12]
        ///TxAdd for device address 4
        txadd4: u1 = 0,
        ///TXADD5 [13:13]
        ///TxAdd for device address 5
        txadd5: u1 = 0,
        ///TXADD6 [14:14]
        ///TxAdd for device address 6
        txadd6: u1 = 0,
        ///TXADD7 [15:15]
        ///TxAdd for device address 7
        txadd7: u1 = 0,
        _unused16: u16 = 0,
    };
    ///Device address match configuration
    pub const dacnf = Register(dacnf_val).init(0x40001000 + 0x640);

    //////////////////////////
    ///MHRMATCHCONF
    const mhrmatchconf_val = packed struct {
        ///MHRMATCHCONF [0:31]
        ///Search pattern configuration
        mhrmatchconf: u32 = 0,
    };
    ///Search pattern configuration
    pub const mhrmatchconf = Register(mhrmatchconf_val).init(0x40001000 + 0x644);

    //////////////////////////
    ///MHRMATCHMAS
    const mhrmatchmas_val = packed struct {
        ///MHRMATCHMAS [0:31]
        ///Pattern mask
        mhrmatchmas: u32 = 0,
    };
    ///Pattern mask
    pub const mhrmatchmas = Register(mhrmatchmas_val).init(0x40001000 + 0x648);

    //////////////////////////
    ///MODECNF0
    const modecnf0_val = packed struct {
        ///RU [0:0]
        ///Radio ramp-up time
        ru: packed enum(u1) {
            ///Default ramp-up time (tRXEN and tTXEN), compatible with firmware written for nRF51
            default = 0,
            ///Fast ramp-up (tRXEN,FAST and tTXEN,FAST), see electrical specification for more information
            fast = 1,
        } = .default,
        _unused1: u7 = 0,
        ///DTX [8:9]
        ///Default TX value
        dtx: packed enum(u2) {
            ///Transmit '1'
            b1 = 0,
            ///Transmit '0'
            b0 = 1,
            ///Transmit center frequency
            center = 2,
        } = .center,
        _unused10: u22 = 0,
    };
    ///Radio mode configuration register 0
    pub const modecnf0 = Register(modecnf0_val).init(0x40001000 + 0x650);

    //////////////////////////
    ///SFD
    const sfd_val = packed struct {
        ///SFD [0:7]
        ///IEEE 802.15.4 start of frame delimiter
        sfd: u8 = 167,
        _unused8: u24 = 0,
    };
    ///IEEE 802.15.4 start of frame delimiter
    pub const sfd = Register(sfd_val).init(0x40001000 + 0x660);

    //////////////////////////
    ///EDCNT
    const edcnt_val = packed struct {
        ///EDCNT [0:20]
        ///IEEE 802.15.4 energy detect loop count
        edcnt: u21 = 0,
        _unused21: u11 = 0,
    };
    ///IEEE 802.15.4 energy detect loop count
    pub const edcnt = Register(edcnt_val).init(0x40001000 + 0x664);

    //////////////////////////
    ///EDSAMPLE
    const edsample_val = packed struct {
        ///EDLVL [0:7]
        ///IEEE 802.15.4 energy detect level
        edlvl: u8 = 0,
        _unused8: u24 = 0,
    };
    ///IEEE 802.15.4 energy detect level
    pub const edsample = RegisterRW(edsample_val, void).init(0x40001000 + 0x668);

    //////////////////////////
    ///CCACTRL
    const ccactrl_val = packed struct {
        ///CCAMODE [0:2]
        ///CCA mode of operation
        ccamode: packed enum(u3) {
            ///Energy above threshold
            ed_mode = 0,
            ///Carrier seen
            carrier_mode = 1,
            ///Energy above threshold AND carrier seen
            carrier_and_ed_mode = 2,
            ///Energy above threshold OR carrier seen
            carrier_or_ed_mode = 3,
            ///Energy above threshold test mode that will abort when first ED measurement over threshold is seen. No averaging.
            ed_mode_test1 = 4,
        } = .ed_mode,
        _unused3: u5 = 0,
        ///CCAEDTHRES [8:15]
        ///CCA energy busy threshold. Used in all the CCA modes except CarrierMode.
        ccaedthres: u8 = 0,
        ///CCACORRTHRES [16:23]
        ///CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode, and CarrierOrEdMode.
        ccacorrthres: u8 = 45,
        ///CCACORRCNT [24:31]
        ///Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled.
        ccacorrcnt: u8 = 5,
    };
    ///IEEE 802.15.4 clear channel assessment control
    pub const ccactrl = Register(ccactrl_val).init(0x40001000 + 0x66C);

    //////////////////////////
    ///DFEMODE
    const dfemode_val = packed struct {
        ///DFEOPMODE [0:1]
        ///Direction finding operation mode
        dfeopmode: packed enum(u2) {
            ///Direction finding mode disabled
            disabled = 0,
            ///Direction finding mode set to AoD
            ao_d = 2,
            ///Direction finding mode set to AoA
            ao_a = 3,
        } = .disabled,
        _unused2: u30 = 0,
    };
    ///Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)
    pub const dfemode = Register(dfemode_val).init(0x40001000 + 0x900);

    //////////////////////////
    ///CTEINLINECONF
    const cteinlineconf_val = packed struct {
        ///CTEINLINECTRLEN [0:0]
        ///Enable parsing of CTEInfo from received packet in BLE modes
        cteinlinectrlen: packed enum(u1) {
            ///Parsing of CTEInfo is enabled
            enabled = 1,
            ///Parsing of CTEInfo is disabled
            disabled = 0,
        } = .disabled,
        _unused1: u2 = 0,
        ///CTEINFOINS1 [3:3]
        ///CTEInfo is S1 byte or not
        cteinfoins1: packed enum(u1) {
            ///CTEInfo is in S1 byte (data PDU)
            in_s1 = 1,
            ///CTEInfo is NOT in S1 byte (advertising PDU)
            not_in_s1 = 0,
        } = .not_in_s1,
        ///CTEERRORHANDLING [4:4]
        ///Sampling/switching if CRC is not OK
        cteerrorhandling: packed enum(u1) {
            ///Sampling and antenna switching also when CRC is not OK
            yes = 1,
            ///No sampling and antenna switching when CRC is not OK
            no = 0,
        } = .no,
        _unused5: u1 = 0,
        ///CTETIMEVALIDRANGE [6:7]
        ///Max range of CTETime
        ctetimevalidrange: packed enum(u2) {
            ///20 in 8us unit (default) Set to 20 if parsed CTETime is larger han 20
            _20 = 0,
            ///31 in 8us unit
            _31 = 1,
            ///63 in 8us unit
            _63 = 2,
        } = ._20,
        _unused8: u2 = 0,
        ///CTEINLINERXMODE1US [10:12]
        ///Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set
        cteinlinerxmode1us: packed enum(u3) {
            ///4us
            _4us = 1,
            ///2us
            _2us = 2,
            ///1us
            _1us = 3,
            ///0.5us
            _500ns = 4,
            ///0.25us
            _250ns = 5,
            ///0.125us
            _125ns = 6,
        } = ._2us,
        ///CTEINLINERXMODE2US [13:15]
        ///Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set
        cteinlinerxmode2us: packed enum(u3) {
            ///4us
            _4us = 1,
            ///2us
            _2us = 2,
            ///1us
            _1us = 3,
            ///0.5us
            _500ns = 4,
            ///0.25us
            _250ns = 5,
            ///0.125us
            _125ns = 6,
        } = ._4us,
        ///S0CONF [16:23]
        ///S0 bit pattern to match
        s0conf: u8 = 0,
        ///S0MASK [24:31]
        ///S0 bit mask to set which bit to match
        s0mask: u8 = 0,
    };
    ///Configuration for CTE inline mode
    pub const cteinlineconf = Register(cteinlineconf_val).init(0x40001000 + 0x904);

    //////////////////////////
    ///DFECTRL1
    const dfectrl1_val = packed struct {
        ///NUMBEROF8US [0:5]
        ///Length of the AoA/AoD procedure in number of 8 us units
        numberof8us: u6 = 2,
        _unused6: u1 = 0,
        ///DFEINEXTENSION [7:7]
        ///Add CTE extension and do antenna switching/sampling in this extension
        dfeinextension: packed enum(u1) {
            ///AoA/AoD procedure triggered at end of CRC
            crc = 1,
            ///Antenna switching/sampling is done in the packet payload
            payload = 0,
        } = .crc,
        ///TSWITCHSPACING [8:10]
        ///Interval between every time the antenna is changed in the SWITCHING state
        tswitchspacing: packed enum(u3) {
            ///4us
            _4us = 1,
            ///2us
            _2us = 2,
            ///1us
            _1us = 3,
        } = ._2us,
        _unused11: u1 = 0,
        ///TSAMPLESPACINGREF [12:14]
        ///Interval between samples in the REFERENCE period
        tsamplespacingref: packed enum(u3) {
            ///4us
            _4us = 1,
            ///2us
            _2us = 2,
            ///1us
            _1us = 3,
            ///0.5us
            _500ns = 4,
            ///0.25us
            _250ns = 5,
            ///0.125us
            _125ns = 6,
        } = ._1us,
        ///SAMPLETYPE [15:15]
        ///Whether to sample I/Q or magnitude/phase
        sampletype: packed enum(u1) {
            ///Complex samples in I and Q
            iq = 0,
            ///Complex samples as magnitude and phase
            mag_phase = 1,
        } = .iq,
        ///TSAMPLESPACING [16:18]
        ///Interval between samples in the SWITCHING period when CTEINLINECTRLEN is 0
        tsamplespacing: packed enum(u3) {
            ///4us
            _4us = 1,
            ///2us
            _2us = 2,
            ///1us
            _1us = 3,
            ///0.5us
            _500ns = 4,
            ///0.25us
            _250ns = 5,
            ///0.125us
            _125ns = 6,
        } = ._2us,
        _unused19: u1 = 0,
        ///REPEATPATTERN [20:23]
        ///Repeat each individual antenna pattern N times sequentially, i.e. P0, P0, P1, P1, P2, P2, P3, P3, etc.
        repeatpattern: packed enum(u4) {
            ///Do not repeat (1 time in total)
            no_repeat = 0,
        } = .no_repeat,
        ///AGCBACKOFFGAIN [24:27]
        ///Gain will be lowered by the specified number of gain steps at the start of CTE
        agcbackoffgain: u4 = 0,
        _unused28: u4 = 0,
    };
    ///Various configuration for Direction finding
    pub const dfectrl1 = Register(dfectrl1_val).init(0x40001000 + 0x910);

    //////////////////////////
    ///DFECTRL2
    const dfectrl2_val = packed struct {
        ///TSWITCHOFFSET [0:12]
        ///Signed value offset after the end of the CRC before starting switching in number of 16M cycles
        tswitchoffset: u13 = 0,
        _unused13: u3 = 0,
        ///TSAMPLEOFFSET [16:27]
        ///Signed value offset before starting sampling in number of 16M cycles relative to the beginning of the REFERENCE state - 12 us after switching start
        tsampleoffset: u12 = 0,
        _unused28: u4 = 0,
    };
    ///Start offset for Direction finding
    pub const dfectrl2 = Register(dfectrl2_val).init(0x40001000 + 0x914);

    //////////////////////////
    ///SWITCHPATTERN
    const switchpattern_val = packed struct {
        ///SWITCHPATTERN [0:7]
        ///Fill array of GPIO patterns for antenna control
        switchpattern: u8 = 0,
        _unused8: u24 = 0,
    };
    ///GPIO patterns to be used for each antenna
    pub const switchpattern = Register(switchpattern_val).init(0x40001000 + 0x928);

    //////////////////////////
    ///CLEARPATTERN
    const clearpattern_val = packed struct {
        ///CLEARPATTERN [0:0]
        ///Clears GPIO pattern array for antenna control
        clearpattern: packed enum(u1) {
            ///Clear the GPIO pattern
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Clear the GPIO pattern array for antenna control
    pub const clearpattern = Register(clearpattern_val).init(0x40001000 + 0x92C);

    //////////////////////////
    ///POWER
    const power_val = packed struct {
        ///POWER [0:0]
        ///Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again.
        power: packed enum(u1) {
            ///Peripheral is powered off
            disabled = 0,
            ///Peripheral is powered on
            enabled = 1,
        } = .enabled,
        _unused1: u31 = 0,
    };
    ///Peripheral power control
    pub const power = Register(power_val).init(0x40001000 + 0xFFC);
};

///Universal Asynchronous Receiver/Transmitter
pub const uart0 = struct {

    //////////////////////////
    ///TASKS_STARTRX
    const tasks_startrx_val = packed struct {
        ///TASKS_STARTRX [0:0]
        ///Start UART receiver
        tasks_startrx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start UART receiver
    pub const tasks_startrx = RegisterRW(void, tasks_startrx_val).init(0x40002000 + 0x000);

    //////////////////////////
    ///TASKS_STOPRX
    const tasks_stoprx_val = packed struct {
        ///TASKS_STOPRX [0:0]
        ///Stop UART receiver
        tasks_stoprx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop UART receiver
    pub const tasks_stoprx = RegisterRW(void, tasks_stoprx_val).init(0x40002000 + 0x004);

    //////////////////////////
    ///TASKS_STARTTX
    const tasks_starttx_val = packed struct {
        ///TASKS_STARTTX [0:0]
        ///Start UART transmitter
        tasks_starttx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start UART transmitter
    pub const tasks_starttx = RegisterRW(void, tasks_starttx_val).init(0x40002000 + 0x008);

    //////////////////////////
    ///TASKS_STOPTX
    const tasks_stoptx_val = packed struct {
        ///TASKS_STOPTX [0:0]
        ///Stop UART transmitter
        tasks_stoptx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop UART transmitter
    pub const tasks_stoptx = RegisterRW(void, tasks_stoptx_val).init(0x40002000 + 0x00C);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend UART
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend UART
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x40002000 + 0x01C);

    //////////////////////////
    ///EVENTS_CTS
    const events_cts_val = packed struct {
        ///EVENTS_CTS [0:0]
        ///CTS is activated (set low). Clear To Send.
        events_cts: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///CTS is activated (set low). Clear To Send.
    pub const events_cts = Register(events_cts_val).init(0x40002000 + 0x100);

    //////////////////////////
    ///EVENTS_NCTS
    const events_ncts_val = packed struct {
        ///EVENTS_NCTS [0:0]
        ///CTS is deactivated (set high). Not Clear To Send.
        events_ncts: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///CTS is deactivated (set high). Not Clear To Send.
    pub const events_ncts = Register(events_ncts_val).init(0x40002000 + 0x104);

    //////////////////////////
    ///EVENTS_RXDRDY
    const events_rxdrdy_val = packed struct {
        ///EVENTS_RXDRDY [0:0]
        ///Data received in RXD
        events_rxdrdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Data received in RXD
    pub const events_rxdrdy = Register(events_rxdrdy_val).init(0x40002000 + 0x108);

    //////////////////////////
    ///EVENTS_TXDRDY
    const events_txdrdy_val = packed struct {
        ///EVENTS_TXDRDY [0:0]
        ///Data sent from TXD
        events_txdrdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Data sent from TXD
    pub const events_txdrdy = Register(events_txdrdy_val).init(0x40002000 + 0x11C);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///Error detected
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Error detected
    pub const events_error = Register(events_error_val).init(0x40002000 + 0x124);

    //////////////////////////
    ///EVENTS_RXTO
    const events_rxto_val = packed struct {
        ///EVENTS_RXTO [0:0]
        ///Receiver timeout
        events_rxto: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Receiver timeout
    pub const events_rxto = Register(events_rxto_val).init(0x40002000 + 0x144);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u3 = 0,
        ///CTS_STARTRX [3:3]
        ///Shortcut between event CTS and task STARTRX
        cts_startrx: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///NCTS_STOPRX [4:4]
        ///Shortcut between event NCTS and task STOPRX
        ncts_stoprx: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused5: u27 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40002000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///CTS [0:0]
        ///Write '1' to enable interrupt for event CTS
        cts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///NCTS [1:1]
        ///Write '1' to enable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXDRDY [2:2]
        ///Write '1' to enable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u4 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to enable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to enable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused18: u14 = 0,
    };
    const intenset_val_write = packed struct {
        ///CTS [0:0]
        ///Write '1' to enable interrupt for event CTS
        cts: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///NCTS [1:1]
        ///Write '1' to enable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RXDRDY [2:2]
        ///Write '1' to enable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u4 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to enable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to enable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused18: u14 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40002000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///CTS [0:0]
        ///Write '1' to disable interrupt for event CTS
        cts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///NCTS [1:1]
        ///Write '1' to disable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXDRDY [2:2]
        ///Write '1' to disable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u4 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to disable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to disable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused18: u14 = 0,
    };
    const intenclr_val_write = packed struct {
        ///CTS [0:0]
        ///Write '1' to disable interrupt for event CTS
        cts: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///NCTS [1:1]
        ///Write '1' to disable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RXDRDY [2:2]
        ///Write '1' to disable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u4 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to disable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to disable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused18: u14 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40002000 + 0x308);

    //////////////////////////
    ///ERRORSRC
    const errorsrc_val_read = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///PARITY [1:1]
        ///Parity error
        parity: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///FRAMING [2:2]
        ///Framing error occurred
        framing: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///BREAK [3:3]
        ///Break condition
        _break: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        _unused4: u28 = 0,
    };
    const errorsrc_val_write = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: u1 = 0,
        ///PARITY [1:1]
        ///Parity error
        parity: u1 = 0,
        ///FRAMING [2:2]
        ///Framing error occurred
        framing: u1 = 0,
        ///BREAK [3:3]
        ///Break condition
        _break: u1 = 0,
        _unused4: u28 = 0,
    };
    ///Error source
    pub const errorsrc = RegisterRW(errorsrc_val_read, errorsrc_val_write).init(0x40002000 + 0x480);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable UART
        enable: packed enum(u4) {
            ///Disable UART
            disabled = 0,
            ///Enable UART
            enabled = 4,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable UART
    pub const enable = Register(enable_val).init(0x40002000 + 0x500);

    //////////////////////////
    ///RXD
    const rxd_val = packed struct {
        ///RXD [0:7]
        ///RX data received in previous transfers, double buffered
        rxd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///RXD register
    pub const rxd = RegisterRW(rxd_val, void).init(0x40002000 + 0x518);

    //////////////////////////
    ///TXD
    const txd_val = packed struct {
        ///TXD [0:7]
        ///TX data to be transferred
        txd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///TXD register
    pub const txd = RegisterRW(void, txd_val).init(0x40002000 + 0x51C);

    //////////////////////////
    ///BAUDRATE
    const baudrate_val = packed struct {
        ///BAUDRATE [0:31]
        ///Baud rate
        baudrate: packed enum(u32) {
            ///1200 baud (actual rate: 1205)
            baud1200 = 0x0004F000,
            ///2400 baud (actual rate: 2396)
            baud2400 = 0x0009D000,
            ///4800 baud (actual rate: 4808)
            baud4800 = 0x0013B000,
            ///9600 baud (actual rate: 9598)
            baud9600 = 0x00275000,
            ///14400 baud (actual rate: 14414)
            baud14400 = 0x003B0000,
            ///19200 baud (actual rate: 19208)
            baud19200 = 0x004EA000,
            ///28800 baud (actual rate: 28829)
            baud28800 = 0x0075F000,
            ///31250 baud
            baud31250 = 0x00800000,
            ///38400 baud (actual rate: 38462)
            baud38400 = 0x009D5000,
            ///56000 baud (actual rate: 55944)
            baud56000 = 0x00E50000,
            ///57600 baud (actual rate: 57762)
            baud57600 = 0x00EBF000,
            ///76800 baud (actual rate: 76923)
            baud76800 = 0x013A9000,
            ///115200 baud (actual rate: 115942)
            baud115200 = 0x01D7E000,
            ///230400 baud (actual rate: 231884)
            baud230400 = 0x03AFB000,
            ///250000 baud
            baud250000 = 0x04000000,
            ///460800 baud (actual rate: 470588)
            baud460800 = 0x075F7000,
            ///921600 baud (actual rate: 941176)
            baud921600 = 0x0EBED000,
            ///1Mega baud
            baud1m = 0x10000000,
            _zero = 0,
        } = ._zero,
    };
    ///Baud rate. Accuracy depends on the HFCLK source selected.
    pub const baudrate = Register(baudrate_val).init(0x40002000 + 0x524);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///HWFC [0:0]
        ///Hardware flow control
        hwfc: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///PARITY [1:3]
        ///Parity
        parity: packed enum(u3) {
            ///Exclude parity bit
            excluded = 0x0,
            ///Include parity bit
            included = 0x7,
            _zero = 0,
        } = ._zero,
        ///STOP [4:4]
        ///Stop bits
        stop: packed enum(u1) {
            ///One stop bit
            one = 0,
            ///Two stop bits
            two = 1,
        } = .one,
        _unused5: u3 = 0,
        ///PARITYTYPE [8:8]
        ///Even or odd parity type
        paritytype: packed enum(u1) {
            ///Even parity
            even = 0,
            ///Odd parity
            odd = 1,
        } = .even,
        _unused9: u23 = 0,
    };
    ///Configuration of parity and hardware flow control
    pub const config = Register(config_val).init(0x40002000 + 0x56C);
};

///UART with EasyDMA 0
pub const uarte0 = struct {

    //////////////////////////
    ///TASKS_STARTRX
    const tasks_startrx_val = packed struct {
        ///TASKS_STARTRX [0:0]
        ///Start UART receiver
        tasks_startrx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start UART receiver
    pub const tasks_startrx = RegisterRW(void, tasks_startrx_val).init(0x40002000 + 0x000);

    //////////////////////////
    ///TASKS_STOPRX
    const tasks_stoprx_val = packed struct {
        ///TASKS_STOPRX [0:0]
        ///Stop UART receiver
        tasks_stoprx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop UART receiver
    pub const tasks_stoprx = RegisterRW(void, tasks_stoprx_val).init(0x40002000 + 0x004);

    //////////////////////////
    ///TASKS_STARTTX
    const tasks_starttx_val = packed struct {
        ///TASKS_STARTTX [0:0]
        ///Start UART transmitter
        tasks_starttx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start UART transmitter
    pub const tasks_starttx = RegisterRW(void, tasks_starttx_val).init(0x40002000 + 0x008);

    //////////////////////////
    ///TASKS_STOPTX
    const tasks_stoptx_val = packed struct {
        ///TASKS_STOPTX [0:0]
        ///Stop UART transmitter
        tasks_stoptx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop UART transmitter
    pub const tasks_stoptx = RegisterRW(void, tasks_stoptx_val).init(0x40002000 + 0x00C);

    //////////////////////////
    ///TASKS_FLUSHRX
    const tasks_flushrx_val = packed struct {
        ///TASKS_FLUSHRX [0:0]
        ///Flush RX FIFO into RX buffer
        tasks_flushrx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Flush RX FIFO into RX buffer
    pub const tasks_flushrx = RegisterRW(void, tasks_flushrx_val).init(0x40002000 + 0x02C);

    //////////////////////////
    ///EVENTS_CTS
    const events_cts_val = packed struct {
        ///EVENTS_CTS [0:0]
        ///CTS is activated (set low). Clear To Send.
        events_cts: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///CTS is activated (set low). Clear To Send.
    pub const events_cts = Register(events_cts_val).init(0x40002000 + 0x100);

    //////////////////////////
    ///EVENTS_NCTS
    const events_ncts_val = packed struct {
        ///EVENTS_NCTS [0:0]
        ///CTS is deactivated (set high). Not Clear To Send.
        events_ncts: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///CTS is deactivated (set high). Not Clear To Send.
    pub const events_ncts = Register(events_ncts_val).init(0x40002000 + 0x104);

    //////////////////////////
    ///EVENTS_RXDRDY
    const events_rxdrdy_val = packed struct {
        ///EVENTS_RXDRDY [0:0]
        ///Data received in RXD (but potentially not yet transferred to Data RAM)
        events_rxdrdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Data received in RXD (but potentially not yet transferred to Data RAM)
    pub const events_rxdrdy = Register(events_rxdrdy_val).init(0x40002000 + 0x108);

    //////////////////////////
    ///EVENTS_ENDRX
    const events_endrx_val = packed struct {
        ///EVENTS_ENDRX [0:0]
        ///Receive buffer is filled up
        events_endrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Receive buffer is filled up
    pub const events_endrx = Register(events_endrx_val).init(0x40002000 + 0x110);

    //////////////////////////
    ///EVENTS_TXDRDY
    const events_txdrdy_val = packed struct {
        ///EVENTS_TXDRDY [0:0]
        ///Data sent from TXD
        events_txdrdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Data sent from TXD
    pub const events_txdrdy = Register(events_txdrdy_val).init(0x40002000 + 0x11C);

    //////////////////////////
    ///EVENTS_ENDTX
    const events_endtx_val = packed struct {
        ///EVENTS_ENDTX [0:0]
        ///Last TX byte transmitted
        events_endtx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Last TX byte transmitted
    pub const events_endtx = Register(events_endtx_val).init(0x40002000 + 0x120);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///Error detected
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Error detected
    pub const events_error = Register(events_error_val).init(0x40002000 + 0x124);

    //////////////////////////
    ///EVENTS_RXTO
    const events_rxto_val = packed struct {
        ///EVENTS_RXTO [0:0]
        ///Receiver timeout
        events_rxto: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Receiver timeout
    pub const events_rxto = Register(events_rxto_val).init(0x40002000 + 0x144);

    //////////////////////////
    ///EVENTS_RXSTARTED
    const events_rxstarted_val = packed struct {
        ///EVENTS_RXSTARTED [0:0]
        ///UART receiver has started
        events_rxstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///UART receiver has started
    pub const events_rxstarted = Register(events_rxstarted_val).init(0x40002000 + 0x14C);

    //////////////////////////
    ///EVENTS_TXSTARTED
    const events_txstarted_val = packed struct {
        ///EVENTS_TXSTARTED [0:0]
        ///UART transmitter has started
        events_txstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///UART transmitter has started
    pub const events_txstarted = Register(events_txstarted_val).init(0x40002000 + 0x150);

    //////////////////////////
    ///EVENTS_TXSTOPPED
    const events_txstopped_val = packed struct {
        ///EVENTS_TXSTOPPED [0:0]
        ///Transmitter stopped
        events_txstopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transmitter stopped
    pub const events_txstopped = Register(events_txstopped_val).init(0x40002000 + 0x158);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u5 = 0,
        ///ENDRX_STARTRX [5:5]
        ///Shortcut between event ENDRX and task STARTRX
        endrx_startrx: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///ENDRX_STOPRX [6:6]
        ///Shortcut between event ENDRX and task STOPRX
        endrx_stoprx: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused7: u25 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40002000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///CTS [0:0]
        ///Enable or disable interrupt for event CTS
        cts: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///NCTS [1:1]
        ///Enable or disable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///RXDRDY [2:2]
        ///Enable or disable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused3: u1 = 0,
        ///ENDRX [4:4]
        ///Enable or disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused5: u2 = 0,
        ///TXDRDY [7:7]
        ///Enable or disable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDTX [8:8]
        ///Enable or disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ERROR [9:9]
        ///Enable or disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Enable or disable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused18: u1 = 0,
        ///RXSTARTED [19:19]
        ///Enable or disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Enable or disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused21: u1 = 0,
        ///TXSTOPPED [22:22]
        ///Enable or disable interrupt for event TXSTOPPED
        txstopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused23: u9 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40002000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///CTS [0:0]
        ///Write '1' to enable interrupt for event CTS
        cts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///NCTS [1:1]
        ///Write '1' to enable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXDRDY [2:2]
        ///Write '1' to enable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u1 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u2 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to enable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to enable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused18: u1 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u1 = 0,
        ///TXSTOPPED [22:22]
        ///Write '1' to enable interrupt for event TXSTOPPED
        txstopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused23: u9 = 0,
    };
    const intenset_val_write = packed struct {
        ///CTS [0:0]
        ///Write '1' to enable interrupt for event CTS
        cts: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///NCTS [1:1]
        ///Write '1' to enable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RXDRDY [2:2]
        ///Write '1' to enable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u1 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u2 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to enable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to enable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused18: u1 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u1 = 0,
        ///TXSTOPPED [22:22]
        ///Write '1' to enable interrupt for event TXSTOPPED
        txstopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused23: u9 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40002000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///CTS [0:0]
        ///Write '1' to disable interrupt for event CTS
        cts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///NCTS [1:1]
        ///Write '1' to disable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXDRDY [2:2]
        ///Write '1' to disable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u1 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u2 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to disable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to disable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused18: u1 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u1 = 0,
        ///TXSTOPPED [22:22]
        ///Write '1' to disable interrupt for event TXSTOPPED
        txstopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused23: u9 = 0,
    };
    const intenclr_val_write = packed struct {
        ///CTS [0:0]
        ///Write '1' to disable interrupt for event CTS
        cts: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///NCTS [1:1]
        ///Write '1' to disable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RXDRDY [2:2]
        ///Write '1' to disable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u1 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u2 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to disable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to disable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused18: u1 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u1 = 0,
        ///TXSTOPPED [22:22]
        ///Write '1' to disable interrupt for event TXSTOPPED
        txstopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused23: u9 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40002000 + 0x308);

    //////////////////////////
    ///ERRORSRC
    const errorsrc_val_read = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///PARITY [1:1]
        ///Parity error
        parity: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///FRAMING [2:2]
        ///Framing error occurred
        framing: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///BREAK [3:3]
        ///Break condition
        _break: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        _unused4: u28 = 0,
    };
    const errorsrc_val_write = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: u1 = 0,
        ///PARITY [1:1]
        ///Parity error
        parity: u1 = 0,
        ///FRAMING [2:2]
        ///Framing error occurred
        framing: u1 = 0,
        ///BREAK [3:3]
        ///Break condition
        _break: u1 = 0,
        _unused4: u28 = 0,
    };
    ///Error source Note : this register is read / write one to clear.
    pub const errorsrc = RegisterRW(errorsrc_val_read, errorsrc_val_write).init(0x40002000 + 0x480);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable UARTE
        enable: packed enum(u4) {
            ///Disable UARTE
            disabled = 0,
            ///Enable UARTE
            enabled = 8,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable UART
    pub const enable = Register(enable_val).init(0x40002000 + 0x500);

    //////////////////////////
    ///BAUDRATE
    const baudrate_val = packed struct {
        ///BAUDRATE [0:31]
        ///Baud rate
        baudrate: packed enum(u32) {
            ///1200 baud (actual rate: 1205)
            baud1200 = 0x0004F000,
            ///2400 baud (actual rate: 2396)
            baud2400 = 0x0009D000,
            ///4800 baud (actual rate: 4808)
            baud4800 = 0x0013B000,
            ///9600 baud (actual rate: 9598)
            baud9600 = 0x00275000,
            ///14400 baud (actual rate: 14401)
            baud14400 = 0x003AF000,
            ///19200 baud (actual rate: 19208)
            baud19200 = 0x004EA000,
            ///28800 baud (actual rate: 28777)
            baud28800 = 0x0075C000,
            ///31250 baud
            baud31250 = 0x00800000,
            ///38400 baud (actual rate: 38369)
            baud38400 = 0x009D0000,
            ///56000 baud (actual rate: 55944)
            baud56000 = 0x00E50000,
            ///57600 baud (actual rate: 57554)
            baud57600 = 0x00EB0000,
            ///76800 baud (actual rate: 76923)
            baud76800 = 0x013A9000,
            ///115200 baud (actual rate: 115108)
            baud115200 = 0x01D60000,
            ///230400 baud (actual rate: 231884)
            baud230400 = 0x03B00000,
            ///250000 baud
            baud250000 = 0x04000000,
            ///460800 baud (actual rate: 457143)
            baud460800 = 0x07400000,
            ///921600 baud (actual rate: 941176)
            baud921600 = 0x0F000000,
            ///1Mega baud
            baud1m = 0x10000000,
            _zero = 0,
        } = ._zero,
    };
    ///Baud rate. Accuracy depends on the HFCLK source selected.
    pub const baudrate = Register(baudrate_val).init(0x40002000 + 0x524);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///HWFC [0:0]
        ///Hardware flow control
        hwfc: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///PARITY [1:3]
        ///Parity
        parity: packed enum(u3) {
            ///Exclude parity bit
            excluded = 0x0,
            ///Include even parity bit
            included = 0x7,
            _zero = 0,
        } = ._zero,
        ///STOP [4:4]
        ///Stop bits
        stop: packed enum(u1) {
            ///One stop bit
            one = 0,
            ///Two stop bits
            two = 1,
        } = .one,
        _unused5: u3 = 0,
        ///PARITYTYPE [8:8]
        ///Even or odd parity type
        paritytype: packed enum(u1) {
            ///Even parity
            even = 0,
            ///Odd parity
            odd = 1,
        } = .even,
        _unused9: u23 = 0,
    };
    ///Configuration of parity and hardware flow control
    pub const config = Register(config_val).init(0x40002000 + 0x56C);
};

///Serial Peripheral Interface 0
pub const spi0 = struct {

    //////////////////////////
    ///EVENTS_READY
    const events_ready_val = packed struct {
        ///EVENTS_READY [0:0]
        ///TXD byte sent and RXD byte received
        events_ready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TXD byte sent and RXD byte received
    pub const events_ready = Register(events_ready_val).init(0x40003000 + 0x108);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40003000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40003000 + 0x308);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable SPI
        enable: packed enum(u4) {
            ///Disable SPI
            disabled = 0,
            ///Enable SPI
            enabled = 1,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable SPI
    pub const enable = Register(enable_val).init(0x40003000 + 0x500);

    //////////////////////////
    ///RXD
    const rxd_val = packed struct {
        ///RXD [0:7]
        ///RX data received. Double buffered
        rxd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///RXD register
    pub const rxd = RegisterRW(rxd_val, void).init(0x40003000 + 0x518);

    //////////////////////////
    ///TXD
    const txd_val = packed struct {
        ///TXD [0:7]
        ///TX data to send. Double buffered
        txd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///TXD register
    pub const txd = Register(txd_val).init(0x40003000 + 0x51C);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///SPI master data rate
        frequency: packed enum(u32) {
            ///125 kbps
            k125 = 0x02000000,
            ///250 kbps
            k250 = 0x04000000,
            ///500 kbps
            k500 = 0x08000000,
            ///1 Mbps
            m1 = 0x10000000,
            ///2 Mbps
            m2 = 0x20000000,
            ///4 Mbps
            m4 = 0x40000000,
            ///8 Mbps
            m8 = 0x80000000,
            _zero = 0,
        } = ._zero,
    };
    ///SPI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x40003000 + 0x524);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ORDER [0:0]
        ///Bit order
        order: packed enum(u1) {
            ///Most significant bit shifted out first
            msb_first = 0,
            ///Least significant bit shifted out first
            lsb_first = 1,
        } = .msb_first,
        ///CPHA [1:1]
        ///Serial clock (SCK) phase
        cpha: packed enum(u1) {
            ///Sample on leading edge of clock, shift serial data on trailing edge
            leading = 0,
            ///Sample on trailing edge of clock, shift serial data on leading edge
            trailing = 1,
        } = .leading,
        ///CPOL [2:2]
        ///Serial clock (SCK) polarity
        cpol: packed enum(u1) {
            ///Active high
            active_high = 0,
            ///Active low
            active_low = 1,
        } = .active_high,
        _unused3: u29 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x40003000 + 0x554);
};

///Serial Peripheral Interface Master with EasyDMA 0
pub const spim0 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start SPI transaction
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start SPI transaction
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40003000 + 0x010);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop SPI transaction
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop SPI transaction
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40003000 + 0x014);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend SPI transaction
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend SPI transaction
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x40003000 + 0x01C);

    //////////////////////////
    ///TASKS_RESUME
    const tasks_resume_val = packed struct {
        ///TASKS_RESUME [0:0]
        ///Resume SPI transaction
        tasks_resume: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Resume SPI transaction
    pub const tasks_resume = RegisterRW(void, tasks_resume_val).init(0x40003000 + 0x020);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///SPI transaction has stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///SPI transaction has stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40003000 + 0x104);

    //////////////////////////
    ///EVENTS_ENDRX
    const events_endrx_val = packed struct {
        ///EVENTS_ENDRX [0:0]
        ///End of RXD buffer reached
        events_endrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer reached
    pub const events_endrx = Register(events_endrx_val).init(0x40003000 + 0x110);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///End of RXD buffer and TXD buffer reached
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer and TXD buffer reached
    pub const events_end = Register(events_end_val).init(0x40003000 + 0x118);

    //////////////////////////
    ///EVENTS_ENDTX
    const events_endtx_val = packed struct {
        ///EVENTS_ENDTX [0:0]
        ///End of TXD buffer reached
        events_endtx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of TXD buffer reached
    pub const events_endtx = Register(events_endtx_val).init(0x40003000 + 0x120);

    //////////////////////////
    ///EVENTS_STARTED
    const events_started_val = packed struct {
        ///EVENTS_STARTED [0:0]
        ///Transaction started
        events_started: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transaction started
    pub const events_started = Register(events_started_val).init(0x40003000 + 0x14C);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u17 = 0,
        ///END_START [17:17]
        ///Shortcut between event END and task START
        end_start: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused18: u14 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40003000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40003000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40003000 + 0x308);

    //////////////////////////
    ///STALLSTAT
    const stallstat_val = packed struct {
        ///TX [0:0]
        ///Stall status for EasyDMA RAM reads
        tx: packed enum(u1) {
            ///No stall
            nostall = 0,
            ///A stall has occurred
            stall = 1,
        } = .nostall,
        ///RX [1:1]
        ///Stall status for EasyDMA RAM writes
        rx: packed enum(u1) {
            ///No stall
            nostall = 0,
            ///A stall has occurred
            stall = 1,
        } = .nostall,
        _unused2: u30 = 0,
    };
    ///Stall status for EasyDMA RAM accesses. The fields in this register is set to STALL by hardware whenever a stall occurres and can be cleared (set to NOSTALL) by the CPU.
    pub const stallstat = Register(stallstat_val).init(0x40003000 + 0x400);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable SPIM
        enable: packed enum(u4) {
            ///Disable SPIM
            disabled = 0,
            ///Enable SPIM
            enabled = 7,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable SPIM
    pub const enable = Register(enable_val).init(0x40003000 + 0x500);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///SPI master data rate
        frequency: packed enum(u32) {
            ///125 kbps
            k125 = 0x02000000,
            ///250 kbps
            k250 = 0x04000000,
            ///500 kbps
            k500 = 0x08000000,
            ///1 Mbps
            m1 = 0x10000000,
            ///2 Mbps
            m2 = 0x20000000,
            ///4 Mbps
            m4 = 0x40000000,
            ///8 Mbps
            m8 = 0x80000000,
            ///16 Mbps
            m16 = 0x0A000000,
            ///32 Mbps
            m32 = 0x14000000,
            _zero = 0,
        } = ._zero,
    };
    ///SPI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x40003000 + 0x524);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ORDER [0:0]
        ///Bit order
        order: packed enum(u1) {
            ///Most significant bit shifted out first
            msb_first = 0,
            ///Least significant bit shifted out first
            lsb_first = 1,
        } = .msb_first,
        ///CPHA [1:1]
        ///Serial clock (SCK) phase
        cpha: packed enum(u1) {
            ///Sample on leading edge of clock, shift serial data on trailing edge
            leading = 0,
            ///Sample on trailing edge of clock, shift serial data on leading edge
            trailing = 1,
        } = .leading,
        ///CPOL [2:2]
        ///Serial clock (SCK) polarity
        cpol: packed enum(u1) {
            ///Active high
            active_high = 0,
            ///Active low
            active_low = 1,
        } = .active_high,
        _unused3: u29 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x40003000 + 0x554);

    //////////////////////////
    ///CSNPOL
    const csnpol_val = packed struct {
        ///CSNPOL [0:0]
        ///Polarity of CSN output
        csnpol: packed enum(u1) {
            ///Active low (idle state high)
            low = 0,
            ///Active high (idle state low)
            high = 1,
        } = .low,
        _unused1: u31 = 0,
    };
    ///Polarity of CSN output
    pub const csnpol = Register(csnpol_val).init(0x40003000 + 0x568);

    //////////////////////////
    ///PSELDCX
    const pseldcx_val = packed struct {
        ///PIN [0:4]
        ///Pin number
        pin: u5 = 31,
        ///PORT [5:5]
        ///Port number
        port: u1 = 1,
        _unused6: u25 = 0,
        ///CONNECT [31:31]
        ///Connection
        connect: packed enum(u1) {
            ///Disconnect
            disconnected = 1,
            ///Connect
            connected = 0,
        } = .disconnected,
    };
    ///Pin select for DCX signal
    pub const pseldcx = Register(pseldcx_val).init(0x40003000 + 0x56C);

    //////////////////////////
    ///DCXCNT
    const dcxcnt_val = packed struct {
        ///DCXCNT [0:3]
        ///This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes.
        dcxcnt: u4 = 0,
        _unused4: u28 = 0,
    };
    ///DCX configuration
    pub const dcxcnt = Register(dcxcnt_val).init(0x40003000 + 0x570);

    //////////////////////////
    ///ORC
    const orc_val = packed struct {
        ///ORC [0:7]
        ///Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT.
        orc: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT
    pub const orc = Register(orc_val).init(0x40003000 + 0x5C0);
};

///SPI Slave 0
pub const spis0 = struct {

    //////////////////////////
    ///TASKS_ACQUIRE
    const tasks_acquire_val = packed struct {
        ///TASKS_ACQUIRE [0:0]
        ///Acquire SPI semaphore
        tasks_acquire: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Acquire SPI semaphore
    pub const tasks_acquire = RegisterRW(void, tasks_acquire_val).init(0x40003000 + 0x024);

    //////////////////////////
    ///TASKS_RELEASE
    const tasks_release_val = packed struct {
        ///TASKS_RELEASE [0:0]
        ///Release SPI semaphore, enabling the SPI slave to acquire it
        tasks_release: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Release SPI semaphore, enabling the SPI slave to acquire it
    pub const tasks_release = RegisterRW(void, tasks_release_val).init(0x40003000 + 0x028);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///Granted transaction completed
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Granted transaction completed
    pub const events_end = Register(events_end_val).init(0x40003000 + 0x104);

    //////////////////////////
    ///EVENTS_ENDRX
    const events_endrx_val = packed struct {
        ///EVENTS_ENDRX [0:0]
        ///End of RXD buffer reached
        events_endrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer reached
    pub const events_endrx = Register(events_endrx_val).init(0x40003000 + 0x110);

    //////////////////////////
    ///EVENTS_ACQUIRED
    const events_acquired_val = packed struct {
        ///EVENTS_ACQUIRED [0:0]
        ///Semaphore acquired
        events_acquired: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Semaphore acquired
    pub const events_acquired = Register(events_acquired_val).init(0x40003000 + 0x128);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u2 = 0,
        ///END_ACQUIRE [2:2]
        ///Shortcut between event END and task ACQUIRE
        end_acquire: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40003000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to enable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused11: u21 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to enable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused11: u21 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40003000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to disable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused11: u21 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to disable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused11: u21 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40003000 + 0x308);

    //////////////////////////
    ///SEMSTAT
    const semstat_val = packed struct {
        ///SEMSTAT [0:1]
        ///Semaphore status
        semstat: packed enum(u2) {
            ///Semaphore is free
            free = 0,
            ///Semaphore is assigned to CPU
            cpu = 1,
            ///Semaphore is assigned to SPI slave
            spis = 2,
            ///Semaphore is assigned to SPI but a handover to the CPU is pending
            cpupending = 3,
        } = .cpu,
        _unused2: u30 = 0,
    };
    ///Semaphore status register
    pub const semstat = RegisterRW(semstat_val, void).init(0x40003000 + 0x400);

    //////////////////////////
    ///STATUS
    const status_val_read = packed struct {
        ///OVERREAD [0:0]
        ///TX buffer over-read detected, and prevented
        overread: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///OVERFLOW [1:1]
        ///RX buffer overflow detected, and prevented
        overflow: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        _unused2: u30 = 0,
    };
    const status_val_write = packed struct {
        ///OVERREAD [0:0]
        ///TX buffer over-read detected, and prevented
        overread: packed enum(u1) {
            ///Write: clear error on writing '1'
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///OVERFLOW [1:1]
        ///RX buffer overflow detected, and prevented
        overflow: packed enum(u1) {
            ///Write: clear error on writing '1'
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u30 = 0,
    };
    ///Status from last transaction
    pub const status = RegisterRW(status_val_read, status_val_write).init(0x40003000 + 0x440);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable SPI slave
        enable: packed enum(u4) {
            ///Disable SPI slave
            disabled = 0,
            ///Enable SPI slave
            enabled = 2,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable SPI slave
    pub const enable = Register(enable_val).init(0x40003000 + 0x500);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ORDER [0:0]
        ///Bit order
        order: packed enum(u1) {
            ///Most significant bit shifted out first
            msb_first = 0,
            ///Least significant bit shifted out first
            lsb_first = 1,
        } = .msb_first,
        ///CPHA [1:1]
        ///Serial clock (SCK) phase
        cpha: packed enum(u1) {
            ///Sample on leading edge of clock, shift serial data on trailing edge
            leading = 0,
            ///Sample on trailing edge of clock, shift serial data on leading edge
            trailing = 1,
        } = .leading,
        ///CPOL [2:2]
        ///Serial clock (SCK) polarity
        cpol: packed enum(u1) {
            ///Active high
            active_high = 0,
            ///Active low
            active_low = 1,
        } = .active_high,
        _unused3: u29 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x40003000 + 0x554);

    //////////////////////////
    ///DEF
    const def_val = packed struct {
        ///DEF [0:7]
        ///Default character. Character clocked out in case of an ignored transaction.
        def: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Default character. Character clocked out in case of an ignored transaction.
    pub const def = Register(def_val).init(0x40003000 + 0x55C);

    //////////////////////////
    ///ORC
    const orc_val = packed struct {
        ///ORC [0:7]
        ///Over-read character. Character clocked out after an over-read of the transmit buffer.
        orc: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Over-read character
    pub const orc = Register(orc_val).init(0x40003000 + 0x5C0);
};

///I2C compatible Two-Wire Interface 0
pub const twi0 = struct {

    //////////////////////////
    ///TASKS_STARTRX
    const tasks_startrx_val = packed struct {
        ///TASKS_STARTRX [0:0]
        ///Start TWI receive sequence
        tasks_startrx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start TWI receive sequence
    pub const tasks_startrx = RegisterRW(void, tasks_startrx_val).init(0x40003000 + 0x000);

    //////////////////////////
    ///TASKS_STARTTX
    const tasks_starttx_val = packed struct {
        ///TASKS_STARTTX [0:0]
        ///Start TWI transmit sequence
        tasks_starttx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start TWI transmit sequence
    pub const tasks_starttx = RegisterRW(void, tasks_starttx_val).init(0x40003000 + 0x008);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop TWI transaction
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop TWI transaction
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40003000 + 0x014);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend TWI transaction
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend TWI transaction
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x40003000 + 0x01C);

    //////////////////////////
    ///TASKS_RESUME
    const tasks_resume_val = packed struct {
        ///TASKS_RESUME [0:0]
        ///Resume TWI transaction
        tasks_resume: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Resume TWI transaction
    pub const tasks_resume = RegisterRW(void, tasks_resume_val).init(0x40003000 + 0x020);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///TWI stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40003000 + 0x104);

    //////////////////////////
    ///EVENTS_RXDREADY
    const events_rxdready_val = packed struct {
        ///EVENTS_RXDREADY [0:0]
        ///TWI RXD byte received
        events_rxdready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI RXD byte received
    pub const events_rxdready = Register(events_rxdready_val).init(0x40003000 + 0x108);

    //////////////////////////
    ///EVENTS_TXDSENT
    const events_txdsent_val = packed struct {
        ///EVENTS_TXDSENT [0:0]
        ///TWI TXD byte sent
        events_txdsent: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI TXD byte sent
    pub const events_txdsent = Register(events_txdsent_val).init(0x40003000 + 0x11C);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///TWI error
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI error
    pub const events_error = Register(events_error_val).init(0x40003000 + 0x124);

    //////////////////////////
    ///EVENTS_BB
    const events_bb_val = packed struct {
        ///EVENTS_BB [0:0]
        ///TWI byte boundary, generated before each byte that is sent or received
        events_bb: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI byte boundary, generated before each byte that is sent or received
    pub const events_bb = Register(events_bb_val).init(0x40003000 + 0x138);

    //////////////////////////
    ///EVENTS_SUSPENDED
    const events_suspended_val = packed struct {
        ///EVENTS_SUSPENDED [0:0]
        ///TWI entered the suspended state
        events_suspended: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI entered the suspended state
    pub const events_suspended = Register(events_suspended_val).init(0x40003000 + 0x148);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///BB_SUSPEND [0:0]
        ///Shortcut between event BB and task SUSPEND
        bb_suspend: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///BB_STOP [1:1]
        ///Shortcut between event BB and task STOP
        bb_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused2: u30 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40003000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXDREADY [2:2]
        ///Write '1' to enable interrupt for event RXDREADY
        rxdready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u4 = 0,
        ///TXDSENT [7:7]
        ///Write '1' to enable interrupt for event TXDSENT
        txdsent: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u4 = 0,
        ///BB [14:14]
        ///Write '1' to enable interrupt for event BB
        bb: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused15: u3 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to enable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused19: u13 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RXDREADY [2:2]
        ///Write '1' to enable interrupt for event RXDREADY
        rxdready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u4 = 0,
        ///TXDSENT [7:7]
        ///Write '1' to enable interrupt for event TXDSENT
        txdsent: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u4 = 0,
        ///BB [14:14]
        ///Write '1' to enable interrupt for event BB
        bb: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused15: u3 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to enable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused19: u13 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40003000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXDREADY [2:2]
        ///Write '1' to disable interrupt for event RXDREADY
        rxdready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u4 = 0,
        ///TXDSENT [7:7]
        ///Write '1' to disable interrupt for event TXDSENT
        txdsent: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u4 = 0,
        ///BB [14:14]
        ///Write '1' to disable interrupt for event BB
        bb: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused15: u3 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to disable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused19: u13 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RXDREADY [2:2]
        ///Write '1' to disable interrupt for event RXDREADY
        rxdready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u4 = 0,
        ///TXDSENT [7:7]
        ///Write '1' to disable interrupt for event TXDSENT
        txdsent: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u4 = 0,
        ///BB [14:14]
        ///Write '1' to disable interrupt for event BB
        bb: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused15: u3 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to disable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused19: u13 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40003000 + 0x308);

    //////////////////////////
    ///ERRORSRC
    const errorsrc_val_read = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: packed enum(u1) {
            ///Read: no overrun occured
            not_present = 0,
            ///Read: overrun occured
            present = 1,
        } = .not_present,
        ///ANACK [1:1]
        ///NACK received after sending the address (write '1' to clear)
        anack: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///DNACK [2:2]
        ///NACK received after sending a data byte (write '1' to clear)
        dnack: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        _unused3: u29 = 0,
    };
    const errorsrc_val_write = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: u1 = 0,
        ///ANACK [1:1]
        ///NACK received after sending the address (write '1' to clear)
        anack: u1 = 0,
        ///DNACK [2:2]
        ///NACK received after sending a data byte (write '1' to clear)
        dnack: u1 = 0,
        _unused3: u29 = 0,
    };
    ///Error source
    pub const errorsrc = RegisterRW(errorsrc_val_read, errorsrc_val_write).init(0x40003000 + 0x4C4);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable TWI
        enable: packed enum(u4) {
            ///Disable TWI
            disabled = 0,
            ///Enable TWI
            enabled = 5,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable TWI
    pub const enable = Register(enable_val).init(0x40003000 + 0x500);

    //////////////////////////
    ///RXD
    const rxd_val = packed struct {
        ///RXD [0:7]
        ///RXD register
        rxd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///RXD register
    pub const rxd = RegisterRW(rxd_val, void).init(0x40003000 + 0x518);

    //////////////////////////
    ///TXD
    const txd_val = packed struct {
        ///TXD [0:7]
        ///TXD register
        txd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///TXD register
    pub const txd = Register(txd_val).init(0x40003000 + 0x51C);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///TWI master clock frequency
        frequency: packed enum(u32) {
            ///100 kbps
            k100 = 0x01980000,
            ///250 kbps
            k250 = 0x04000000,
            ///400 kbps (actual rate 410.256 kbps)
            k400 = 0x06680000,
            _zero = 0,
        } = ._zero,
    };
    ///TWI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x40003000 + 0x524);

    //////////////////////////
    ///ADDRESS
    const address_val = packed struct {
        ///ADDRESS [0:6]
        ///Address used in the TWI transfer
        address: u7 = 0,
        _unused7: u25 = 0,
    };
    ///Address used in the TWI transfer
    pub const address = Register(address_val).init(0x40003000 + 0x588);
};

///I2C compatible Two-Wire Master Interface with EasyDMA 0
pub const twim0 = struct {

    //////////////////////////
    ///TASKS_STARTRX
    const tasks_startrx_val = packed struct {
        ///TASKS_STARTRX [0:0]
        ///Start TWI receive sequence
        tasks_startrx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start TWI receive sequence
    pub const tasks_startrx = RegisterRW(void, tasks_startrx_val).init(0x40003000 + 0x000);

    //////////////////////////
    ///TASKS_STARTTX
    const tasks_starttx_val = packed struct {
        ///TASKS_STARTTX [0:0]
        ///Start TWI transmit sequence
        tasks_starttx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start TWI transmit sequence
    pub const tasks_starttx = RegisterRW(void, tasks_starttx_val).init(0x40003000 + 0x008);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop TWI transaction. Must be issued while the TWI master is not suspended.
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop TWI transaction. Must be issued while the TWI master is not suspended.
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40003000 + 0x014);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend TWI transaction
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend TWI transaction
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x40003000 + 0x01C);

    //////////////////////////
    ///TASKS_RESUME
    const tasks_resume_val = packed struct {
        ///TASKS_RESUME [0:0]
        ///Resume TWI transaction
        tasks_resume: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Resume TWI transaction
    pub const tasks_resume = RegisterRW(void, tasks_resume_val).init(0x40003000 + 0x020);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///TWI stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40003000 + 0x104);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///TWI error
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI error
    pub const events_error = Register(events_error_val).init(0x40003000 + 0x124);

    //////////////////////////
    ///EVENTS_SUSPENDED
    const events_suspended_val = packed struct {
        ///EVENTS_SUSPENDED [0:0]
        ///Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended.
        events_suspended: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended.
    pub const events_suspended = Register(events_suspended_val).init(0x40003000 + 0x148);

    //////////////////////////
    ///EVENTS_RXSTARTED
    const events_rxstarted_val = packed struct {
        ///EVENTS_RXSTARTED [0:0]
        ///Receive sequence started
        events_rxstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Receive sequence started
    pub const events_rxstarted = Register(events_rxstarted_val).init(0x40003000 + 0x14C);

    //////////////////////////
    ///EVENTS_TXSTARTED
    const events_txstarted_val = packed struct {
        ///EVENTS_TXSTARTED [0:0]
        ///Transmit sequence started
        events_txstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transmit sequence started
    pub const events_txstarted = Register(events_txstarted_val).init(0x40003000 + 0x150);

    //////////////////////////
    ///EVENTS_LASTRX
    const events_lastrx_val = packed struct {
        ///EVENTS_LASTRX [0:0]
        ///Byte boundary, starting to receive the last byte
        events_lastrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Byte boundary, starting to receive the last byte
    pub const events_lastrx = Register(events_lastrx_val).init(0x40003000 + 0x15C);

    //////////////////////////
    ///EVENTS_LASTTX
    const events_lasttx_val = packed struct {
        ///EVENTS_LASTTX [0:0]
        ///Byte boundary, starting to transmit the last byte
        events_lasttx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Byte boundary, starting to transmit the last byte
    pub const events_lasttx = Register(events_lasttx_val).init(0x40003000 + 0x160);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u7 = 0,
        ///LASTTX_STARTRX [7:7]
        ///Shortcut between event LASTTX and task STARTRX
        lasttx_startrx: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LASTTX_SUSPEND [8:8]
        ///Shortcut between event LASTTX and task SUSPEND
        lasttx_suspend: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LASTTX_STOP [9:9]
        ///Shortcut between event LASTTX and task STOP
        lasttx_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LASTRX_STARTTX [10:10]
        ///Shortcut between event LASTRX and task STARTTX
        lastrx_starttx: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LASTRX_SUSPEND [11:11]
        ///Shortcut between event LASTRX and task SUSPEND
        lastrx_suspend: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LASTRX_STOP [12:12]
        ///Shortcut between event LASTRX and task STOP
        lastrx_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused13: u19 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40003000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Enable or disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused10: u8 = 0,
        ///SUSPENDED [18:18]
        ///Enable or disable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///RXSTARTED [19:19]
        ///Enable or disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Enable or disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused21: u2 = 0,
        ///LASTRX [23:23]
        ///Enable or disable interrupt for event LASTRX
        lastrx: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///LASTTX [24:24]
        ///Enable or disable interrupt for event LASTTX
        lasttx: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused25: u7 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40003000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u8 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to enable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u2 = 0,
        ///LASTRX [23:23]
        ///Write '1' to enable interrupt for event LASTRX
        lastrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LASTTX [24:24]
        ///Write '1' to enable interrupt for event LASTTX
        lasttx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused25: u7 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u8 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to enable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u2 = 0,
        ///LASTRX [23:23]
        ///Write '1' to enable interrupt for event LASTRX
        lastrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///LASTTX [24:24]
        ///Write '1' to enable interrupt for event LASTTX
        lasttx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused25: u7 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40003000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u8 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to disable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u2 = 0,
        ///LASTRX [23:23]
        ///Write '1' to disable interrupt for event LASTRX
        lastrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LASTTX [24:24]
        ///Write '1' to disable interrupt for event LASTTX
        lasttx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused25: u7 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u8 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to disable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u2 = 0,
        ///LASTRX [23:23]
        ///Write '1' to disable interrupt for event LASTRX
        lastrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///LASTTX [24:24]
        ///Write '1' to disable interrupt for event LASTTX
        lasttx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused25: u7 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40003000 + 0x308);

    //////////////////////////
    ///ERRORSRC
    const errorsrc_val = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: packed enum(u1) {
            ///Error did not occur
            not_received = 0,
            ///Error occurred
            received = 1,
        } = .not_received,
        ///ANACK [1:1]
        ///NACK received after sending the address (write '1' to clear)
        anack: packed enum(u1) {
            ///Error did not occur
            not_received = 0,
            ///Error occurred
            received = 1,
        } = .not_received,
        ///DNACK [2:2]
        ///NACK received after sending a data byte (write '1' to clear)
        dnack: packed enum(u1) {
            ///Error did not occur
            not_received = 0,
            ///Error occurred
            received = 1,
        } = .not_received,
        _unused3: u29 = 0,
    };
    ///Error source
    pub const errorsrc = Register(errorsrc_val).init(0x40003000 + 0x4C4);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable TWIM
        enable: packed enum(u4) {
            ///Disable TWIM
            disabled = 0,
            ///Enable TWIM
            enabled = 6,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable TWIM
    pub const enable = Register(enable_val).init(0x40003000 + 0x500);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///TWI master clock frequency
        frequency: packed enum(u32) {
            ///100 kbps
            k100 = 0x01980000,
            ///250 kbps
            k250 = 0x04000000,
            ///400 kbps
            k400 = 0x06400000,
            _zero = 0,
        } = ._zero,
    };
    ///TWI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x40003000 + 0x524);

    //////////////////////////
    ///ADDRESS
    const address_val = packed struct {
        ///ADDRESS [0:6]
        ///Address used in the TWI transfer
        address: u7 = 0,
        _unused7: u25 = 0,
    };
    ///Address used in the TWI transfer
    pub const address = Register(address_val).init(0x40003000 + 0x588);
};

///I2C compatible Two-Wire Slave Interface with EasyDMA 0
pub const twis0 = struct {

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop TWI transaction
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop TWI transaction
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40003000 + 0x014);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend TWI transaction
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend TWI transaction
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x40003000 + 0x01C);

    //////////////////////////
    ///TASKS_RESUME
    const tasks_resume_val = packed struct {
        ///TASKS_RESUME [0:0]
        ///Resume TWI transaction
        tasks_resume: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Resume TWI transaction
    pub const tasks_resume = RegisterRW(void, tasks_resume_val).init(0x40003000 + 0x020);

    //////////////////////////
    ///TASKS_PREPARERX
    const tasks_preparerx_val = packed struct {
        ///TASKS_PREPARERX [0:0]
        ///Prepare the TWI slave to respond to a write command
        tasks_preparerx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Prepare the TWI slave to respond to a write command
    pub const tasks_preparerx = RegisterRW(void, tasks_preparerx_val).init(0x40003000 + 0x030);

    //////////////////////////
    ///TASKS_PREPARETX
    const tasks_preparetx_val = packed struct {
        ///TASKS_PREPARETX [0:0]
        ///Prepare the TWI slave to respond to a read command
        tasks_preparetx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Prepare the TWI slave to respond to a read command
    pub const tasks_preparetx = RegisterRW(void, tasks_preparetx_val).init(0x40003000 + 0x034);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///TWI stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40003000 + 0x104);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///TWI error
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI error
    pub const events_error = Register(events_error_val).init(0x40003000 + 0x124);

    //////////////////////////
    ///EVENTS_RXSTARTED
    const events_rxstarted_val = packed struct {
        ///EVENTS_RXSTARTED [0:0]
        ///Receive sequence started
        events_rxstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Receive sequence started
    pub const events_rxstarted = Register(events_rxstarted_val).init(0x40003000 + 0x14C);

    //////////////////////////
    ///EVENTS_TXSTARTED
    const events_txstarted_val = packed struct {
        ///EVENTS_TXSTARTED [0:0]
        ///Transmit sequence started
        events_txstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transmit sequence started
    pub const events_txstarted = Register(events_txstarted_val).init(0x40003000 + 0x150);

    //////////////////////////
    ///EVENTS_WRITE
    const events_write_val = packed struct {
        ///EVENTS_WRITE [0:0]
        ///Write command received
        events_write: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Write command received
    pub const events_write = Register(events_write_val).init(0x40003000 + 0x164);

    //////////////////////////
    ///EVENTS_READ
    const events_read_val = packed struct {
        ///EVENTS_READ [0:0]
        ///Read command received
        events_read: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Read command received
    pub const events_read = Register(events_read_val).init(0x40003000 + 0x168);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u13 = 0,
        ///WRITE_SUSPEND [13:13]
        ///Shortcut between event WRITE and task SUSPEND
        write_suspend: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///READ_SUSPEND [14:14]
        ///Shortcut between event READ and task SUSPEND
        read_suspend: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused15: u17 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40003000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Enable or disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused10: u9 = 0,
        ///RXSTARTED [19:19]
        ///Enable or disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Enable or disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused21: u4 = 0,
        ///WRITE [25:25]
        ///Enable or disable interrupt for event WRITE
        write: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///READ [26:26]
        ///Enable or disable interrupt for event READ
        read: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused27: u5 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40003000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u9 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u4 = 0,
        ///WRITE [25:25]
        ///Write '1' to enable interrupt for event WRITE
        write: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///READ [26:26]
        ///Write '1' to enable interrupt for event READ
        read: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused27: u5 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u9 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u4 = 0,
        ///WRITE [25:25]
        ///Write '1' to enable interrupt for event WRITE
        write: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///READ [26:26]
        ///Write '1' to enable interrupt for event READ
        read: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused27: u5 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40003000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u9 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u4 = 0,
        ///WRITE [25:25]
        ///Write '1' to disable interrupt for event WRITE
        write: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///READ [26:26]
        ///Write '1' to disable interrupt for event READ
        read: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused27: u5 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u9 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u4 = 0,
        ///WRITE [25:25]
        ///Write '1' to disable interrupt for event WRITE
        write: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///READ [26:26]
        ///Write '1' to disable interrupt for event READ
        read: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused27: u5 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40003000 + 0x308);

    //////////////////////////
    ///ERRORSRC
    const errorsrc_val = packed struct {
        ///OVERFLOW [0:0]
        ///RX buffer overflow detected, and prevented
        overflow: packed enum(u1) {
            ///Error did not occur
            not_detected = 0,
            ///Error occurred
            detected = 1,
        } = .not_detected,
        _unused1: u1 = 0,
        ///DNACK [2:2]
        ///NACK sent after receiving a data byte
        dnack: packed enum(u1) {
            ///Error did not occur
            not_received = 0,
            ///Error occurred
            received = 1,
        } = .not_received,
        ///OVERREAD [3:3]
        ///TX buffer over-read detected, and prevented
        overread: packed enum(u1) {
            ///Error did not occur
            not_detected = 0,
            ///Error occurred
            detected = 1,
        } = .not_detected,
        _unused4: u28 = 0,
    };
    ///Error source
    pub const errorsrc = Register(errorsrc_val).init(0x40003000 + 0x4D0);

    //////////////////////////
    ///MATCH
    const match_val = packed struct {
        ///MATCH [0:0]
        ///Which of the addresses in {ADDRESS} matched the incoming address
        match: u1 = 0,
        _unused1: u31 = 0,
    };
    ///Status register indicating which address had a match
    pub const match = RegisterRW(match_val, void).init(0x40003000 + 0x4D4);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable TWIS
        enable: packed enum(u4) {
            ///Disable TWIS
            disabled = 0,
            ///Enable TWIS
            enabled = 9,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable TWIS
    pub const enable = Register(enable_val).init(0x40003000 + 0x500);

    //////////////////////////
    ///ADDRESS[%s]
    const address_val = packed struct {
        ///ADDRESS [0:6]
        ///TWI slave address
        address: u7 = 0,
        _unused7: u25 = 0,
    };
    ///Description collection: TWI slave address n
    pub const address = Register(address_val).initRange(0x40003000 + 0x588, 4, 2);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ADDRESS0 [0:0]
        ///Enable or disable address matching on ADDRESS[0]
        address0: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .enabled,
        ///ADDRESS1 [1:1]
        ///Enable or disable address matching on ADDRESS[1]
        address1: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u30 = 0,
    };
    ///Configuration register for the address match mechanism
    pub const config = Register(config_val).init(0x40003000 + 0x594);

    //////////////////////////
    ///ORC
    const orc_val = packed struct {
        ///ORC [0:7]
        ///Over-read character. Character sent out in case of an over-read of the transmit buffer.
        orc: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Over-read character. Character sent out in case of an over-read of the transmit buffer.
    pub const orc = Register(orc_val).init(0x40003000 + 0x5C0);
};

///Serial Peripheral Interface 1
pub const spi1 = struct {

    //////////////////////////
    ///EVENTS_READY
    const events_ready_val = packed struct {
        ///EVENTS_READY [0:0]
        ///TXD byte sent and RXD byte received
        events_ready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TXD byte sent and RXD byte received
    pub const events_ready = Register(events_ready_val).init(0x40004000 + 0x108);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40004000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40004000 + 0x308);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable SPI
        enable: packed enum(u4) {
            ///Disable SPI
            disabled = 0,
            ///Enable SPI
            enabled = 1,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable SPI
    pub const enable = Register(enable_val).init(0x40004000 + 0x500);

    //////////////////////////
    ///RXD
    const rxd_val = packed struct {
        ///RXD [0:7]
        ///RX data received. Double buffered
        rxd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///RXD register
    pub const rxd = RegisterRW(rxd_val, void).init(0x40004000 + 0x518);

    //////////////////////////
    ///TXD
    const txd_val = packed struct {
        ///TXD [0:7]
        ///TX data to send. Double buffered
        txd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///TXD register
    pub const txd = Register(txd_val).init(0x40004000 + 0x51C);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///SPI master data rate
        frequency: packed enum(u32) {
            ///125 kbps
            k125 = 0x02000000,
            ///250 kbps
            k250 = 0x04000000,
            ///500 kbps
            k500 = 0x08000000,
            ///1 Mbps
            m1 = 0x10000000,
            ///2 Mbps
            m2 = 0x20000000,
            ///4 Mbps
            m4 = 0x40000000,
            ///8 Mbps
            m8 = 0x80000000,
            _zero = 0,
        } = ._zero,
    };
    ///SPI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x40004000 + 0x524);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ORDER [0:0]
        ///Bit order
        order: packed enum(u1) {
            ///Most significant bit shifted out first
            msb_first = 0,
            ///Least significant bit shifted out first
            lsb_first = 1,
        } = .msb_first,
        ///CPHA [1:1]
        ///Serial clock (SCK) phase
        cpha: packed enum(u1) {
            ///Sample on leading edge of clock, shift serial data on trailing edge
            leading = 0,
            ///Sample on trailing edge of clock, shift serial data on leading edge
            trailing = 1,
        } = .leading,
        ///CPOL [2:2]
        ///Serial clock (SCK) polarity
        cpol: packed enum(u1) {
            ///Active high
            active_high = 0,
            ///Active low
            active_low = 1,
        } = .active_high,
        _unused3: u29 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x40004000 + 0x554);
};

///Serial Peripheral Interface Master with EasyDMA 1
pub const spim1 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start SPI transaction
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start SPI transaction
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40004000 + 0x010);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop SPI transaction
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop SPI transaction
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40004000 + 0x014);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend SPI transaction
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend SPI transaction
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x40004000 + 0x01C);

    //////////////////////////
    ///TASKS_RESUME
    const tasks_resume_val = packed struct {
        ///TASKS_RESUME [0:0]
        ///Resume SPI transaction
        tasks_resume: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Resume SPI transaction
    pub const tasks_resume = RegisterRW(void, tasks_resume_val).init(0x40004000 + 0x020);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///SPI transaction has stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///SPI transaction has stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40004000 + 0x104);

    //////////////////////////
    ///EVENTS_ENDRX
    const events_endrx_val = packed struct {
        ///EVENTS_ENDRX [0:0]
        ///End of RXD buffer reached
        events_endrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer reached
    pub const events_endrx = Register(events_endrx_val).init(0x40004000 + 0x110);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///End of RXD buffer and TXD buffer reached
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer and TXD buffer reached
    pub const events_end = Register(events_end_val).init(0x40004000 + 0x118);

    //////////////////////////
    ///EVENTS_ENDTX
    const events_endtx_val = packed struct {
        ///EVENTS_ENDTX [0:0]
        ///End of TXD buffer reached
        events_endtx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of TXD buffer reached
    pub const events_endtx = Register(events_endtx_val).init(0x40004000 + 0x120);

    //////////////////////////
    ///EVENTS_STARTED
    const events_started_val = packed struct {
        ///EVENTS_STARTED [0:0]
        ///Transaction started
        events_started: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transaction started
    pub const events_started = Register(events_started_val).init(0x40004000 + 0x14C);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u17 = 0,
        ///END_START [17:17]
        ///Shortcut between event END and task START
        end_start: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused18: u14 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40004000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40004000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40004000 + 0x308);

    //////////////////////////
    ///STALLSTAT
    const stallstat_val = packed struct {
        ///TX [0:0]
        ///Stall status for EasyDMA RAM reads
        tx: packed enum(u1) {
            ///No stall
            nostall = 0,
            ///A stall has occurred
            stall = 1,
        } = .nostall,
        ///RX [1:1]
        ///Stall status for EasyDMA RAM writes
        rx: packed enum(u1) {
            ///No stall
            nostall = 0,
            ///A stall has occurred
            stall = 1,
        } = .nostall,
        _unused2: u30 = 0,
    };
    ///Stall status for EasyDMA RAM accesses. The fields in this register is set to STALL by hardware whenever a stall occurres and can be cleared (set to NOSTALL) by the CPU.
    pub const stallstat = Register(stallstat_val).init(0x40004000 + 0x400);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable SPIM
        enable: packed enum(u4) {
            ///Disable SPIM
            disabled = 0,
            ///Enable SPIM
            enabled = 7,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable SPIM
    pub const enable = Register(enable_val).init(0x40004000 + 0x500);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///SPI master data rate
        frequency: packed enum(u32) {
            ///125 kbps
            k125 = 0x02000000,
            ///250 kbps
            k250 = 0x04000000,
            ///500 kbps
            k500 = 0x08000000,
            ///1 Mbps
            m1 = 0x10000000,
            ///2 Mbps
            m2 = 0x20000000,
            ///4 Mbps
            m4 = 0x40000000,
            ///8 Mbps
            m8 = 0x80000000,
            ///16 Mbps
            m16 = 0x0A000000,
            ///32 Mbps
            m32 = 0x14000000,
            _zero = 0,
        } = ._zero,
    };
    ///SPI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x40004000 + 0x524);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ORDER [0:0]
        ///Bit order
        order: packed enum(u1) {
            ///Most significant bit shifted out first
            msb_first = 0,
            ///Least significant bit shifted out first
            lsb_first = 1,
        } = .msb_first,
        ///CPHA [1:1]
        ///Serial clock (SCK) phase
        cpha: packed enum(u1) {
            ///Sample on leading edge of clock, shift serial data on trailing edge
            leading = 0,
            ///Sample on trailing edge of clock, shift serial data on leading edge
            trailing = 1,
        } = .leading,
        ///CPOL [2:2]
        ///Serial clock (SCK) polarity
        cpol: packed enum(u1) {
            ///Active high
            active_high = 0,
            ///Active low
            active_low = 1,
        } = .active_high,
        _unused3: u29 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x40004000 + 0x554);

    //////////////////////////
    ///CSNPOL
    const csnpol_val = packed struct {
        ///CSNPOL [0:0]
        ///Polarity of CSN output
        csnpol: packed enum(u1) {
            ///Active low (idle state high)
            low = 0,
            ///Active high (idle state low)
            high = 1,
        } = .low,
        _unused1: u31 = 0,
    };
    ///Polarity of CSN output
    pub const csnpol = Register(csnpol_val).init(0x40004000 + 0x568);

    //////////////////////////
    ///PSELDCX
    const pseldcx_val = packed struct {
        ///PIN [0:4]
        ///Pin number
        pin: u5 = 31,
        ///PORT [5:5]
        ///Port number
        port: u1 = 1,
        _unused6: u25 = 0,
        ///CONNECT [31:31]
        ///Connection
        connect: packed enum(u1) {
            ///Disconnect
            disconnected = 1,
            ///Connect
            connected = 0,
        } = .disconnected,
    };
    ///Pin select for DCX signal
    pub const pseldcx = Register(pseldcx_val).init(0x40004000 + 0x56C);

    //////////////////////////
    ///DCXCNT
    const dcxcnt_val = packed struct {
        ///DCXCNT [0:3]
        ///This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes.
        dcxcnt: u4 = 0,
        _unused4: u28 = 0,
    };
    ///DCX configuration
    pub const dcxcnt = Register(dcxcnt_val).init(0x40004000 + 0x570);

    //////////////////////////
    ///ORC
    const orc_val = packed struct {
        ///ORC [0:7]
        ///Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT.
        orc: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT
    pub const orc = Register(orc_val).init(0x40004000 + 0x5C0);
};

///SPI Slave 1
pub const spis1 = struct {

    //////////////////////////
    ///TASKS_ACQUIRE
    const tasks_acquire_val = packed struct {
        ///TASKS_ACQUIRE [0:0]
        ///Acquire SPI semaphore
        tasks_acquire: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Acquire SPI semaphore
    pub const tasks_acquire = RegisterRW(void, tasks_acquire_val).init(0x40004000 + 0x024);

    //////////////////////////
    ///TASKS_RELEASE
    const tasks_release_val = packed struct {
        ///TASKS_RELEASE [0:0]
        ///Release SPI semaphore, enabling the SPI slave to acquire it
        tasks_release: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Release SPI semaphore, enabling the SPI slave to acquire it
    pub const tasks_release = RegisterRW(void, tasks_release_val).init(0x40004000 + 0x028);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///Granted transaction completed
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Granted transaction completed
    pub const events_end = Register(events_end_val).init(0x40004000 + 0x104);

    //////////////////////////
    ///EVENTS_ENDRX
    const events_endrx_val = packed struct {
        ///EVENTS_ENDRX [0:0]
        ///End of RXD buffer reached
        events_endrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer reached
    pub const events_endrx = Register(events_endrx_val).init(0x40004000 + 0x110);

    //////////////////////////
    ///EVENTS_ACQUIRED
    const events_acquired_val = packed struct {
        ///EVENTS_ACQUIRED [0:0]
        ///Semaphore acquired
        events_acquired: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Semaphore acquired
    pub const events_acquired = Register(events_acquired_val).init(0x40004000 + 0x128);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u2 = 0,
        ///END_ACQUIRE [2:2]
        ///Shortcut between event END and task ACQUIRE
        end_acquire: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40004000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to enable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused11: u21 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to enable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused11: u21 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40004000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to disable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused11: u21 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to disable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused11: u21 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40004000 + 0x308);

    //////////////////////////
    ///SEMSTAT
    const semstat_val = packed struct {
        ///SEMSTAT [0:1]
        ///Semaphore status
        semstat: packed enum(u2) {
            ///Semaphore is free
            free = 0,
            ///Semaphore is assigned to CPU
            cpu = 1,
            ///Semaphore is assigned to SPI slave
            spis = 2,
            ///Semaphore is assigned to SPI but a handover to the CPU is pending
            cpupending = 3,
        } = .cpu,
        _unused2: u30 = 0,
    };
    ///Semaphore status register
    pub const semstat = RegisterRW(semstat_val, void).init(0x40004000 + 0x400);

    //////////////////////////
    ///STATUS
    const status_val_read = packed struct {
        ///OVERREAD [0:0]
        ///TX buffer over-read detected, and prevented
        overread: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///OVERFLOW [1:1]
        ///RX buffer overflow detected, and prevented
        overflow: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        _unused2: u30 = 0,
    };
    const status_val_write = packed struct {
        ///OVERREAD [0:0]
        ///TX buffer over-read detected, and prevented
        overread: packed enum(u1) {
            ///Write: clear error on writing '1'
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///OVERFLOW [1:1]
        ///RX buffer overflow detected, and prevented
        overflow: packed enum(u1) {
            ///Write: clear error on writing '1'
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u30 = 0,
    };
    ///Status from last transaction
    pub const status = RegisterRW(status_val_read, status_val_write).init(0x40004000 + 0x440);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable SPI slave
        enable: packed enum(u4) {
            ///Disable SPI slave
            disabled = 0,
            ///Enable SPI slave
            enabled = 2,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable SPI slave
    pub const enable = Register(enable_val).init(0x40004000 + 0x500);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ORDER [0:0]
        ///Bit order
        order: packed enum(u1) {
            ///Most significant bit shifted out first
            msb_first = 0,
            ///Least significant bit shifted out first
            lsb_first = 1,
        } = .msb_first,
        ///CPHA [1:1]
        ///Serial clock (SCK) phase
        cpha: packed enum(u1) {
            ///Sample on leading edge of clock, shift serial data on trailing edge
            leading = 0,
            ///Sample on trailing edge of clock, shift serial data on leading edge
            trailing = 1,
        } = .leading,
        ///CPOL [2:2]
        ///Serial clock (SCK) polarity
        cpol: packed enum(u1) {
            ///Active high
            active_high = 0,
            ///Active low
            active_low = 1,
        } = .active_high,
        _unused3: u29 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x40004000 + 0x554);

    //////////////////////////
    ///DEF
    const def_val = packed struct {
        ///DEF [0:7]
        ///Default character. Character clocked out in case of an ignored transaction.
        def: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Default character. Character clocked out in case of an ignored transaction.
    pub const def = Register(def_val).init(0x40004000 + 0x55C);

    //////////////////////////
    ///ORC
    const orc_val = packed struct {
        ///ORC [0:7]
        ///Over-read character. Character clocked out after an over-read of the transmit buffer.
        orc: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Over-read character
    pub const orc = Register(orc_val).init(0x40004000 + 0x5C0);
};

///I2C compatible Two-Wire Interface 1
pub const twi1 = struct {

    //////////////////////////
    ///TASKS_STARTRX
    const tasks_startrx_val = packed struct {
        ///TASKS_STARTRX [0:0]
        ///Start TWI receive sequence
        tasks_startrx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start TWI receive sequence
    pub const tasks_startrx = RegisterRW(void, tasks_startrx_val).init(0x40004000 + 0x000);

    //////////////////////////
    ///TASKS_STARTTX
    const tasks_starttx_val = packed struct {
        ///TASKS_STARTTX [0:0]
        ///Start TWI transmit sequence
        tasks_starttx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start TWI transmit sequence
    pub const tasks_starttx = RegisterRW(void, tasks_starttx_val).init(0x40004000 + 0x008);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop TWI transaction
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop TWI transaction
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40004000 + 0x014);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend TWI transaction
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend TWI transaction
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x40004000 + 0x01C);

    //////////////////////////
    ///TASKS_RESUME
    const tasks_resume_val = packed struct {
        ///TASKS_RESUME [0:0]
        ///Resume TWI transaction
        tasks_resume: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Resume TWI transaction
    pub const tasks_resume = RegisterRW(void, tasks_resume_val).init(0x40004000 + 0x020);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///TWI stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40004000 + 0x104);

    //////////////////////////
    ///EVENTS_RXDREADY
    const events_rxdready_val = packed struct {
        ///EVENTS_RXDREADY [0:0]
        ///TWI RXD byte received
        events_rxdready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI RXD byte received
    pub const events_rxdready = Register(events_rxdready_val).init(0x40004000 + 0x108);

    //////////////////////////
    ///EVENTS_TXDSENT
    const events_txdsent_val = packed struct {
        ///EVENTS_TXDSENT [0:0]
        ///TWI TXD byte sent
        events_txdsent: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI TXD byte sent
    pub const events_txdsent = Register(events_txdsent_val).init(0x40004000 + 0x11C);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///TWI error
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI error
    pub const events_error = Register(events_error_val).init(0x40004000 + 0x124);

    //////////////////////////
    ///EVENTS_BB
    const events_bb_val = packed struct {
        ///EVENTS_BB [0:0]
        ///TWI byte boundary, generated before each byte that is sent or received
        events_bb: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI byte boundary, generated before each byte that is sent or received
    pub const events_bb = Register(events_bb_val).init(0x40004000 + 0x138);

    //////////////////////////
    ///EVENTS_SUSPENDED
    const events_suspended_val = packed struct {
        ///EVENTS_SUSPENDED [0:0]
        ///TWI entered the suspended state
        events_suspended: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI entered the suspended state
    pub const events_suspended = Register(events_suspended_val).init(0x40004000 + 0x148);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///BB_SUSPEND [0:0]
        ///Shortcut between event BB and task SUSPEND
        bb_suspend: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///BB_STOP [1:1]
        ///Shortcut between event BB and task STOP
        bb_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused2: u30 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40004000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXDREADY [2:2]
        ///Write '1' to enable interrupt for event RXDREADY
        rxdready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u4 = 0,
        ///TXDSENT [7:7]
        ///Write '1' to enable interrupt for event TXDSENT
        txdsent: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u4 = 0,
        ///BB [14:14]
        ///Write '1' to enable interrupt for event BB
        bb: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused15: u3 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to enable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused19: u13 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RXDREADY [2:2]
        ///Write '1' to enable interrupt for event RXDREADY
        rxdready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u4 = 0,
        ///TXDSENT [7:7]
        ///Write '1' to enable interrupt for event TXDSENT
        txdsent: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u4 = 0,
        ///BB [14:14]
        ///Write '1' to enable interrupt for event BB
        bb: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused15: u3 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to enable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused19: u13 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40004000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXDREADY [2:2]
        ///Write '1' to disable interrupt for event RXDREADY
        rxdready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u4 = 0,
        ///TXDSENT [7:7]
        ///Write '1' to disable interrupt for event TXDSENT
        txdsent: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u4 = 0,
        ///BB [14:14]
        ///Write '1' to disable interrupt for event BB
        bb: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused15: u3 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to disable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused19: u13 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RXDREADY [2:2]
        ///Write '1' to disable interrupt for event RXDREADY
        rxdready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u4 = 0,
        ///TXDSENT [7:7]
        ///Write '1' to disable interrupt for event TXDSENT
        txdsent: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u1 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u4 = 0,
        ///BB [14:14]
        ///Write '1' to disable interrupt for event BB
        bb: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused15: u3 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to disable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused19: u13 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40004000 + 0x308);

    //////////////////////////
    ///ERRORSRC
    const errorsrc_val_read = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: packed enum(u1) {
            ///Read: no overrun occured
            not_present = 0,
            ///Read: overrun occured
            present = 1,
        } = .not_present,
        ///ANACK [1:1]
        ///NACK received after sending the address (write '1' to clear)
        anack: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///DNACK [2:2]
        ///NACK received after sending a data byte (write '1' to clear)
        dnack: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        _unused3: u29 = 0,
    };
    const errorsrc_val_write = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: u1 = 0,
        ///ANACK [1:1]
        ///NACK received after sending the address (write '1' to clear)
        anack: u1 = 0,
        ///DNACK [2:2]
        ///NACK received after sending a data byte (write '1' to clear)
        dnack: u1 = 0,
        _unused3: u29 = 0,
    };
    ///Error source
    pub const errorsrc = RegisterRW(errorsrc_val_read, errorsrc_val_write).init(0x40004000 + 0x4C4);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable TWI
        enable: packed enum(u4) {
            ///Disable TWI
            disabled = 0,
            ///Enable TWI
            enabled = 5,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable TWI
    pub const enable = Register(enable_val).init(0x40004000 + 0x500);

    //////////////////////////
    ///RXD
    const rxd_val = packed struct {
        ///RXD [0:7]
        ///RXD register
        rxd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///RXD register
    pub const rxd = RegisterRW(rxd_val, void).init(0x40004000 + 0x518);

    //////////////////////////
    ///TXD
    const txd_val = packed struct {
        ///TXD [0:7]
        ///TXD register
        txd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///TXD register
    pub const txd = Register(txd_val).init(0x40004000 + 0x51C);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///TWI master clock frequency
        frequency: packed enum(u32) {
            ///100 kbps
            k100 = 0x01980000,
            ///250 kbps
            k250 = 0x04000000,
            ///400 kbps (actual rate 410.256 kbps)
            k400 = 0x06680000,
            _zero = 0,
        } = ._zero,
    };
    ///TWI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x40004000 + 0x524);

    //////////////////////////
    ///ADDRESS
    const address_val = packed struct {
        ///ADDRESS [0:6]
        ///Address used in the TWI transfer
        address: u7 = 0,
        _unused7: u25 = 0,
    };
    ///Address used in the TWI transfer
    pub const address = Register(address_val).init(0x40004000 + 0x588);
};

///I2C compatible Two-Wire Master Interface with EasyDMA 1
pub const twim1 = struct {

    //////////////////////////
    ///TASKS_STARTRX
    const tasks_startrx_val = packed struct {
        ///TASKS_STARTRX [0:0]
        ///Start TWI receive sequence
        tasks_startrx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start TWI receive sequence
    pub const tasks_startrx = RegisterRW(void, tasks_startrx_val).init(0x40004000 + 0x000);

    //////////////////////////
    ///TASKS_STARTTX
    const tasks_starttx_val = packed struct {
        ///TASKS_STARTTX [0:0]
        ///Start TWI transmit sequence
        tasks_starttx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start TWI transmit sequence
    pub const tasks_starttx = RegisterRW(void, tasks_starttx_val).init(0x40004000 + 0x008);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop TWI transaction. Must be issued while the TWI master is not suspended.
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop TWI transaction. Must be issued while the TWI master is not suspended.
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40004000 + 0x014);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend TWI transaction
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend TWI transaction
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x40004000 + 0x01C);

    //////////////////////////
    ///TASKS_RESUME
    const tasks_resume_val = packed struct {
        ///TASKS_RESUME [0:0]
        ///Resume TWI transaction
        tasks_resume: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Resume TWI transaction
    pub const tasks_resume = RegisterRW(void, tasks_resume_val).init(0x40004000 + 0x020);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///TWI stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40004000 + 0x104);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///TWI error
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI error
    pub const events_error = Register(events_error_val).init(0x40004000 + 0x124);

    //////////////////////////
    ///EVENTS_SUSPENDED
    const events_suspended_val = packed struct {
        ///EVENTS_SUSPENDED [0:0]
        ///Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended.
        events_suspended: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended.
    pub const events_suspended = Register(events_suspended_val).init(0x40004000 + 0x148);

    //////////////////////////
    ///EVENTS_RXSTARTED
    const events_rxstarted_val = packed struct {
        ///EVENTS_RXSTARTED [0:0]
        ///Receive sequence started
        events_rxstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Receive sequence started
    pub const events_rxstarted = Register(events_rxstarted_val).init(0x40004000 + 0x14C);

    //////////////////////////
    ///EVENTS_TXSTARTED
    const events_txstarted_val = packed struct {
        ///EVENTS_TXSTARTED [0:0]
        ///Transmit sequence started
        events_txstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transmit sequence started
    pub const events_txstarted = Register(events_txstarted_val).init(0x40004000 + 0x150);

    //////////////////////////
    ///EVENTS_LASTRX
    const events_lastrx_val = packed struct {
        ///EVENTS_LASTRX [0:0]
        ///Byte boundary, starting to receive the last byte
        events_lastrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Byte boundary, starting to receive the last byte
    pub const events_lastrx = Register(events_lastrx_val).init(0x40004000 + 0x15C);

    //////////////////////////
    ///EVENTS_LASTTX
    const events_lasttx_val = packed struct {
        ///EVENTS_LASTTX [0:0]
        ///Byte boundary, starting to transmit the last byte
        events_lasttx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Byte boundary, starting to transmit the last byte
    pub const events_lasttx = Register(events_lasttx_val).init(0x40004000 + 0x160);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u7 = 0,
        ///LASTTX_STARTRX [7:7]
        ///Shortcut between event LASTTX and task STARTRX
        lasttx_startrx: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LASTTX_SUSPEND [8:8]
        ///Shortcut between event LASTTX and task SUSPEND
        lasttx_suspend: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LASTTX_STOP [9:9]
        ///Shortcut between event LASTTX and task STOP
        lasttx_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LASTRX_STARTTX [10:10]
        ///Shortcut between event LASTRX and task STARTTX
        lastrx_starttx: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LASTRX_SUSPEND [11:11]
        ///Shortcut between event LASTRX and task SUSPEND
        lastrx_suspend: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LASTRX_STOP [12:12]
        ///Shortcut between event LASTRX and task STOP
        lastrx_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused13: u19 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40004000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Enable or disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused10: u8 = 0,
        ///SUSPENDED [18:18]
        ///Enable or disable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///RXSTARTED [19:19]
        ///Enable or disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Enable or disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused21: u2 = 0,
        ///LASTRX [23:23]
        ///Enable or disable interrupt for event LASTRX
        lastrx: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///LASTTX [24:24]
        ///Enable or disable interrupt for event LASTTX
        lasttx: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused25: u7 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40004000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u8 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to enable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u2 = 0,
        ///LASTRX [23:23]
        ///Write '1' to enable interrupt for event LASTRX
        lastrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LASTTX [24:24]
        ///Write '1' to enable interrupt for event LASTTX
        lasttx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused25: u7 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u8 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to enable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u2 = 0,
        ///LASTRX [23:23]
        ///Write '1' to enable interrupt for event LASTRX
        lastrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///LASTTX [24:24]
        ///Write '1' to enable interrupt for event LASTTX
        lasttx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused25: u7 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40004000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u8 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to disable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u2 = 0,
        ///LASTRX [23:23]
        ///Write '1' to disable interrupt for event LASTRX
        lastrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LASTTX [24:24]
        ///Write '1' to disable interrupt for event LASTTX
        lasttx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused25: u7 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u8 = 0,
        ///SUSPENDED [18:18]
        ///Write '1' to disable interrupt for event SUSPENDED
        suspended: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u2 = 0,
        ///LASTRX [23:23]
        ///Write '1' to disable interrupt for event LASTRX
        lastrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///LASTTX [24:24]
        ///Write '1' to disable interrupt for event LASTTX
        lasttx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused25: u7 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40004000 + 0x308);

    //////////////////////////
    ///ERRORSRC
    const errorsrc_val = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: packed enum(u1) {
            ///Error did not occur
            not_received = 0,
            ///Error occurred
            received = 1,
        } = .not_received,
        ///ANACK [1:1]
        ///NACK received after sending the address (write '1' to clear)
        anack: packed enum(u1) {
            ///Error did not occur
            not_received = 0,
            ///Error occurred
            received = 1,
        } = .not_received,
        ///DNACK [2:2]
        ///NACK received after sending a data byte (write '1' to clear)
        dnack: packed enum(u1) {
            ///Error did not occur
            not_received = 0,
            ///Error occurred
            received = 1,
        } = .not_received,
        _unused3: u29 = 0,
    };
    ///Error source
    pub const errorsrc = Register(errorsrc_val).init(0x40004000 + 0x4C4);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable TWIM
        enable: packed enum(u4) {
            ///Disable TWIM
            disabled = 0,
            ///Enable TWIM
            enabled = 6,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable TWIM
    pub const enable = Register(enable_val).init(0x40004000 + 0x500);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///TWI master clock frequency
        frequency: packed enum(u32) {
            ///100 kbps
            k100 = 0x01980000,
            ///250 kbps
            k250 = 0x04000000,
            ///400 kbps
            k400 = 0x06400000,
            _zero = 0,
        } = ._zero,
    };
    ///TWI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x40004000 + 0x524);

    //////////////////////////
    ///ADDRESS
    const address_val = packed struct {
        ///ADDRESS [0:6]
        ///Address used in the TWI transfer
        address: u7 = 0,
        _unused7: u25 = 0,
    };
    ///Address used in the TWI transfer
    pub const address = Register(address_val).init(0x40004000 + 0x588);
};

///I2C compatible Two-Wire Slave Interface with EasyDMA 1
pub const twis1 = struct {

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop TWI transaction
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop TWI transaction
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40004000 + 0x014);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend TWI transaction
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend TWI transaction
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x40004000 + 0x01C);

    //////////////////////////
    ///TASKS_RESUME
    const tasks_resume_val = packed struct {
        ///TASKS_RESUME [0:0]
        ///Resume TWI transaction
        tasks_resume: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Resume TWI transaction
    pub const tasks_resume = RegisterRW(void, tasks_resume_val).init(0x40004000 + 0x020);

    //////////////////////////
    ///TASKS_PREPARERX
    const tasks_preparerx_val = packed struct {
        ///TASKS_PREPARERX [0:0]
        ///Prepare the TWI slave to respond to a write command
        tasks_preparerx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Prepare the TWI slave to respond to a write command
    pub const tasks_preparerx = RegisterRW(void, tasks_preparerx_val).init(0x40004000 + 0x030);

    //////////////////////////
    ///TASKS_PREPARETX
    const tasks_preparetx_val = packed struct {
        ///TASKS_PREPARETX [0:0]
        ///Prepare the TWI slave to respond to a read command
        tasks_preparetx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Prepare the TWI slave to respond to a read command
    pub const tasks_preparetx = RegisterRW(void, tasks_preparetx_val).init(0x40004000 + 0x034);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///TWI stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40004000 + 0x104);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///TWI error
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TWI error
    pub const events_error = Register(events_error_val).init(0x40004000 + 0x124);

    //////////////////////////
    ///EVENTS_RXSTARTED
    const events_rxstarted_val = packed struct {
        ///EVENTS_RXSTARTED [0:0]
        ///Receive sequence started
        events_rxstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Receive sequence started
    pub const events_rxstarted = Register(events_rxstarted_val).init(0x40004000 + 0x14C);

    //////////////////////////
    ///EVENTS_TXSTARTED
    const events_txstarted_val = packed struct {
        ///EVENTS_TXSTARTED [0:0]
        ///Transmit sequence started
        events_txstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transmit sequence started
    pub const events_txstarted = Register(events_txstarted_val).init(0x40004000 + 0x150);

    //////////////////////////
    ///EVENTS_WRITE
    const events_write_val = packed struct {
        ///EVENTS_WRITE [0:0]
        ///Write command received
        events_write: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Write command received
    pub const events_write = Register(events_write_val).init(0x40004000 + 0x164);

    //////////////////////////
    ///EVENTS_READ
    const events_read_val = packed struct {
        ///EVENTS_READ [0:0]
        ///Read command received
        events_read: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Read command received
    pub const events_read = Register(events_read_val).init(0x40004000 + 0x168);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u13 = 0,
        ///WRITE_SUSPEND [13:13]
        ///Shortcut between event WRITE and task SUSPEND
        write_suspend: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///READ_SUSPEND [14:14]
        ///Shortcut between event READ and task SUSPEND
        read_suspend: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused15: u17 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40004000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Enable or disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused10: u9 = 0,
        ///RXSTARTED [19:19]
        ///Enable or disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Enable or disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused21: u4 = 0,
        ///WRITE [25:25]
        ///Enable or disable interrupt for event WRITE
        write: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///READ [26:26]
        ///Enable or disable interrupt for event READ
        read: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused27: u5 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40004000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u9 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u4 = 0,
        ///WRITE [25:25]
        ///Write '1' to enable interrupt for event WRITE
        write: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///READ [26:26]
        ///Write '1' to enable interrupt for event READ
        read: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused27: u5 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u9 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u4 = 0,
        ///WRITE [25:25]
        ///Write '1' to enable interrupt for event WRITE
        write: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///READ [26:26]
        ///Write '1' to enable interrupt for event READ
        read: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused27: u5 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40004000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u9 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u4 = 0,
        ///WRITE [25:25]
        ///Write '1' to disable interrupt for event WRITE
        write: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///READ [26:26]
        ///Write '1' to disable interrupt for event READ
        read: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused27: u5 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u7 = 0,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u9 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u4 = 0,
        ///WRITE [25:25]
        ///Write '1' to disable interrupt for event WRITE
        write: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///READ [26:26]
        ///Write '1' to disable interrupt for event READ
        read: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused27: u5 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40004000 + 0x308);

    //////////////////////////
    ///ERRORSRC
    const errorsrc_val = packed struct {
        ///OVERFLOW [0:0]
        ///RX buffer overflow detected, and prevented
        overflow: packed enum(u1) {
            ///Error did not occur
            not_detected = 0,
            ///Error occurred
            detected = 1,
        } = .not_detected,
        _unused1: u1 = 0,
        ///DNACK [2:2]
        ///NACK sent after receiving a data byte
        dnack: packed enum(u1) {
            ///Error did not occur
            not_received = 0,
            ///Error occurred
            received = 1,
        } = .not_received,
        ///OVERREAD [3:3]
        ///TX buffer over-read detected, and prevented
        overread: packed enum(u1) {
            ///Error did not occur
            not_detected = 0,
            ///Error occurred
            detected = 1,
        } = .not_detected,
        _unused4: u28 = 0,
    };
    ///Error source
    pub const errorsrc = Register(errorsrc_val).init(0x40004000 + 0x4D0);

    //////////////////////////
    ///MATCH
    const match_val = packed struct {
        ///MATCH [0:0]
        ///Which of the addresses in {ADDRESS} matched the incoming address
        match: u1 = 0,
        _unused1: u31 = 0,
    };
    ///Status register indicating which address had a match
    pub const match = RegisterRW(match_val, void).init(0x40004000 + 0x4D4);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable TWIS
        enable: packed enum(u4) {
            ///Disable TWIS
            disabled = 0,
            ///Enable TWIS
            enabled = 9,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable TWIS
    pub const enable = Register(enable_val).init(0x40004000 + 0x500);

    //////////////////////////
    ///ADDRESS[%s]
    const address_val = packed struct {
        ///ADDRESS [0:6]
        ///TWI slave address
        address: u7 = 0,
        _unused7: u25 = 0,
    };
    ///Description collection: TWI slave address n
    pub const address = Register(address_val).initRange(0x40004000 + 0x588, 4, 2);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ADDRESS0 [0:0]
        ///Enable or disable address matching on ADDRESS[0]
        address0: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .enabled,
        ///ADDRESS1 [1:1]
        ///Enable or disable address matching on ADDRESS[1]
        address1: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u30 = 0,
    };
    ///Configuration register for the address match mechanism
    pub const config = Register(config_val).init(0x40004000 + 0x594);

    //////////////////////////
    ///ORC
    const orc_val = packed struct {
        ///ORC [0:7]
        ///Over-read character. Character sent out in case of an over-read of the transmit buffer.
        orc: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Over-read character. Character sent out in case of an over-read of the transmit buffer.
    pub const orc = Register(orc_val).init(0x40004000 + 0x5C0);
};

///NFC-A compatible radio
pub const nfct = struct {

    //////////////////////////
    ///TASKS_ACTIVATE
    const tasks_activate_val = packed struct {
        ///TASKS_ACTIVATE [0:0]
        ///Activate NFCT peripheral for incoming and outgoing frames, change state to activated
        tasks_activate: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Activate NFCT peripheral for incoming and outgoing frames, change state to activated
    pub const tasks_activate = RegisterRW(void, tasks_activate_val).init(0x40005000 + 0x000);

    //////////////////////////
    ///TASKS_DISABLE
    const tasks_disable_val = packed struct {
        ///TASKS_DISABLE [0:0]
        ///Disable NFCT peripheral
        tasks_disable: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Disable NFCT peripheral
    pub const tasks_disable = RegisterRW(void, tasks_disable_val).init(0x40005000 + 0x004);

    //////////////////////////
    ///TASKS_SENSE
    const tasks_sense_val = packed struct {
        ///TASKS_SENSE [0:0]
        ///Enable NFC sense field mode, change state to sense mode
        tasks_sense: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Enable NFC sense field mode, change state to sense mode
    pub const tasks_sense = RegisterRW(void, tasks_sense_val).init(0x40005000 + 0x008);

    //////////////////////////
    ///TASKS_STARTTX
    const tasks_starttx_val = packed struct {
        ///TASKS_STARTTX [0:0]
        ///Start transmission of an outgoing frame, change state to transmit
        tasks_starttx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start transmission of an outgoing frame, change state to transmit
    pub const tasks_starttx = RegisterRW(void, tasks_starttx_val).init(0x40005000 + 0x00C);

    //////////////////////////
    ///TASKS_ENABLERXDATA
    const tasks_enablerxdata_val = packed struct {
        ///TASKS_ENABLERXDATA [0:0]
        ///Initializes the EasyDMA for receive.
        tasks_enablerxdata: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Initializes the EasyDMA for receive.
    pub const tasks_enablerxdata = RegisterRW(void, tasks_enablerxdata_val).init(0x40005000 + 0x01C);

    //////////////////////////
    ///TASKS_GOIDLE
    const tasks_goidle_val = packed struct {
        ///TASKS_GOIDLE [0:0]
        ///Force state machine to IDLE state
        tasks_goidle: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Force state machine to IDLE state
    pub const tasks_goidle = RegisterRW(void, tasks_goidle_val).init(0x40005000 + 0x024);

    //////////////////////////
    ///TASKS_GOSLEEP
    const tasks_gosleep_val = packed struct {
        ///TASKS_GOSLEEP [0:0]
        ///Force state machine to SLEEP_A state
        tasks_gosleep: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Force state machine to SLEEP_A state
    pub const tasks_gosleep = RegisterRW(void, tasks_gosleep_val).init(0x40005000 + 0x028);

    //////////////////////////
    ///EVENTS_READY
    const events_ready_val = packed struct {
        ///EVENTS_READY [0:0]
        ///The NFCT peripheral is ready to receive and send frames
        events_ready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The NFCT peripheral is ready to receive and send frames
    pub const events_ready = Register(events_ready_val).init(0x40005000 + 0x100);

    //////////////////////////
    ///EVENTS_FIELDDETECTED
    const events_fielddetected_val = packed struct {
        ///EVENTS_FIELDDETECTED [0:0]
        ///Remote NFC field detected
        events_fielddetected: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Remote NFC field detected
    pub const events_fielddetected = Register(events_fielddetected_val).init(0x40005000 + 0x104);

    //////////////////////////
    ///EVENTS_FIELDLOST
    const events_fieldlost_val = packed struct {
        ///EVENTS_FIELDLOST [0:0]
        ///Remote NFC field lost
        events_fieldlost: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Remote NFC field lost
    pub const events_fieldlost = Register(events_fieldlost_val).init(0x40005000 + 0x108);

    //////////////////////////
    ///EVENTS_TXFRAMESTART
    const events_txframestart_val = packed struct {
        ///EVENTS_TXFRAMESTART [0:0]
        ///Marks the start of the first symbol of a transmitted frame
        events_txframestart: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Marks the start of the first symbol of a transmitted frame
    pub const events_txframestart = Register(events_txframestart_val).init(0x40005000 + 0x10C);

    //////////////////////////
    ///EVENTS_TXFRAMEEND
    const events_txframeend_val = packed struct {
        ///EVENTS_TXFRAMEEND [0:0]
        ///Marks the end of the last transmitted on-air symbol of a frame
        events_txframeend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Marks the end of the last transmitted on-air symbol of a frame
    pub const events_txframeend = Register(events_txframeend_val).init(0x40005000 + 0x110);

    //////////////////////////
    ///EVENTS_RXFRAMESTART
    const events_rxframestart_val = packed struct {
        ///EVENTS_RXFRAMESTART [0:0]
        ///Marks the end of the first symbol of a received frame
        events_rxframestart: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Marks the end of the first symbol of a received frame
    pub const events_rxframestart = Register(events_rxframestart_val).init(0x40005000 + 0x114);

    //////////////////////////
    ///EVENTS_RXFRAMEEND
    const events_rxframeend_val = packed struct {
        ///EVENTS_RXFRAMEEND [0:0]
        ///Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer
        events_rxframeend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer
    pub const events_rxframeend = Register(events_rxframeend_val).init(0x40005000 + 0x118);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///NFC error reported. The ERRORSTATUS register contains details on the source of the error.
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///NFC error reported. The ERRORSTATUS register contains details on the source of the error.
    pub const events_error = Register(events_error_val).init(0x40005000 + 0x11C);

    //////////////////////////
    ///EVENTS_RXERROR
    const events_rxerror_val = packed struct {
        ///EVENTS_RXERROR [0:0]
        ///NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error.
        events_rxerror: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error.
    pub const events_rxerror = Register(events_rxerror_val).init(0x40005000 + 0x128);

    //////////////////////////
    ///EVENTS_ENDRX
    const events_endrx_val = packed struct {
        ///EVENTS_ENDRX [0:0]
        ///RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
        events_endrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full.
    pub const events_endrx = Register(events_endrx_val).init(0x40005000 + 0x12C);

    //////////////////////////
    ///EVENTS_ENDTX
    const events_endtx_val = packed struct {
        ///EVENTS_ENDTX [0:0]
        ///Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer
        events_endtx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer
    pub const events_endtx = Register(events_endtx_val).init(0x40005000 + 0x130);

    //////////////////////////
    ///EVENTS_AUTOCOLRESSTARTED
    const events_autocolresstarted_val = packed struct {
        ///EVENTS_AUTOCOLRESSTARTED [0:0]
        ///Auto collision resolution process has started
        events_autocolresstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Auto collision resolution process has started
    pub const events_autocolresstarted = Register(events_autocolresstarted_val).init(0x40005000 + 0x138);

    //////////////////////////
    ///EVENTS_COLLISION
    const events_collision_val = packed struct {
        ///EVENTS_COLLISION [0:0]
        ///NFC auto collision resolution error reported.
        events_collision: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///NFC auto collision resolution error reported.
    pub const events_collision = Register(events_collision_val).init(0x40005000 + 0x148);

    //////////////////////////
    ///EVENTS_SELECTED
    const events_selected_val = packed struct {
        ///EVENTS_SELECTED [0:0]
        ///NFC auto collision resolution successfully completed
        events_selected: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///NFC auto collision resolution successfully completed
    pub const events_selected = Register(events_selected_val).init(0x40005000 + 0x14C);

    //////////////////////////
    ///EVENTS_STARTED
    const events_started_val = packed struct {
        ///EVENTS_STARTED [0:0]
        ///EasyDMA is ready to receive or send frames.
        events_started: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///EasyDMA is ready to receive or send frames.
    pub const events_started = Register(events_started_val).init(0x40005000 + 0x150);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///FIELDDETECTED_ACTIVATE [0:0]
        ///Shortcut between event FIELDDETECTED and task ACTIVATE
        fielddetected_activate: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///FIELDLOST_SENSE [1:1]
        ///Shortcut between event FIELDLOST and task SENSE
        fieldlost_sense: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused2: u3 = 0,
        ///TXFRAMEEND_ENABLERXDATA [5:5]
        ///Shortcut between event TXFRAMEEND and task ENABLERXDATA
        txframeend_enablerxdata: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused6: u26 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40005000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///READY [0:0]
        ///Enable or disable interrupt for event READY
        ready: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///FIELDDETECTED [1:1]
        ///Enable or disable interrupt for event FIELDDETECTED
        fielddetected: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///FIELDLOST [2:2]
        ///Enable or disable interrupt for event FIELDLOST
        fieldlost: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TXFRAMESTART [3:3]
        ///Enable or disable interrupt for event TXFRAMESTART
        txframestart: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TXFRAMEEND [4:4]
        ///Enable or disable interrupt for event TXFRAMEEND
        txframeend: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///RXFRAMESTART [5:5]
        ///Enable or disable interrupt for event RXFRAMESTART
        rxframestart: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///RXFRAMEEND [6:6]
        ///Enable or disable interrupt for event RXFRAMEEND
        rxframeend: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ERROR [7:7]
        ///Enable or disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused8: u2 = 0,
        ///RXERROR [10:10]
        ///Enable or disable interrupt for event RXERROR
        rxerror: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDRX [11:11]
        ///Enable or disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDTX [12:12]
        ///Enable or disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused13: u1 = 0,
        ///AUTOCOLRESSTARTED [14:14]
        ///Enable or disable interrupt for event AUTOCOLRESSTARTED
        autocolresstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused15: u3 = 0,
        ///COLLISION [18:18]
        ///Enable or disable interrupt for event COLLISION
        collision: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SELECTED [19:19]
        ///Enable or disable interrupt for event SELECTED
        selected: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///STARTED [20:20]
        ///Enable or disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused21: u11 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40005000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///READY [0:0]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///FIELDDETECTED [1:1]
        ///Write '1' to enable interrupt for event FIELDDETECTED
        fielddetected: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///FIELDLOST [2:2]
        ///Write '1' to enable interrupt for event FIELDLOST
        fieldlost: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXFRAMESTART [3:3]
        ///Write '1' to enable interrupt for event TXFRAMESTART
        txframestart: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXFRAMEEND [4:4]
        ///Write '1' to enable interrupt for event TXFRAMEEND
        txframeend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXFRAMESTART [5:5]
        ///Write '1' to enable interrupt for event RXFRAMESTART
        rxframestart: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXFRAMEEND [6:6]
        ///Write '1' to enable interrupt for event RXFRAMEEND
        rxframeend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ERROR [7:7]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u2 = 0,
        ///RXERROR [10:10]
        ///Write '1' to enable interrupt for event RXERROR
        rxerror: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDRX [11:11]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDTX [12:12]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused13: u1 = 0,
        ///AUTOCOLRESSTARTED [14:14]
        ///Write '1' to enable interrupt for event AUTOCOLRESSTARTED
        autocolresstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused15: u3 = 0,
        ///COLLISION [18:18]
        ///Write '1' to enable interrupt for event COLLISION
        collision: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SELECTED [19:19]
        ///Write '1' to enable interrupt for event SELECTED
        selected: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STARTED [20:20]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u11 = 0,
    };
    const intenset_val_write = packed struct {
        ///READY [0:0]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///FIELDDETECTED [1:1]
        ///Write '1' to enable interrupt for event FIELDDETECTED
        fielddetected: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///FIELDLOST [2:2]
        ///Write '1' to enable interrupt for event FIELDLOST
        fieldlost: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TXFRAMESTART [3:3]
        ///Write '1' to enable interrupt for event TXFRAMESTART
        txframestart: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TXFRAMEEND [4:4]
        ///Write '1' to enable interrupt for event TXFRAMEEND
        txframeend: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RXFRAMESTART [5:5]
        ///Write '1' to enable interrupt for event RXFRAMESTART
        rxframestart: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RXFRAMEEND [6:6]
        ///Write '1' to enable interrupt for event RXFRAMEEND
        rxframeend: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ERROR [7:7]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u2 = 0,
        ///RXERROR [10:10]
        ///Write '1' to enable interrupt for event RXERROR
        rxerror: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDRX [11:11]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDTX [12:12]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused13: u1 = 0,
        ///AUTOCOLRESSTARTED [14:14]
        ///Write '1' to enable interrupt for event AUTOCOLRESSTARTED
        autocolresstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused15: u3 = 0,
        ///COLLISION [18:18]
        ///Write '1' to enable interrupt for event COLLISION
        collision: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SELECTED [19:19]
        ///Write '1' to enable interrupt for event SELECTED
        selected: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///STARTED [20:20]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u11 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40005000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///READY [0:0]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///FIELDDETECTED [1:1]
        ///Write '1' to disable interrupt for event FIELDDETECTED
        fielddetected: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///FIELDLOST [2:2]
        ///Write '1' to disable interrupt for event FIELDLOST
        fieldlost: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXFRAMESTART [3:3]
        ///Write '1' to disable interrupt for event TXFRAMESTART
        txframestart: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXFRAMEEND [4:4]
        ///Write '1' to disable interrupt for event TXFRAMEEND
        txframeend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXFRAMESTART [5:5]
        ///Write '1' to disable interrupt for event RXFRAMESTART
        rxframestart: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXFRAMEEND [6:6]
        ///Write '1' to disable interrupt for event RXFRAMEEND
        rxframeend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ERROR [7:7]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u2 = 0,
        ///RXERROR [10:10]
        ///Write '1' to disable interrupt for event RXERROR
        rxerror: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDRX [11:11]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDTX [12:12]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused13: u1 = 0,
        ///AUTOCOLRESSTARTED [14:14]
        ///Write '1' to disable interrupt for event AUTOCOLRESSTARTED
        autocolresstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused15: u3 = 0,
        ///COLLISION [18:18]
        ///Write '1' to disable interrupt for event COLLISION
        collision: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SELECTED [19:19]
        ///Write '1' to disable interrupt for event SELECTED
        selected: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STARTED [20:20]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u11 = 0,
    };
    const intenclr_val_write = packed struct {
        ///READY [0:0]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///FIELDDETECTED [1:1]
        ///Write '1' to disable interrupt for event FIELDDETECTED
        fielddetected: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///FIELDLOST [2:2]
        ///Write '1' to disable interrupt for event FIELDLOST
        fieldlost: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TXFRAMESTART [3:3]
        ///Write '1' to disable interrupt for event TXFRAMESTART
        txframestart: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TXFRAMEEND [4:4]
        ///Write '1' to disable interrupt for event TXFRAMEEND
        txframeend: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RXFRAMESTART [5:5]
        ///Write '1' to disable interrupt for event RXFRAMESTART
        rxframestart: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RXFRAMEEND [6:6]
        ///Write '1' to disable interrupt for event RXFRAMEEND
        rxframeend: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ERROR [7:7]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u2 = 0,
        ///RXERROR [10:10]
        ///Write '1' to disable interrupt for event RXERROR
        rxerror: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDRX [11:11]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDTX [12:12]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused13: u1 = 0,
        ///AUTOCOLRESSTARTED [14:14]
        ///Write '1' to disable interrupt for event AUTOCOLRESSTARTED
        autocolresstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused15: u3 = 0,
        ///COLLISION [18:18]
        ///Write '1' to disable interrupt for event COLLISION
        collision: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SELECTED [19:19]
        ///Write '1' to disable interrupt for event SELECTED
        selected: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///STARTED [20:20]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u11 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40005000 + 0x308);

    //////////////////////////
    ///ERRORSTATUS
    const errorstatus_val = packed struct {
        ///FRAMEDELAYTIMEOUT [0:0]
        ///No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX
        framedelaytimeout: u1 = 0,
        _unused1: u31 = 0,
    };
    ///NFC Error Status register
    pub const errorstatus = Register(errorstatus_val).init(0x40005000 + 0x404);

    //////////////////////////
    ///NFCTAGSTATE
    const nfctagstate_val = packed struct {
        ///NFCTAGSTATE [0:2]
        ///NfcTag state
        nfctagstate: packed enum(u3) {
            ///Disabled or sense
            disabled = 0,
            ///RampUp
            ramp_up = 2,
            ///Idle
            idle = 3,
            ///Receive
            receive = 4,
            ///FrameDelay
            frame_delay = 5,
            ///Transmit
            transmit = 6,
        } = .disabled,
        _unused3: u29 = 0,
    };
    ///NfcTag state register
    pub const nfctagstate = RegisterRW(nfctagstate_val, void).init(0x40005000 + 0x410);

    //////////////////////////
    ///SLEEPSTATE
    const sleepstate_val = packed struct {
        ///SLEEPSTATE [0:0]
        ///Reflects the sleep state during automatic collision resolution. Set to IDLE 
        ///by a GOIDLE task. Set to SLEEP_A when a valid SLEEP_REQ frame is received or by a 
        ///GOSLEEP task.
        sleepstate: packed enum(u1) {
            ///State is IDLE.
            idle = 0,
            ///State is SLEEP_A.
            sleep_a = 1,
        } = .idle,
        _unused1: u31 = 0,
    };
    ///Sleep state during automatic collision resolution
    pub const sleepstate = RegisterRW(sleepstate_val, void).init(0x40005000 + 0x420);

    //////////////////////////
    ///FIELDPRESENT
    const fieldpresent_val = packed struct {
        ///FIELDPRESENT [0:0]
        ///Indicates if a valid field is present. Available only in the activated state.
        fieldpresent: packed enum(u1) {
            ///No valid field detected
            no_field = 0,
            ///Valid field detected
            field_present = 1,
        } = .no_field,
        ///LOCKDETECT [1:1]
        ///Indicates if the low level has locked to the field
        lockdetect: packed enum(u1) {
            ///Not locked to field
            not_locked = 0,
            ///Locked to field
            locked = 1,
        } = .not_locked,
        _unused2: u30 = 0,
    };
    ///Indicates the presence or not of a valid field
    pub const fieldpresent = RegisterRW(fieldpresent_val, void).init(0x40005000 + 0x43C);

    //////////////////////////
    ///FRAMEDELAYMIN
    const framedelaymin_val = packed struct {
        ///FRAMEDELAYMIN [0:15]
        ///Minimum frame delay in number of 13.56 MHz clocks
        framedelaymin: u16 = 1152,
        _unused16: u16 = 0,
    };
    ///Minimum frame delay
    pub const framedelaymin = Register(framedelaymin_val).init(0x40005000 + 0x504);

    //////////////////////////
    ///FRAMEDELAYMAX
    const framedelaymax_val = packed struct {
        ///FRAMEDELAYMAX [0:19]
        ///Maximum frame delay in number of 13.56 MHz clocks
        framedelaymax: u20 = 4096,
        _unused20: u12 = 0,
    };
    ///Maximum frame delay
    pub const framedelaymax = Register(framedelaymax_val).init(0x40005000 + 0x508);

    //////////////////////////
    ///FRAMEDELAYMODE
    const framedelaymode_val = packed struct {
        ///FRAMEDELAYMODE [0:1]
        ///Configuration register for the Frame Delay Timer
        framedelaymode: packed enum(u2) {
            ///Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout.
            free_run = 0,
            ///Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX
            window = 1,
            ///Frame is transmitted exactly at FRAMEDELAYMAX
            exact_val = 2,
            ///Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX
            window_grid = 3,
        } = .window,
        _unused2: u30 = 0,
    };
    ///Configuration register for the Frame Delay Timer
    pub const framedelaymode = Register(framedelaymode_val).init(0x40005000 + 0x50C);

    //////////////////////////
    ///PACKETPTR
    const packetptr_val = packed struct {
        ///PTR [0:31]
        ///Packet pointer for TXD and RXD data storage in Data RAM. This address is a byte-aligned RAM address.
        ptr: u32 = 0,
    };
    ///Packet pointer for TXD and RXD data storage in Data RAM
    pub const packetptr = Register(packetptr_val).init(0x40005000 + 0x510);

    //////////////////////////
    ///MAXLEN
    const maxlen_val = packed struct {
        ///MAXLEN [0:8]
        ///Size of the RAM buffer allocated to TXD and RXD data storage each
        maxlen: u9 = 0,
        _unused9: u23 = 0,
    };
    ///Size of the RAM buffer allocated to TXD and RXD data storage each
    pub const maxlen = Register(maxlen_val).init(0x40005000 + 0x514);

    //////////////////////////
    ///MODULATIONCTRL
    const modulationctrl_val = packed struct {
        ///MODULATIONCTRL [0:1]
        ///Configuration of modulation control.
        modulationctrl: packed enum(u2) {
            ///Invalid, defaults to same behaviour as for Internal
            invalid = 0x0,
            ///Use internal modulator only
            internal = 0x1,
            ///Output digital modulation signal to a GPIO pin.
            mod_to_gpio = 0x2,
            ///Use internal modulator and output digital modulation signal to a GPIO pin.
            internal_and_mod_to_gpio = 0x3,
            _zero = 0,
        } = ._zero,
        _unused2: u30 = 0,
    };
    ///Enables the modulation output to a GPIO pin which can be connected to a second external antenna.
    pub const modulationctrl = Register(modulationctrl_val).init(0x40005000 + 0x52C);

    //////////////////////////
    ///MODULATIONPSEL
    const modulationpsel_val = packed struct {
        ///PIN [0:4]
        ///Pin number
        pin: u5 = 31,
        ///PORT [5:5]
        ///Port number
        port: u1 = 1,
        _unused6: u25 = 0,
        ///CONNECT [31:31]
        ///Connection
        connect: packed enum(u1) {
            ///Disconnect
            disconnected = 1,
            ///Connect
            connected = 0,
        } = .disconnected,
    };
    ///Pin select for Modulation control.
    pub const modulationpsel = Register(modulationpsel_val).init(0x40005000 + 0x538);

    //////////////////////////
    ///NFCID1_LAST
    const nfcid1_last_val = packed struct {
        ///NFCID1_Z [0:7]
        ///NFCID1 byte Z (very last byte sent)
        nfcid1_z: u8 = 99,
        ///NFCID1_Y [8:15]
        ///NFCID1 byte Y
        nfcid1_y: u8 = 99,
        ///NFCID1_X [16:23]
        ///NFCID1 byte X
        nfcid1_x: u8 = 0,
        ///NFCID1_W [24:31]
        ///NFCID1 byte W
        nfcid1_w: u8 = 0,
    };
    ///Last NFCID1 part (4, 7 or 10 bytes ID)
    pub const nfcid1_last = Register(nfcid1_last_val).init(0x40005000 + 0x590);

    //////////////////////////
    ///NFCID1_2ND_LAST
    const nfcid1_2nd_last_val = packed struct {
        ///NFCID1_V [0:7]
        ///NFCID1 byte V
        nfcid1_v: u8 = 0,
        ///NFCID1_U [8:15]
        ///NFCID1 byte U
        nfcid1_u: u8 = 0,
        ///NFCID1_T [16:23]
        ///NFCID1 byte T
        nfcid1_t: u8 = 0,
        _unused24: u8 = 0,
    };
    ///Second last NFCID1 part (7 or 10 bytes ID)
    pub const nfcid1_2nd_last = Register(nfcid1_2nd_last_val).init(0x40005000 + 0x594);

    //////////////////////////
    ///NFCID1_3RD_LAST
    const nfcid1_3rd_last_val = packed struct {
        ///NFCID1_S [0:7]
        ///NFCID1 byte S
        nfcid1_s: u8 = 0,
        ///NFCID1_R [8:15]
        ///NFCID1 byte R
        nfcid1_r: u8 = 0,
        ///NFCID1_Q [16:23]
        ///NFCID1 byte Q
        nfcid1_q: u8 = 0,
        _unused24: u8 = 0,
    };
    ///Third last NFCID1 part (10 bytes ID)
    pub const nfcid1_3rd_last = Register(nfcid1_3rd_last_val).init(0x40005000 + 0x598);

    //////////////////////////
    ///AUTOCOLRESCONFIG
    const autocolresconfig_val = packed struct {
        ///MODE [0:0]
        ///Enables/disables auto collision resolution
        mode: packed enum(u1) {
            ///Auto collision resolution enabled
            enabled = 0,
            ///Auto collision resolution disabled
            disabled = 1,
        } = .enabled,
        _unused1: u31 = 0,
    };
    ///Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated.
    pub const autocolresconfig = Register(autocolresconfig_val).init(0x40005000 + 0x59C);

    //////////////////////////
    ///SENSRES
    const sensres_val = packed struct {
        ///BITFRAMESDD [0:4]
        ///Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification
        bitframesdd: packed enum(u5) {
            ///SDD pattern 00000
            sdd00000 = 0,
            ///SDD pattern 00001
            sdd00001 = 1,
            ///SDD pattern 00010
            sdd00010 = 2,
            ///SDD pattern 00100
            sdd00100 = 4,
            ///SDD pattern 01000
            sdd01000 = 8,
            ///SDD pattern 10000
            sdd10000 = 16,
        } = .sdd00001,
        ///RFU5 [5:5]
        ///Reserved for future use. Shall be 0.
        rfu5: u1 = 0,
        ///NFCIDSIZE [6:7]
        ///NFCID1 size. This value is used by the auto collision resolution engine.
        nfcidsize: packed enum(u2) {
            ///NFCID1 size: single (4 bytes)
            nfcid1single = 0,
            ///NFCID1 size: double (7 bytes)
            nfcid1double = 1,
            ///NFCID1 size: triple (10 bytes)
            nfcid1triple = 2,
        } = .nfcid1single,
        ///PLATFCONFIG [8:11]
        ///Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification
        platfconfig: u4 = 0,
        ///RFU74 [12:15]
        ///Reserved for future use. Shall be 0.
        rfu74: u4 = 0,
        _unused16: u16 = 0,
    };
    ///NFC-A SENS_RES auto-response settings
    pub const sensres = Register(sensres_val).init(0x40005000 + 0x5A0);

    //////////////////////////
    ///SELRES
    const selres_val = packed struct {
        ///RFU10 [0:1]
        ///Reserved for future use. Shall be 0.
        rfu10: u2 = 0,
        ///CASCADE [2:2]
        ///Cascade as defined by the b3 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification (controlled by hardware, shall be 0)
        cascade: u1 = 0,
        ///RFU43 [3:4]
        ///Reserved for future use. Shall be 0.
        rfu43: u2 = 0,
        ///PROTOCOL [5:6]
        ///Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification
        protocol: u2 = 0,
        ///RFU7 [7:7]
        ///Reserved for future use. Shall be 0.
        rfu7: u1 = 0,
        _unused8: u24 = 0,
    };
    ///NFC-A SEL_RES auto-response settings
    pub const selres = Register(selres_val).init(0x40005000 + 0x5A4);
};

///GPIO Tasks and Events
pub const gpiote = struct {

    //////////////////////////
    ///TASKS_OUT[%s]
    const tasks_out_val = packed struct {
        ///TASKS_OUT [0:0]
        ///Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
        tasks_out: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
    pub const tasks_out = RegisterRW(void, tasks_out_val).initRange(0x40006000 + 0x000, 4, 8);

    //////////////////////////
    ///TASKS_SET[%s]
    const tasks_set_val = packed struct {
        ///TASKS_SET [0:0]
        ///Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high.
        tasks_set: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high.
    pub const tasks_set = RegisterRW(void, tasks_set_val).initRange(0x40006000 + 0x030, 4, 8);

    //////////////////////////
    ///TASKS_CLR[%s]
    const tasks_clr_val = packed struct {
        ///TASKS_CLR [0:0]
        ///Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low.
        tasks_clr: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low.
    pub const tasks_clr = RegisterRW(void, tasks_clr_val).initRange(0x40006000 + 0x060, 4, 8);

    //////////////////////////
    ///EVENTS_IN[%s]
    const events_in_val = packed struct {
        ///EVENTS_IN [0:0]
        ///Event generated from pin specified in CONFIG[n].PSEL
        events_in: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Event generated from pin specified in CONFIG[n].PSEL
    pub const events_in = Register(events_in_val).initRange(0x40006000 + 0x100, 4, 8);

    //////////////////////////
    ///EVENTS_PORT
    const events_port_val = packed struct {
        ///EVENTS_PORT [0:0]
        ///Event generated from multiple input GPIO pins with SENSE mechanism enabled
        events_port: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Event generated from multiple input GPIO pins with SENSE mechanism enabled
    pub const events_port = Register(events_port_val).init(0x40006000 + 0x17C);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///IN0 [0:0]
        ///Write '1' to enable interrupt for event IN[0]
        in0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN1 [1:1]
        ///Write '1' to enable interrupt for event IN[1]
        in1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN2 [2:2]
        ///Write '1' to enable interrupt for event IN[2]
        in2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN3 [3:3]
        ///Write '1' to enable interrupt for event IN[3]
        in3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN4 [4:4]
        ///Write '1' to enable interrupt for event IN[4]
        in4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN5 [5:5]
        ///Write '1' to enable interrupt for event IN[5]
        in5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN6 [6:6]
        ///Write '1' to enable interrupt for event IN[6]
        in6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN7 [7:7]
        ///Write '1' to enable interrupt for event IN[7]
        in7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u23 = 0,
        ///PORT [31:31]
        ///Write '1' to enable interrupt for event PORT
        port: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
    };
    const intenset_val_write = packed struct {
        ///IN0 [0:0]
        ///Write '1' to enable interrupt for event IN[0]
        in0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///IN1 [1:1]
        ///Write '1' to enable interrupt for event IN[1]
        in1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///IN2 [2:2]
        ///Write '1' to enable interrupt for event IN[2]
        in2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///IN3 [3:3]
        ///Write '1' to enable interrupt for event IN[3]
        in3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///IN4 [4:4]
        ///Write '1' to enable interrupt for event IN[4]
        in4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///IN5 [5:5]
        ///Write '1' to enable interrupt for event IN[5]
        in5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///IN6 [6:6]
        ///Write '1' to enable interrupt for event IN[6]
        in6: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///IN7 [7:7]
        ///Write '1' to enable interrupt for event IN[7]
        in7: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u23 = 0,
        ///PORT [31:31]
        ///Write '1' to enable interrupt for event PORT
        port: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40006000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///IN0 [0:0]
        ///Write '1' to disable interrupt for event IN[0]
        in0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN1 [1:1]
        ///Write '1' to disable interrupt for event IN[1]
        in1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN2 [2:2]
        ///Write '1' to disable interrupt for event IN[2]
        in2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN3 [3:3]
        ///Write '1' to disable interrupt for event IN[3]
        in3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN4 [4:4]
        ///Write '1' to disable interrupt for event IN[4]
        in4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN5 [5:5]
        ///Write '1' to disable interrupt for event IN[5]
        in5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN6 [6:6]
        ///Write '1' to disable interrupt for event IN[6]
        in6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///IN7 [7:7]
        ///Write '1' to disable interrupt for event IN[7]
        in7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u23 = 0,
        ///PORT [31:31]
        ///Write '1' to disable interrupt for event PORT
        port: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
    };
    const intenclr_val_write = packed struct {
        ///IN0 [0:0]
        ///Write '1' to disable interrupt for event IN[0]
        in0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///IN1 [1:1]
        ///Write '1' to disable interrupt for event IN[1]
        in1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///IN2 [2:2]
        ///Write '1' to disable interrupt for event IN[2]
        in2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///IN3 [3:3]
        ///Write '1' to disable interrupt for event IN[3]
        in3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///IN4 [4:4]
        ///Write '1' to disable interrupt for event IN[4]
        in4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///IN5 [5:5]
        ///Write '1' to disable interrupt for event IN[5]
        in5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///IN6 [6:6]
        ///Write '1' to disable interrupt for event IN[6]
        in6: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///IN7 [7:7]
        ///Write '1' to disable interrupt for event IN[7]
        in7: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u23 = 0,
        ///PORT [31:31]
        ///Write '1' to disable interrupt for event PORT
        port: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40006000 + 0x308);

    //////////////////////////
    ///CONFIG[%s]
    const config_val = packed struct {
        ///MODE [0:1]
        ///Mode
        mode: packed enum(u2) {
            ///Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module.
            disabled = 0,
            ///Event mode
            event = 1,
            ///Task mode
            task = 3,
        } = .disabled,
        _unused2: u6 = 0,
        ///PSEL [8:12]
        ///GPIO number associated with SET[n], CLR[n], and OUT[n] tasks and IN[n] event
        psel: u5 = 0,
        ///PORT [13:13]
        ///Port number
        port: u1 = 0,
        _unused14: u2 = 0,
        ///POLARITY [16:17]
        ///When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event.
        polarity: packed enum(u2) {
            ///Task mode: No effect on pin from OUT[n] task. Event mode: no IN[n] event generated on pin activity.
            none = 0,
            ///Task mode: Set pin from OUT[n] task. Event mode: Generate IN[n] event when rising edge on pin.
            lo_to_hi = 1,
            ///Task mode: Clear pin from OUT[n] task. Event mode: Generate IN[n] event when falling edge on pin.
            hi_to_lo = 2,
            ///Task mode: Toggle pin from OUT[n]. Event mode: Generate IN[n] when any change on pin.
            toggle = 3,
        } = .none,
        _unused18: u2 = 0,
        ///OUTINIT [20:20]
        ///When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect.
        outinit: packed enum(u1) {
            ///Task mode: Initial value of pin before task triggering is low
            low = 0,
            ///Task mode: Initial value of pin before task triggering is high
            high = 1,
        } = .low,
        _unused21: u11 = 0,
    };
    ///Description collection: Configuration for OUT[n], SET[n], and CLR[n] tasks and IN[n] event
    pub const config = Register(config_val).initRange(0x40006000 + 0x510, 4, 8);
};

///Successive approximation register (SAR) analog-to-digital converter
pub const saadc = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Starts the SAADC and prepares the result buffer in RAM
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Starts the SAADC and prepares the result buffer in RAM
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40007000 + 0x000);

    //////////////////////////
    ///TASKS_SAMPLE
    const tasks_sample_val = packed struct {
        ///TASKS_SAMPLE [0:0]
        ///Takes one SAADC sample
        tasks_sample: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Takes one SAADC sample
    pub const tasks_sample = RegisterRW(void, tasks_sample_val).init(0x40007000 + 0x004);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stops the SAADC and terminates all on-going conversions
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stops the SAADC and terminates all on-going conversions
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40007000 + 0x008);

    //////////////////////////
    ///TASKS_CALIBRATEOFFSET
    const tasks_calibrateoffset_val = packed struct {
        ///TASKS_CALIBRATEOFFSET [0:0]
        ///Starts offset auto-calibration
        tasks_calibrateoffset: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Starts offset auto-calibration
    pub const tasks_calibrateoffset = RegisterRW(void, tasks_calibrateoffset_val).init(0x40007000 + 0x00C);

    //////////////////////////
    ///EVENTS_STARTED
    const events_started_val = packed struct {
        ///EVENTS_STARTED [0:0]
        ///The SAADC has started
        events_started: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The SAADC has started
    pub const events_started = Register(events_started_val).init(0x40007000 + 0x100);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///The SAADC has filled up the result buffer
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The SAADC has filled up the result buffer
    pub const events_end = Register(events_end_val).init(0x40007000 + 0x104);

    //////////////////////////
    ///EVENTS_DONE
    const events_done_val = packed struct {
        ///EVENTS_DONE [0:0]
        ///A conversion task has been completed. Depending on the configuration, multiple conversions might be needed for a result to be transferred to RAM.
        events_done: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///A conversion task has been completed. Depending on the configuration, multiple conversions might be needed for a result to be transferred to RAM.
    pub const events_done = Register(events_done_val).init(0x40007000 + 0x108);

    //////////////////////////
    ///EVENTS_RESULTDONE
    const events_resultdone_val = packed struct {
        ///EVENTS_RESULTDONE [0:0]
        ///Result ready for transfer to RAM
        events_resultdone: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Result ready for transfer to RAM
    pub const events_resultdone = Register(events_resultdone_val).init(0x40007000 + 0x10C);

    //////////////////////////
    ///EVENTS_CALIBRATEDONE
    const events_calibratedone_val = packed struct {
        ///EVENTS_CALIBRATEDONE [0:0]
        ///Calibration is complete
        events_calibratedone: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Calibration is complete
    pub const events_calibratedone = Register(events_calibratedone_val).init(0x40007000 + 0x110);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///The SAADC has stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The SAADC has stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40007000 + 0x114);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///STARTED [0:0]
        ///Enable or disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///END [1:1]
        ///Enable or disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///DONE [2:2]
        ///Enable or disable interrupt for event DONE
        done: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///RESULTDONE [3:3]
        ///Enable or disable interrupt for event RESULTDONE
        resultdone: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CALIBRATEDONE [4:4]
        ///Enable or disable interrupt for event CALIBRATEDONE
        calibratedone: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///STOPPED [5:5]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH0LIMITH [6:6]
        ///Enable or disable interrupt for event CH0LIMITH
        ch0limith: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH0LIMITL [7:7]
        ///Enable or disable interrupt for event CH0LIMITL
        ch0limitl: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH1LIMITH [8:8]
        ///Enable or disable interrupt for event CH1LIMITH
        ch1limith: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH1LIMITL [9:9]
        ///Enable or disable interrupt for event CH1LIMITL
        ch1limitl: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH2LIMITH [10:10]
        ///Enable or disable interrupt for event CH2LIMITH
        ch2limith: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH2LIMITL [11:11]
        ///Enable or disable interrupt for event CH2LIMITL
        ch2limitl: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH3LIMITH [12:12]
        ///Enable or disable interrupt for event CH3LIMITH
        ch3limith: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH3LIMITL [13:13]
        ///Enable or disable interrupt for event CH3LIMITL
        ch3limitl: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH4LIMITH [14:14]
        ///Enable or disable interrupt for event CH4LIMITH
        ch4limith: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH4LIMITL [15:15]
        ///Enable or disable interrupt for event CH4LIMITL
        ch4limitl: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH5LIMITH [16:16]
        ///Enable or disable interrupt for event CH5LIMITH
        ch5limith: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH5LIMITL [17:17]
        ///Enable or disable interrupt for event CH5LIMITL
        ch5limitl: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH6LIMITH [18:18]
        ///Enable or disable interrupt for event CH6LIMITH
        ch6limith: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH6LIMITL [19:19]
        ///Enable or disable interrupt for event CH6LIMITL
        ch6limitl: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH7LIMITH [20:20]
        ///Enable or disable interrupt for event CH7LIMITH
        ch7limith: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CH7LIMITL [21:21]
        ///Enable or disable interrupt for event CH7LIMITL
        ch7limitl: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40007000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///STARTED [0:0]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///END [1:1]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DONE [2:2]
        ///Write '1' to enable interrupt for event DONE
        done: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RESULTDONE [3:3]
        ///Write '1' to enable interrupt for event RESULTDONE
        resultdone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CALIBRATEDONE [4:4]
        ///Write '1' to enable interrupt for event CALIBRATEDONE
        calibratedone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STOPPED [5:5]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH0LIMITH [6:6]
        ///Write '1' to enable interrupt for event CH0LIMITH
        ch0limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH0LIMITL [7:7]
        ///Write '1' to enable interrupt for event CH0LIMITL
        ch0limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH1LIMITH [8:8]
        ///Write '1' to enable interrupt for event CH1LIMITH
        ch1limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH1LIMITL [9:9]
        ///Write '1' to enable interrupt for event CH1LIMITL
        ch1limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH2LIMITH [10:10]
        ///Write '1' to enable interrupt for event CH2LIMITH
        ch2limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH2LIMITL [11:11]
        ///Write '1' to enable interrupt for event CH2LIMITL
        ch2limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH3LIMITH [12:12]
        ///Write '1' to enable interrupt for event CH3LIMITH
        ch3limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH3LIMITL [13:13]
        ///Write '1' to enable interrupt for event CH3LIMITL
        ch3limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH4LIMITH [14:14]
        ///Write '1' to enable interrupt for event CH4LIMITH
        ch4limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH4LIMITL [15:15]
        ///Write '1' to enable interrupt for event CH4LIMITL
        ch4limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH5LIMITH [16:16]
        ///Write '1' to enable interrupt for event CH5LIMITH
        ch5limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH5LIMITL [17:17]
        ///Write '1' to enable interrupt for event CH5LIMITL
        ch5limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH6LIMITH [18:18]
        ///Write '1' to enable interrupt for event CH6LIMITH
        ch6limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH6LIMITL [19:19]
        ///Write '1' to enable interrupt for event CH6LIMITL
        ch6limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH7LIMITH [20:20]
        ///Write '1' to enable interrupt for event CH7LIMITH
        ch7limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH7LIMITL [21:21]
        ///Write '1' to enable interrupt for event CH7LIMITL
        ch7limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenset_val_write = packed struct {
        ///STARTED [0:0]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///END [1:1]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///DONE [2:2]
        ///Write '1' to enable interrupt for event DONE
        done: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RESULTDONE [3:3]
        ///Write '1' to enable interrupt for event RESULTDONE
        resultdone: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CALIBRATEDONE [4:4]
        ///Write '1' to enable interrupt for event CALIBRATEDONE
        calibratedone: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///STOPPED [5:5]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH0LIMITH [6:6]
        ///Write '1' to enable interrupt for event CH0LIMITH
        ch0limith: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH0LIMITL [7:7]
        ///Write '1' to enable interrupt for event CH0LIMITL
        ch0limitl: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH1LIMITH [8:8]
        ///Write '1' to enable interrupt for event CH1LIMITH
        ch1limith: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH1LIMITL [9:9]
        ///Write '1' to enable interrupt for event CH1LIMITL
        ch1limitl: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH2LIMITH [10:10]
        ///Write '1' to enable interrupt for event CH2LIMITH
        ch2limith: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH2LIMITL [11:11]
        ///Write '1' to enable interrupt for event CH2LIMITL
        ch2limitl: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH3LIMITH [12:12]
        ///Write '1' to enable interrupt for event CH3LIMITH
        ch3limith: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH3LIMITL [13:13]
        ///Write '1' to enable interrupt for event CH3LIMITL
        ch3limitl: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH4LIMITH [14:14]
        ///Write '1' to enable interrupt for event CH4LIMITH
        ch4limith: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH4LIMITL [15:15]
        ///Write '1' to enable interrupt for event CH4LIMITL
        ch4limitl: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH5LIMITH [16:16]
        ///Write '1' to enable interrupt for event CH5LIMITH
        ch5limith: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH5LIMITL [17:17]
        ///Write '1' to enable interrupt for event CH5LIMITL
        ch5limitl: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH6LIMITH [18:18]
        ///Write '1' to enable interrupt for event CH6LIMITH
        ch6limith: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH6LIMITL [19:19]
        ///Write '1' to enable interrupt for event CH6LIMITL
        ch6limitl: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH7LIMITH [20:20]
        ///Write '1' to enable interrupt for event CH7LIMITH
        ch7limith: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH7LIMITL [21:21]
        ///Write '1' to enable interrupt for event CH7LIMITL
        ch7limitl: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40007000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///STARTED [0:0]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///END [1:1]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DONE [2:2]
        ///Write '1' to disable interrupt for event DONE
        done: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RESULTDONE [3:3]
        ///Write '1' to disable interrupt for event RESULTDONE
        resultdone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CALIBRATEDONE [4:4]
        ///Write '1' to disable interrupt for event CALIBRATEDONE
        calibratedone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STOPPED [5:5]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH0LIMITH [6:6]
        ///Write '1' to disable interrupt for event CH0LIMITH
        ch0limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH0LIMITL [7:7]
        ///Write '1' to disable interrupt for event CH0LIMITL
        ch0limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH1LIMITH [8:8]
        ///Write '1' to disable interrupt for event CH1LIMITH
        ch1limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH1LIMITL [9:9]
        ///Write '1' to disable interrupt for event CH1LIMITL
        ch1limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH2LIMITH [10:10]
        ///Write '1' to disable interrupt for event CH2LIMITH
        ch2limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH2LIMITL [11:11]
        ///Write '1' to disable interrupt for event CH2LIMITL
        ch2limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH3LIMITH [12:12]
        ///Write '1' to disable interrupt for event CH3LIMITH
        ch3limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH3LIMITL [13:13]
        ///Write '1' to disable interrupt for event CH3LIMITL
        ch3limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH4LIMITH [14:14]
        ///Write '1' to disable interrupt for event CH4LIMITH
        ch4limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH4LIMITL [15:15]
        ///Write '1' to disable interrupt for event CH4LIMITL
        ch4limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH5LIMITH [16:16]
        ///Write '1' to disable interrupt for event CH5LIMITH
        ch5limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH5LIMITL [17:17]
        ///Write '1' to disable interrupt for event CH5LIMITL
        ch5limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH6LIMITH [18:18]
        ///Write '1' to disable interrupt for event CH6LIMITH
        ch6limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH6LIMITL [19:19]
        ///Write '1' to disable interrupt for event CH6LIMITL
        ch6limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH7LIMITH [20:20]
        ///Write '1' to disable interrupt for event CH7LIMITH
        ch7limith: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CH7LIMITL [21:21]
        ///Write '1' to disable interrupt for event CH7LIMITL
        ch7limitl: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenclr_val_write = packed struct {
        ///STARTED [0:0]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///END [1:1]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///DONE [2:2]
        ///Write '1' to disable interrupt for event DONE
        done: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RESULTDONE [3:3]
        ///Write '1' to disable interrupt for event RESULTDONE
        resultdone: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CALIBRATEDONE [4:4]
        ///Write '1' to disable interrupt for event CALIBRATEDONE
        calibratedone: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///STOPPED [5:5]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH0LIMITH [6:6]
        ///Write '1' to disable interrupt for event CH0LIMITH
        ch0limith: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH0LIMITL [7:7]
        ///Write '1' to disable interrupt for event CH0LIMITL
        ch0limitl: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH1LIMITH [8:8]
        ///Write '1' to disable interrupt for event CH1LIMITH
        ch1limith: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH1LIMITL [9:9]
        ///Write '1' to disable interrupt for event CH1LIMITL
        ch1limitl: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH2LIMITH [10:10]
        ///Write '1' to disable interrupt for event CH2LIMITH
        ch2limith: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH2LIMITL [11:11]
        ///Write '1' to disable interrupt for event CH2LIMITL
        ch2limitl: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH3LIMITH [12:12]
        ///Write '1' to disable interrupt for event CH3LIMITH
        ch3limith: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH3LIMITL [13:13]
        ///Write '1' to disable interrupt for event CH3LIMITL
        ch3limitl: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH4LIMITH [14:14]
        ///Write '1' to disable interrupt for event CH4LIMITH
        ch4limith: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH4LIMITL [15:15]
        ///Write '1' to disable interrupt for event CH4LIMITL
        ch4limitl: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH5LIMITH [16:16]
        ///Write '1' to disable interrupt for event CH5LIMITH
        ch5limith: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH5LIMITL [17:17]
        ///Write '1' to disable interrupt for event CH5LIMITL
        ch5limitl: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH6LIMITH [18:18]
        ///Write '1' to disable interrupt for event CH6LIMITH
        ch6limith: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH6LIMITL [19:19]
        ///Write '1' to disable interrupt for event CH6LIMITL
        ch6limitl: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH7LIMITH [20:20]
        ///Write '1' to disable interrupt for event CH7LIMITH
        ch7limith: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH7LIMITL [21:21]
        ///Write '1' to disable interrupt for event CH7LIMITL
        ch7limitl: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40007000 + 0x308);

    //////////////////////////
    ///STATUS
    const status_val = packed struct {
        ///STATUS [0:0]
        ///Status
        status: packed enum(u1) {
            ///SAADC is ready. No on-going conversions.
            ready = 0,
            ///SAADC is busy. Conversion in progress.
            busy = 1,
        } = .ready,
        _unused1: u31 = 0,
    };
    ///Status
    pub const status = RegisterRW(status_val, void).init(0x40007000 + 0x400);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:0]
        ///Enable or disable SAADC
        enable: packed enum(u1) {
            ///Disable SAADC
            disabled = 0,
            ///Enable SAADC
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Enable or disable SAADC
    pub const enable = Register(enable_val).init(0x40007000 + 0x500);

    //////////////////////////
    ///RESOLUTION
    const resolution_val = packed struct {
        ///VAL [0:2]
        ///Set the resolution
        val: packed enum(u3) {
            ///8 bits
            _8bit = 0,
            ///10 bits
            _10bit = 1,
            ///12 bits
            _12bit = 2,
            ///14 bits
            _14bit = 3,
        } = ._10bit,
        _unused3: u29 = 0,
    };
    ///Resolution configuration
    pub const resolution = Register(resolution_val).init(0x40007000 + 0x5F0);

    //////////////////////////
    ///OVERSAMPLE
    const oversample_val = packed struct {
        ///OVERSAMPLE [0:3]
        ///Oversample control
        oversample: packed enum(u4) {
            ///Bypass oversampling
            bypass = 0,
            ///Oversample 2x
            over2x = 1,
            ///Oversample 4x
            over4x = 2,
            ///Oversample 8x
            over8x = 3,
            ///Oversample 16x
            over16x = 4,
            ///Oversample 32x
            over32x = 5,
            ///Oversample 64x
            over64x = 6,
            ///Oversample 128x
            over128x = 7,
            ///Oversample 256x
            over256x = 8,
        } = .bypass,
        _unused4: u28 = 0,
    };
    ///Oversampling configuration. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used.
    pub const oversample = Register(oversample_val).init(0x40007000 + 0x5F4);

    //////////////////////////
    ///SAMPLERATE
    const samplerate_val = packed struct {
        ///CC [0:10]
        ///Capture and compare value. Sample rate is 16 MHz/CC
        cc: u11 = 0,
        _unused11: u1 = 0,
        ///MODE [12:12]
        ///Select mode for sample rate control
        mode: packed enum(u1) {
            ///Rate is controlled from SAMPLE task
            task = 0,
            ///Rate is controlled from local timer (use CC to control the rate)
            timers = 1,
        } = .task,
        _unused13: u19 = 0,
    };
    ///Controls normal or continuous sample rate
    pub const samplerate = Register(samplerate_val).init(0x40007000 + 0x5F8);
};

///Timer/Counter 0
pub const timer0 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start Timer
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start Timer
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40008000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop Timer
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop Timer
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40008000 + 0x004);

    //////////////////////////
    ///TASKS_COUNT
    const tasks_count_val = packed struct {
        ///TASKS_COUNT [0:0]
        ///Increment Timer (Counter mode only)
        tasks_count: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Increment Timer (Counter mode only)
    pub const tasks_count = RegisterRW(void, tasks_count_val).init(0x40008000 + 0x008);

    //////////////////////////
    ///TASKS_CLEAR
    const tasks_clear_val = packed struct {
        ///TASKS_CLEAR [0:0]
        ///Clear time
        tasks_clear: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Clear time
    pub const tasks_clear = RegisterRW(void, tasks_clear_val).init(0x40008000 + 0x00C);

    //////////////////////////
    ///TASKS_SHUTDOWN
    const tasks_shutdown_val = packed struct {
        ///TASKS_SHUTDOWN [0:0]
        ///Deprecated field -  Shut down timer
        tasks_shutdown: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Deprecated register - Shut down timer
    pub const tasks_shutdown = RegisterRW(void, tasks_shutdown_val).init(0x40008000 + 0x010);

    //////////////////////////
    ///TASKS_CAPTURE[%s]
    const tasks_capture_val = packed struct {
        ///TASKS_CAPTURE [0:0]
        ///Capture Timer value to CC[n] register
        tasks_capture: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Capture Timer value to CC[n] register
    pub const tasks_capture = RegisterRW(void, tasks_capture_val).initRange(0x40008000 + 0x040, 4, 6);

    //////////////////////////
    ///EVENTS_COMPARE[%s]
    const events_compare_val = packed struct {
        ///EVENTS_COMPARE [0:0]
        ///Compare event on CC[n] match
        events_compare: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Compare event on CC[n] match
    pub const events_compare = Register(events_compare_val).initRange(0x40008000 + 0x140, 4, 6);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///COMPARE0_CLEAR [0:0]
        ///Shortcut between event COMPARE[0] and task CLEAR
        compare0_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE1_CLEAR [1:1]
        ///Shortcut between event COMPARE[1] and task CLEAR
        compare1_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE2_CLEAR [2:2]
        ///Shortcut between event COMPARE[2] and task CLEAR
        compare2_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE3_CLEAR [3:3]
        ///Shortcut between event COMPARE[3] and task CLEAR
        compare3_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE4_CLEAR [4:4]
        ///Shortcut between event COMPARE[4] and task CLEAR
        compare4_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE5_CLEAR [5:5]
        ///Shortcut between event COMPARE[5] and task CLEAR
        compare5_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused6: u2 = 0,
        ///COMPARE0_STOP [8:8]
        ///Shortcut between event COMPARE[0] and task STOP
        compare0_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE1_STOP [9:9]
        ///Shortcut between event COMPARE[1] and task STOP
        compare1_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE2_STOP [10:10]
        ///Shortcut between event COMPARE[2] and task STOP
        compare2_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE3_STOP [11:11]
        ///Shortcut between event COMPARE[3] and task STOP
        compare3_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE4_STOP [12:12]
        ///Shortcut between event COMPARE[4] and task STOP
        compare4_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE5_STOP [13:13]
        ///Shortcut between event COMPARE[5] and task STOP
        compare5_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused14: u18 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40008000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE4 [20:20]
        ///Write '1' to enable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE5 [21:21]
        ///Write '1' to enable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE4 [20:20]
        ///Write '1' to enable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE5 [21:21]
        ///Write '1' to enable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40008000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE4 [20:20]
        ///Write '1' to disable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE5 [21:21]
        ///Write '1' to disable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE4 [20:20]
        ///Write '1' to disable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE5 [21:21]
        ///Write '1' to disable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40008000 + 0x308);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///MODE [0:1]
        ///Timer mode
        mode: packed enum(u2) {
            ///Select Timer mode
            timer = 0,
            ///Deprecated enumerator -  Select Counter mode
            counter = 1,
            ///Select Low Power Counter mode
            low_power_counter = 2,
        } = .timer,
        _unused2: u30 = 0,
    };
    ///Timer mode selection
    pub const mode = Register(mode_val).init(0x40008000 + 0x504);

    //////////////////////////
    ///BITMODE
    const bitmode_val = packed struct {
        ///BITMODE [0:1]
        ///Timer bit width
        bitmode: packed enum(u2) {
            ///16 bit timer bit width
            _16bit = 0,
            ///8 bit timer bit width
            _08bit = 1,
            ///24 bit timer bit width
            _24bit = 2,
            ///32 bit timer bit width
            _32bit = 3,
        } = ._16bit,
        _unused2: u30 = 0,
    };
    ///Configure the number of bits used by the TIMER
    pub const bitmode = Register(bitmode_val).init(0x40008000 + 0x508);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:3]
        ///Prescaler value
        prescaler: u4 = 4,
        _unused4: u28 = 0,
    };
    ///Timer prescaler register
    pub const prescaler = Register(prescaler_val).init(0x40008000 + 0x510);

    //////////////////////////
    ///CC[%s]
    const cc_val = packed struct {
        ///CC [0:31]
        ///Capture/Compare value
        cc: u32 = 0,
    };
    ///Description collection: Capture/Compare register n
    pub const cc = Register(cc_val).initRange(0x40008000 + 0x540, 4, 6);
};

///Timer/Counter 1
pub const timer1 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start Timer
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start Timer
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40009000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop Timer
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop Timer
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40009000 + 0x004);

    //////////////////////////
    ///TASKS_COUNT
    const tasks_count_val = packed struct {
        ///TASKS_COUNT [0:0]
        ///Increment Timer (Counter mode only)
        tasks_count: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Increment Timer (Counter mode only)
    pub const tasks_count = RegisterRW(void, tasks_count_val).init(0x40009000 + 0x008);

    //////////////////////////
    ///TASKS_CLEAR
    const tasks_clear_val = packed struct {
        ///TASKS_CLEAR [0:0]
        ///Clear time
        tasks_clear: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Clear time
    pub const tasks_clear = RegisterRW(void, tasks_clear_val).init(0x40009000 + 0x00C);

    //////////////////////////
    ///TASKS_SHUTDOWN
    const tasks_shutdown_val = packed struct {
        ///TASKS_SHUTDOWN [0:0]
        ///Deprecated field -  Shut down timer
        tasks_shutdown: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Deprecated register - Shut down timer
    pub const tasks_shutdown = RegisterRW(void, tasks_shutdown_val).init(0x40009000 + 0x010);

    //////////////////////////
    ///TASKS_CAPTURE[%s]
    const tasks_capture_val = packed struct {
        ///TASKS_CAPTURE [0:0]
        ///Capture Timer value to CC[n] register
        tasks_capture: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Capture Timer value to CC[n] register
    pub const tasks_capture = RegisterRW(void, tasks_capture_val).initRange(0x40009000 + 0x040, 4, 6);

    //////////////////////////
    ///EVENTS_COMPARE[%s]
    const events_compare_val = packed struct {
        ///EVENTS_COMPARE [0:0]
        ///Compare event on CC[n] match
        events_compare: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Compare event on CC[n] match
    pub const events_compare = Register(events_compare_val).initRange(0x40009000 + 0x140, 4, 6);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///COMPARE0_CLEAR [0:0]
        ///Shortcut between event COMPARE[0] and task CLEAR
        compare0_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE1_CLEAR [1:1]
        ///Shortcut between event COMPARE[1] and task CLEAR
        compare1_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE2_CLEAR [2:2]
        ///Shortcut between event COMPARE[2] and task CLEAR
        compare2_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE3_CLEAR [3:3]
        ///Shortcut between event COMPARE[3] and task CLEAR
        compare3_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE4_CLEAR [4:4]
        ///Shortcut between event COMPARE[4] and task CLEAR
        compare4_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE5_CLEAR [5:5]
        ///Shortcut between event COMPARE[5] and task CLEAR
        compare5_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused6: u2 = 0,
        ///COMPARE0_STOP [8:8]
        ///Shortcut between event COMPARE[0] and task STOP
        compare0_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE1_STOP [9:9]
        ///Shortcut between event COMPARE[1] and task STOP
        compare1_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE2_STOP [10:10]
        ///Shortcut between event COMPARE[2] and task STOP
        compare2_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE3_STOP [11:11]
        ///Shortcut between event COMPARE[3] and task STOP
        compare3_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE4_STOP [12:12]
        ///Shortcut between event COMPARE[4] and task STOP
        compare4_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE5_STOP [13:13]
        ///Shortcut between event COMPARE[5] and task STOP
        compare5_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused14: u18 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40009000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE4 [20:20]
        ///Write '1' to enable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE5 [21:21]
        ///Write '1' to enable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE4 [20:20]
        ///Write '1' to enable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE5 [21:21]
        ///Write '1' to enable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40009000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE4 [20:20]
        ///Write '1' to disable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE5 [21:21]
        ///Write '1' to disable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE4 [20:20]
        ///Write '1' to disable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE5 [21:21]
        ///Write '1' to disable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40009000 + 0x308);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///MODE [0:1]
        ///Timer mode
        mode: packed enum(u2) {
            ///Select Timer mode
            timer = 0,
            ///Deprecated enumerator -  Select Counter mode
            counter = 1,
            ///Select Low Power Counter mode
            low_power_counter = 2,
        } = .timer,
        _unused2: u30 = 0,
    };
    ///Timer mode selection
    pub const mode = Register(mode_val).init(0x40009000 + 0x504);

    //////////////////////////
    ///BITMODE
    const bitmode_val = packed struct {
        ///BITMODE [0:1]
        ///Timer bit width
        bitmode: packed enum(u2) {
            ///16 bit timer bit width
            _16bit = 0,
            ///8 bit timer bit width
            _08bit = 1,
            ///24 bit timer bit width
            _24bit = 2,
            ///32 bit timer bit width
            _32bit = 3,
        } = ._16bit,
        _unused2: u30 = 0,
    };
    ///Configure the number of bits used by the TIMER
    pub const bitmode = Register(bitmode_val).init(0x40009000 + 0x508);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:3]
        ///Prescaler value
        prescaler: u4 = 4,
        _unused4: u28 = 0,
    };
    ///Timer prescaler register
    pub const prescaler = Register(prescaler_val).init(0x40009000 + 0x510);

    //////////////////////////
    ///CC[%s]
    const cc_val = packed struct {
        ///CC [0:31]
        ///Capture/Compare value
        cc: u32 = 0,
    };
    ///Description collection: Capture/Compare register n
    pub const cc = Register(cc_val).initRange(0x40009000 + 0x540, 4, 6);
};

///Timer/Counter 2
pub const timer2 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start Timer
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start Timer
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x4000A000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop Timer
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop Timer
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4000A000 + 0x004);

    //////////////////////////
    ///TASKS_COUNT
    const tasks_count_val = packed struct {
        ///TASKS_COUNT [0:0]
        ///Increment Timer (Counter mode only)
        tasks_count: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Increment Timer (Counter mode only)
    pub const tasks_count = RegisterRW(void, tasks_count_val).init(0x4000A000 + 0x008);

    //////////////////////////
    ///TASKS_CLEAR
    const tasks_clear_val = packed struct {
        ///TASKS_CLEAR [0:0]
        ///Clear time
        tasks_clear: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Clear time
    pub const tasks_clear = RegisterRW(void, tasks_clear_val).init(0x4000A000 + 0x00C);

    //////////////////////////
    ///TASKS_SHUTDOWN
    const tasks_shutdown_val = packed struct {
        ///TASKS_SHUTDOWN [0:0]
        ///Deprecated field -  Shut down timer
        tasks_shutdown: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Deprecated register - Shut down timer
    pub const tasks_shutdown = RegisterRW(void, tasks_shutdown_val).init(0x4000A000 + 0x010);

    //////////////////////////
    ///TASKS_CAPTURE[%s]
    const tasks_capture_val = packed struct {
        ///TASKS_CAPTURE [0:0]
        ///Capture Timer value to CC[n] register
        tasks_capture: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Capture Timer value to CC[n] register
    pub const tasks_capture = RegisterRW(void, tasks_capture_val).initRange(0x4000A000 + 0x040, 4, 6);

    //////////////////////////
    ///EVENTS_COMPARE[%s]
    const events_compare_val = packed struct {
        ///EVENTS_COMPARE [0:0]
        ///Compare event on CC[n] match
        events_compare: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Compare event on CC[n] match
    pub const events_compare = Register(events_compare_val).initRange(0x4000A000 + 0x140, 4, 6);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///COMPARE0_CLEAR [0:0]
        ///Shortcut between event COMPARE[0] and task CLEAR
        compare0_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE1_CLEAR [1:1]
        ///Shortcut between event COMPARE[1] and task CLEAR
        compare1_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE2_CLEAR [2:2]
        ///Shortcut between event COMPARE[2] and task CLEAR
        compare2_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE3_CLEAR [3:3]
        ///Shortcut between event COMPARE[3] and task CLEAR
        compare3_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE4_CLEAR [4:4]
        ///Shortcut between event COMPARE[4] and task CLEAR
        compare4_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE5_CLEAR [5:5]
        ///Shortcut between event COMPARE[5] and task CLEAR
        compare5_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused6: u2 = 0,
        ///COMPARE0_STOP [8:8]
        ///Shortcut between event COMPARE[0] and task STOP
        compare0_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE1_STOP [9:9]
        ///Shortcut between event COMPARE[1] and task STOP
        compare1_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE2_STOP [10:10]
        ///Shortcut between event COMPARE[2] and task STOP
        compare2_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE3_STOP [11:11]
        ///Shortcut between event COMPARE[3] and task STOP
        compare3_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE4_STOP [12:12]
        ///Shortcut between event COMPARE[4] and task STOP
        compare4_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE5_STOP [13:13]
        ///Shortcut between event COMPARE[5] and task STOP
        compare5_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused14: u18 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x4000A000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE4 [20:20]
        ///Write '1' to enable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE5 [21:21]
        ///Write '1' to enable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE4 [20:20]
        ///Write '1' to enable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE5 [21:21]
        ///Write '1' to enable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4000A000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE4 [20:20]
        ///Write '1' to disable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE5 [21:21]
        ///Write '1' to disable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE4 [20:20]
        ///Write '1' to disable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE5 [21:21]
        ///Write '1' to disable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4000A000 + 0x308);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///MODE [0:1]
        ///Timer mode
        mode: packed enum(u2) {
            ///Select Timer mode
            timer = 0,
            ///Deprecated enumerator -  Select Counter mode
            counter = 1,
            ///Select Low Power Counter mode
            low_power_counter = 2,
        } = .timer,
        _unused2: u30 = 0,
    };
    ///Timer mode selection
    pub const mode = Register(mode_val).init(0x4000A000 + 0x504);

    //////////////////////////
    ///BITMODE
    const bitmode_val = packed struct {
        ///BITMODE [0:1]
        ///Timer bit width
        bitmode: packed enum(u2) {
            ///16 bit timer bit width
            _16bit = 0,
            ///8 bit timer bit width
            _08bit = 1,
            ///24 bit timer bit width
            _24bit = 2,
            ///32 bit timer bit width
            _32bit = 3,
        } = ._16bit,
        _unused2: u30 = 0,
    };
    ///Configure the number of bits used by the TIMER
    pub const bitmode = Register(bitmode_val).init(0x4000A000 + 0x508);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:3]
        ///Prescaler value
        prescaler: u4 = 4,
        _unused4: u28 = 0,
    };
    ///Timer prescaler register
    pub const prescaler = Register(prescaler_val).init(0x4000A000 + 0x510);

    //////////////////////////
    ///CC[%s]
    const cc_val = packed struct {
        ///CC [0:31]
        ///Capture/Compare value
        cc: u32 = 0,
    };
    ///Description collection: Capture/Compare register n
    pub const cc = Register(cc_val).initRange(0x4000A000 + 0x540, 4, 6);
};

///Real time counter 0
pub const rtc0 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start RTC COUNTER
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start RTC COUNTER
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x4000B000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop RTC COUNTER
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop RTC COUNTER
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4000B000 + 0x004);

    //////////////////////////
    ///TASKS_CLEAR
    const tasks_clear_val = packed struct {
        ///TASKS_CLEAR [0:0]
        ///Clear RTC COUNTER
        tasks_clear: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Clear RTC COUNTER
    pub const tasks_clear = RegisterRW(void, tasks_clear_val).init(0x4000B000 + 0x008);

    //////////////////////////
    ///TASKS_TRIGOVRFLW
    const tasks_trigovrflw_val = packed struct {
        ///TASKS_TRIGOVRFLW [0:0]
        ///Set COUNTER to 0xFFFFF0
        tasks_trigovrflw: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Set COUNTER to 0xFFFFF0
    pub const tasks_trigovrflw = RegisterRW(void, tasks_trigovrflw_val).init(0x4000B000 + 0x00C);

    //////////////////////////
    ///EVENTS_TICK
    const events_tick_val = packed struct {
        ///EVENTS_TICK [0:0]
        ///Event on COUNTER increment
        events_tick: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Event on COUNTER increment
    pub const events_tick = Register(events_tick_val).init(0x4000B000 + 0x100);

    //////////////////////////
    ///EVENTS_OVRFLW
    const events_ovrflw_val = packed struct {
        ///EVENTS_OVRFLW [0:0]
        ///Event on COUNTER overflow
        events_ovrflw: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Event on COUNTER overflow
    pub const events_ovrflw = Register(events_ovrflw_val).init(0x4000B000 + 0x104);

    //////////////////////////
    ///EVENTS_COMPARE[%s]
    const events_compare_val = packed struct {
        ///EVENTS_COMPARE [0:0]
        ///Compare event on CC[n] match
        events_compare: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Compare event on CC[n] match
    pub const events_compare = Register(events_compare_val).initRange(0x4000B000 + 0x140, 4, 4);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable interrupt for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to enable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenset_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable interrupt for event TICK
        tick: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to enable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4000B000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable interrupt for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to disable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenclr_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable interrupt for event TICK
        tick: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to disable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4000B000 + 0x308);

    //////////////////////////
    ///EVTEN
    const evten_val = packed struct {
        ///TICK [0:0]
        ///Enable or disable event routing for event TICK
        tick: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Enable or disable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Enable or disable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Enable or disable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Enable or disable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Enable or disable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    ///Enable or disable event routing
    pub const evten = Register(evten_val).init(0x4000B000 + 0x340);

    //////////////////////////
    ///EVTENSET
    const evtenset_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable event routing for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to enable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const evtenset_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable event routing for event TICK
        tick: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to enable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Enable event routing
    pub const evtenset = RegisterRW(evtenset_val_read, evtenset_val_write).init(0x4000B000 + 0x344);

    //////////////////////////
    ///EVTENCLR
    const evtenclr_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable event routing for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to disable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const evtenclr_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable event routing for event TICK
        tick: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to disable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Disable event routing
    pub const evtenclr = RegisterRW(evtenclr_val_read, evtenclr_val_write).init(0x4000B000 + 0x348);

    //////////////////////////
    ///COUNTER
    const counter_val = packed struct {
        ///COUNTER [0:23]
        ///Counter value
        counter: u24 = 0,
        _unused24: u8 = 0,
    };
    ///Current COUNTER value
    pub const counter = RegisterRW(counter_val, void).init(0x4000B000 + 0x504);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:11]
        ///Prescaler value
        prescaler: u12 = 0,
        _unused12: u20 = 0,
    };
    ///12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped
    pub const prescaler = Register(prescaler_val).init(0x4000B000 + 0x508);

    //////////////////////////
    ///CC[%s]
    const cc_val = packed struct {
        ///COMPARE [0:23]
        ///Compare value
        compare: u24 = 0,
        _unused24: u8 = 0,
    };
    ///Description collection: Compare register n
    pub const cc = Register(cc_val).initRange(0x4000B000 + 0x540, 4, 4);
};

///Temperature Sensor
pub const temp = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start temperature measurement
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start temperature measurement
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x4000C000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop temperature measurement
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop temperature measurement
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4000C000 + 0x004);

    //////////////////////////
    ///EVENTS_DATARDY
    const events_datardy_val = packed struct {
        ///EVENTS_DATARDY [0:0]
        ///Temperature measurement complete, data ready
        events_datardy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Temperature measurement complete, data ready
    pub const events_datardy = Register(events_datardy_val).init(0x4000C000 + 0x100);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///DATARDY [0:0]
        ///Write '1' to enable interrupt for event DATARDY
        datardy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    const intenset_val_write = packed struct {
        ///DATARDY [0:0]
        ///Write '1' to enable interrupt for event DATARDY
        datardy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4000C000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///DATARDY [0:0]
        ///Write '1' to disable interrupt for event DATARDY
        datardy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    const intenclr_val_write = packed struct {
        ///DATARDY [0:0]
        ///Write '1' to disable interrupt for event DATARDY
        datardy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4000C000 + 0x308);

    //////////////////////////
    ///TEMP
    const temp_val = packed struct {
        ///TEMP [0:31]
        ///Temperature in degC (0.25deg steps)
        temp: u32 = 0,
    };
    ///Temperature in degC (0.25deg steps)
    pub const temp = RegisterRW(temp_val, void).init(0x4000C000 + 0x508);

    //////////////////////////
    ///A0
    const a0_val = packed struct {
        ///A0 [0:11]
        ///Slope of 1st piece wise linear function
        a0: u12 = 806,
        _unused12: u20 = 0,
    };
    ///Slope of 1st piece wise linear function
    pub const a0 = Register(a0_val).init(0x4000C000 + 0x520);

    //////////////////////////
    ///A1
    const a1_val = packed struct {
        ///A1 [0:11]
        ///Slope of 2nd piece wise linear function
        a1: u12 = 840,
        _unused12: u20 = 0,
    };
    ///Slope of 2nd piece wise linear function
    pub const a1 = Register(a1_val).init(0x4000C000 + 0x524);

    //////////////////////////
    ///A2
    const a2_val = packed struct {
        ///A2 [0:11]
        ///Slope of 3rd piece wise linear function
        a2: u12 = 938,
        _unused12: u20 = 0,
    };
    ///Slope of 3rd piece wise linear function
    pub const a2 = Register(a2_val).init(0x4000C000 + 0x528);

    //////////////////////////
    ///A3
    const a3_val = packed struct {
        ///A3 [0:11]
        ///Slope of 4th piece wise linear function
        a3: u12 = 1038,
        _unused12: u20 = 0,
    };
    ///Slope of 4th piece wise linear function
    pub const a3 = Register(a3_val).init(0x4000C000 + 0x52C);

    //////////////////////////
    ///A4
    const a4_val = packed struct {
        ///A4 [0:11]
        ///Slope of 5th piece wise linear function
        a4: u12 = 1213,
        _unused12: u20 = 0,
    };
    ///Slope of 5th piece wise linear function
    pub const a4 = Register(a4_val).init(0x4000C000 + 0x530);

    //////////////////////////
    ///A5
    const a5_val = packed struct {
        ///A5 [0:11]
        ///Slope of 6th piece wise linear function
        a5: u12 = 1443,
        _unused12: u20 = 0,
    };
    ///Slope of 6th piece wise linear function
    pub const a5 = Register(a5_val).init(0x4000C000 + 0x534);

    //////////////////////////
    ///B0
    const b0_val = packed struct {
        ///B0 [0:13]
        ///y-intercept of 1st piece wise linear function
        b0: u14 = 16367,
        _unused14: u18 = 0,
    };
    ///y-intercept of 1st piece wise linear function
    pub const b0 = Register(b0_val).init(0x4000C000 + 0x540);

    //////////////////////////
    ///B1
    const b1_val = packed struct {
        ///B1 [0:13]
        ///y-intercept of 2nd piece wise linear function
        b1: u14 = 16318,
        _unused14: u18 = 0,
    };
    ///y-intercept of 2nd piece wise linear function
    pub const b1 = Register(b1_val).init(0x4000C000 + 0x544);

    //////////////////////////
    ///B2
    const b2_val = packed struct {
        ///B2 [0:13]
        ///y-intercept of 3rd piece wise linear function
        b2: u14 = 16318,
        _unused14: u18 = 0,
    };
    ///y-intercept of 3rd piece wise linear function
    pub const b2 = Register(b2_val).init(0x4000C000 + 0x548);

    //////////////////////////
    ///B3
    const b3_val = packed struct {
        ///B3 [0:13]
        ///y-intercept of 4th piece wise linear function
        b3: u14 = 18,
        _unused14: u18 = 0,
    };
    ///y-intercept of 4th piece wise linear function
    pub const b3 = Register(b3_val).init(0x4000C000 + 0x54C);

    //////////////////////////
    ///B4
    const b4_val = packed struct {
        ///B4 [0:13]
        ///y-intercept of 5th piece wise linear function
        b4: u14 = 292,
        _unused14: u18 = 0,
    };
    ///y-intercept of 5th piece wise linear function
    pub const b4 = Register(b4_val).init(0x4000C000 + 0x550);

    //////////////////////////
    ///B5
    const b5_val = packed struct {
        ///B5 [0:13]
        ///y-intercept of 6th piece wise linear function
        b5: u14 = 636,
        _unused14: u18 = 0,
    };
    ///y-intercept of 6th piece wise linear function
    pub const b5 = Register(b5_val).init(0x4000C000 + 0x554);

    //////////////////////////
    ///T0
    const t0_val = packed struct {
        ///T0 [0:7]
        ///End point of 1st piece wise linear function
        t0: u8 = 226,
        _unused8: u24 = 0,
    };
    ///End point of 1st piece wise linear function
    pub const t0 = Register(t0_val).init(0x4000C000 + 0x560);

    //////////////////////////
    ///T1
    const t1_val = packed struct {
        ///T1 [0:7]
        ///End point of 2nd piece wise linear function
        t1: u8 = 0,
        _unused8: u24 = 0,
    };
    ///End point of 2nd piece wise linear function
    pub const t1 = Register(t1_val).init(0x4000C000 + 0x564);

    //////////////////////////
    ///T2
    const t2_val = packed struct {
        ///T2 [0:7]
        ///End point of 3rd piece wise linear function
        t2: u8 = 25,
        _unused8: u24 = 0,
    };
    ///End point of 3rd piece wise linear function
    pub const t2 = Register(t2_val).init(0x4000C000 + 0x568);

    //////////////////////////
    ///T3
    const t3_val = packed struct {
        ///T3 [0:7]
        ///End point of 4th piece wise linear function
        t3: u8 = 60,
        _unused8: u24 = 0,
    };
    ///End point of 4th piece wise linear function
    pub const t3 = Register(t3_val).init(0x4000C000 + 0x56C);

    //////////////////////////
    ///T4
    const t4_val = packed struct {
        ///T4 [0:7]
        ///End point of 5th piece wise linear function
        t4: u8 = 80,
        _unused8: u24 = 0,
    };
    ///End point of 5th piece wise linear function
    pub const t4 = Register(t4_val).init(0x4000C000 + 0x570);
};

///Random Number Generator
pub const rng = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Task starting the random number generator
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Task starting the random number generator
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x4000D000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Task stopping the random number generator
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Task stopping the random number generator
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4000D000 + 0x004);

    //////////////////////////
    ///EVENTS_VALRDY
    const events_valrdy_val = packed struct {
        ///EVENTS_VALRDY [0:0]
        ///Event being generated for every new random number written to the VALUE register
        events_valrdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Event being generated for every new random number written to the VALUE register
    pub const events_valrdy = Register(events_valrdy_val).init(0x4000D000 + 0x100);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///VALRDY_STOP [0:0]
        ///Shortcut between event VALRDY and task STOP
        valrdy_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x4000D000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///VALRDY [0:0]
        ///Write '1' to enable interrupt for event VALRDY
        valrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    const intenset_val_write = packed struct {
        ///VALRDY [0:0]
        ///Write '1' to enable interrupt for event VALRDY
        valrdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4000D000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///VALRDY [0:0]
        ///Write '1' to disable interrupt for event VALRDY
        valrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    const intenclr_val_write = packed struct {
        ///VALRDY [0:0]
        ///Write '1' to disable interrupt for event VALRDY
        valrdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4000D000 + 0x308);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///DERCEN [0:0]
        ///Bias correction
        dercen: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x4000D000 + 0x504);

    //////////////////////////
    ///VALUE
    const value_val = packed struct {
        ///VALUE [0:7]
        ///Generated random number
        value: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Output random number
    pub const value = RegisterRW(value_val, void).init(0x4000D000 + 0x508);
};

///AES ECB Mode Encryption
pub const ecb = struct {

    //////////////////////////
    ///TASKS_STARTECB
    const tasks_startecb_val = packed struct {
        ///TASKS_STARTECB [0:0]
        ///Start ECB block encrypt
        tasks_startecb: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start ECB block encrypt
    pub const tasks_startecb = RegisterRW(void, tasks_startecb_val).init(0x4000E000 + 0x000);

    //////////////////////////
    ///TASKS_STOPECB
    const tasks_stopecb_val = packed struct {
        ///TASKS_STOPECB [0:0]
        ///Abort a possible executing ECB operation
        tasks_stopecb: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Abort a possible executing ECB operation
    pub const tasks_stopecb = RegisterRW(void, tasks_stopecb_val).init(0x4000E000 + 0x004);

    //////////////////////////
    ///EVENTS_ENDECB
    const events_endecb_val = packed struct {
        ///EVENTS_ENDECB [0:0]
        ///ECB block encrypt complete
        events_endecb: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///ECB block encrypt complete
    pub const events_endecb = Register(events_endecb_val).init(0x4000E000 + 0x100);

    //////////////////////////
    ///EVENTS_ERRORECB
    const events_errorecb_val = packed struct {
        ///EVENTS_ERRORECB [0:0]
        ///ECB block encrypt aborted because of a STOPECB task or due to an error
        events_errorecb: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///ECB block encrypt aborted because of a STOPECB task or due to an error
    pub const events_errorecb = Register(events_errorecb_val).init(0x4000E000 + 0x104);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///ENDECB [0:0]
        ///Write '1' to enable interrupt for event ENDECB
        endecb: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ERRORECB [1:1]
        ///Write '1' to enable interrupt for event ERRORECB
        errorecb: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u30 = 0,
    };
    const intenset_val_write = packed struct {
        ///ENDECB [0:0]
        ///Write '1' to enable interrupt for event ENDECB
        endecb: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ERRORECB [1:1]
        ///Write '1' to enable interrupt for event ERRORECB
        errorecb: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u30 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4000E000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///ENDECB [0:0]
        ///Write '1' to disable interrupt for event ENDECB
        endecb: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ERRORECB [1:1]
        ///Write '1' to disable interrupt for event ERRORECB
        errorecb: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u30 = 0,
    };
    const intenclr_val_write = packed struct {
        ///ENDECB [0:0]
        ///Write '1' to disable interrupt for event ENDECB
        endecb: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ERRORECB [1:1]
        ///Write '1' to disable interrupt for event ERRORECB
        errorecb: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u30 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4000E000 + 0x308);

    //////////////////////////
    ///ECBDATAPTR
    const ecbdataptr_val = packed struct {
        ///ECBDATAPTR [0:31]
        ///Pointer to the ECB data structure (see Table 1 ECB data structure overview)
        ecbdataptr: u32 = 0,
    };
    ///ECB block encrypt memory pointers
    pub const ecbdataptr = Register(ecbdataptr_val).init(0x4000E000 + 0x504);
};

///Accelerated Address Resolver
pub const aar = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start resolving addresses based on IRKs specified in the IRK data structure
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start resolving addresses based on IRKs specified in the IRK data structure
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x4000F000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop resolving addresses
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop resolving addresses
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4000F000 + 0x008);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///Address resolution procedure complete
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Address resolution procedure complete
    pub const events_end = Register(events_end_val).init(0x4000F000 + 0x100);

    //////////////////////////
    ///EVENTS_RESOLVED
    const events_resolved_val = packed struct {
        ///EVENTS_RESOLVED [0:0]
        ///Address resolved
        events_resolved: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Address resolved
    pub const events_resolved = Register(events_resolved_val).init(0x4000F000 + 0x104);

    //////////////////////////
    ///EVENTS_NOTRESOLVED
    const events_notresolved_val = packed struct {
        ///EVENTS_NOTRESOLVED [0:0]
        ///Address not resolved
        events_notresolved: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Address not resolved
    pub const events_notresolved = Register(events_notresolved_val).init(0x4000F000 + 0x108);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///END [0:0]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RESOLVED [1:1]
        ///Write '1' to enable interrupt for event RESOLVED
        resolved: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///NOTRESOLVED [2:2]
        ///Write '1' to enable interrupt for event NOTRESOLVED
        notresolved: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenset_val_write = packed struct {
        ///END [0:0]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RESOLVED [1:1]
        ///Write '1' to enable interrupt for event RESOLVED
        resolved: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///NOTRESOLVED [2:2]
        ///Write '1' to enable interrupt for event NOTRESOLVED
        notresolved: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4000F000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///END [0:0]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RESOLVED [1:1]
        ///Write '1' to disable interrupt for event RESOLVED
        resolved: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///NOTRESOLVED [2:2]
        ///Write '1' to disable interrupt for event NOTRESOLVED
        notresolved: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenclr_val_write = packed struct {
        ///END [0:0]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RESOLVED [1:1]
        ///Write '1' to disable interrupt for event RESOLVED
        resolved: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///NOTRESOLVED [2:2]
        ///Write '1' to disable interrupt for event NOTRESOLVED
        notresolved: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4000F000 + 0x308);

    //////////////////////////
    ///STATUS
    const status_val = packed struct {
        ///STATUS [0:3]
        ///The IRK that was used last time an address was resolved
        status: u4 = 0,
        _unused4: u28 = 0,
    };
    ///Resolution status
    pub const status = RegisterRW(status_val, void).init(0x4000F000 + 0x400);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:1]
        ///Enable or disable AAR
        enable: packed enum(u2) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 3,
        } = .disabled,
        _unused2: u30 = 0,
    };
    ///Enable AAR
    pub const enable = Register(enable_val).init(0x4000F000 + 0x500);

    //////////////////////////
    ///NIRK
    const nirk_val = packed struct {
        ///NIRK [0:4]
        ///Number of Identity root keys available in the IRK data structure
        nirk: u5 = 1,
        _unused5: u27 = 0,
    };
    ///Number of IRKs
    pub const nirk = Register(nirk_val).init(0x4000F000 + 0x504);

    //////////////////////////
    ///IRKPTR
    const irkptr_val = packed struct {
        ///IRKPTR [0:31]
        ///Pointer to the IRK data structure
        irkptr: u32 = 0,
    };
    ///Pointer to IRK data structure
    pub const irkptr = Register(irkptr_val).init(0x4000F000 + 0x508);

    //////////////////////////
    ///ADDRPTR
    const addrptr_val = packed struct {
        ///ADDRPTR [0:31]
        ///Pointer to the resolvable address (6-bytes)
        addrptr: u32 = 0,
    };
    ///Pointer to the resolvable address
    pub const addrptr = Register(addrptr_val).init(0x4000F000 + 0x510);

    //////////////////////////
    ///SCRATCHPTR
    const scratchptr_val = packed struct {
        ///SCRATCHPTR [0:31]
        ///Pointer to a scratch data area used for temporary storage during resolution. A space of minimum 3 bytes must be reserved.
        scratchptr: u32 = 0,
    };
    ///Pointer to data area used for temporary storage
    pub const scratchptr = Register(scratchptr_val).init(0x4000F000 + 0x514);
};

///AES CCM Mode Encryption
pub const ccm = struct {

    //////////////////////////
    ///TASKS_KSGEN
    const tasks_ksgen_val = packed struct {
        ///TASKS_KSGEN [0:0]
        ///Start generation of key-stream. This operation will stop by itself when completed.
        tasks_ksgen: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start generation of key-stream. This operation will stop by itself when completed.
    pub const tasks_ksgen = RegisterRW(void, tasks_ksgen_val).init(0x4000F000 + 0x000);

    //////////////////////////
    ///TASKS_CRYPT
    const tasks_crypt_val = packed struct {
        ///TASKS_CRYPT [0:0]
        ///Start encryption/decryption. This operation will stop by itself when completed.
        tasks_crypt: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start encryption/decryption. This operation will stop by itself when completed.
    pub const tasks_crypt = RegisterRW(void, tasks_crypt_val).init(0x4000F000 + 0x004);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop encryption/decryption
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop encryption/decryption
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4000F000 + 0x008);

    //////////////////////////
    ///TASKS_RATEOVERRIDE
    const tasks_rateoverride_val = packed struct {
        ///TASKS_RATEOVERRIDE [0:0]
        ///Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption
        tasks_rateoverride: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption
    pub const tasks_rateoverride = RegisterRW(void, tasks_rateoverride_val).init(0x4000F000 + 0x00C);

    //////////////////////////
    ///EVENTS_ENDKSGEN
    const events_endksgen_val = packed struct {
        ///EVENTS_ENDKSGEN [0:0]
        ///Key-stream generation complete
        events_endksgen: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Key-stream generation complete
    pub const events_endksgen = Register(events_endksgen_val).init(0x4000F000 + 0x100);

    //////////////////////////
    ///EVENTS_ENDCRYPT
    const events_endcrypt_val = packed struct {
        ///EVENTS_ENDCRYPT [0:0]
        ///Encrypt/decrypt complete
        events_endcrypt: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Encrypt/decrypt complete
    pub const events_endcrypt = Register(events_endcrypt_val).init(0x4000F000 + 0x104);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///Deprecated field -  CCM error event
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Deprecated register - CCM error event
    pub const events_error = Register(events_error_val).init(0x4000F000 + 0x108);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///ENDKSGEN_CRYPT [0:0]
        ///Shortcut between event ENDKSGEN and task CRYPT
        endksgen_crypt: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x4000F000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///ENDKSGEN [0:0]
        ///Write '1' to enable interrupt for event ENDKSGEN
        endksgen: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDCRYPT [1:1]
        ///Write '1' to enable interrupt for event ENDCRYPT
        endcrypt: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ERROR [2:2]
        ///Deprecated intsetfield -  Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenset_val_write = packed struct {
        ///ENDKSGEN [0:0]
        ///Write '1' to enable interrupt for event ENDKSGEN
        endksgen: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDCRYPT [1:1]
        ///Write '1' to enable interrupt for event ENDCRYPT
        endcrypt: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ERROR [2:2]
        ///Deprecated intsetfield -  Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4000F000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///ENDKSGEN [0:0]
        ///Write '1' to disable interrupt for event ENDKSGEN
        endksgen: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDCRYPT [1:1]
        ///Write '1' to disable interrupt for event ENDCRYPT
        endcrypt: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ERROR [2:2]
        ///Deprecated intclrfield -  Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenclr_val_write = packed struct {
        ///ENDKSGEN [0:0]
        ///Write '1' to disable interrupt for event ENDKSGEN
        endksgen: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDCRYPT [1:1]
        ///Write '1' to disable interrupt for event ENDCRYPT
        endcrypt: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ERROR [2:2]
        ///Deprecated intclrfield -  Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4000F000 + 0x308);

    //////////////////////////
    ///MICSTATUS
    const micstatus_val = packed struct {
        ///MICSTATUS [0:0]
        ///The result of the MIC check performed during the previous decryption operation
        micstatus: packed enum(u1) {
            ///MIC check failed
            check_failed = 0,
            ///MIC check passed
            check_passed = 1,
        } = .check_failed,
        _unused1: u31 = 0,
    };
    ///MIC check result
    pub const micstatus = RegisterRW(micstatus_val, void).init(0x4000F000 + 0x400);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:1]
        ///Enable or disable CCM
        enable: packed enum(u2) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 2,
        } = .disabled,
        _unused2: u30 = 0,
    };
    ///Enable
    pub const enable = Register(enable_val).init(0x4000F000 + 0x500);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///MODE [0:0]
        ///The mode of operation to be used. The settings in this register apply whenever either the KSGEN or CRYPT tasks are triggered.
        mode: packed enum(u1) {
            ///AES CCM packet encryption mode
            encryption = 0,
            ///AES CCM packet decryption mode
            decryption = 1,
        } = .decryption,
        _unused1: u15 = 0,
        ///DATARATE [16:17]
        ///Radio data rate that the CCM shall run synchronous with
        datarate: packed enum(u2) {
            ///1 Mbps
            _1mbit = 0,
            ///2 Mbps
            _2mbit = 1,
            ///125 Kbps
            _125kbps = 2,
            ///500 Kbps
            _500kbps = 3,
        } = ._1mbit,
        _unused18: u6 = 0,
        ///LENGTH [24:24]
        ///Packet length configuration
        length: packed enum(u1) {
            ///Default length. Effective length of LENGTH field in encrypted/decrypted packet is 5 bits. A key-stream for packet payloads up to 27 bytes will be generated.
            default = 0,
            ///Extended length. Effective length of LENGTH field in encrypted/decrypted packet is 8 bits. A key-stream for packet payloads up to MAXPACKETSIZE bytes will be generated.
            extended = 1,
        } = .default,
        _unused25: u7 = 0,
    };
    ///Operation mode
    pub const mode = Register(mode_val).init(0x4000F000 + 0x504);

    //////////////////////////
    ///CNFPTR
    const cnfptr_val = packed struct {
        ///CNFPTR [0:31]
        ///Pointer to the data structure holding the AES key and the CCM NONCE vector (see Table 1 CCM data structure overview)
        cnfptr: u32 = 0,
    };
    ///Pointer to data structure holding AES key and NONCE vector
    pub const cnfptr = Register(cnfptr_val).init(0x4000F000 + 0x508);

    //////////////////////////
    ///INPTR
    const inptr_val = packed struct {
        ///INPTR [0:31]
        ///Input pointer
        inptr: u32 = 0,
    };
    ///Input pointer
    pub const inptr = Register(inptr_val).init(0x4000F000 + 0x50C);

    //////////////////////////
    ///OUTPTR
    const outptr_val = packed struct {
        ///OUTPTR [0:31]
        ///Output pointer
        outptr: u32 = 0,
    };
    ///Output pointer
    pub const outptr = Register(outptr_val).init(0x4000F000 + 0x510);

    //////////////////////////
    ///SCRATCHPTR
    const scratchptr_val = packed struct {
        ///SCRATCHPTR [0:31]
        ///Pointer to a scratch data area used for temporary storage during key-stream generation,
        ///MIC generation and encryption/decryption.
        scratchptr: u32 = 0,
    };
    ///Pointer to data area used for temporary storage
    pub const scratchptr = Register(scratchptr_val).init(0x4000F000 + 0x514);

    //////////////////////////
    ///MAXPACKETSIZE
    const maxpacketsize_val = packed struct {
        ///MAXPACKETSIZE [0:7]
        ///Length of key-stream generated when MODE.LENGTH = Extended. This value must be greater or equal to the subsequent packet payload to be encrypted/decrypted.
        maxpacketsize: u8 = 251,
        _unused8: u24 = 0,
    };
    ///Length of key-stream generated when MODE.LENGTH = Extended.
    pub const maxpacketsize = Register(maxpacketsize_val).init(0x4000F000 + 0x518);

    //////////////////////////
    ///RATEOVERRIDE
    const rateoverride_val = packed struct {
        ///RATEOVERRIDE [0:1]
        ///Data rate override setting.
        rateoverride: packed enum(u2) {
            ///1 Mbps
            _1mbit = 0,
            ///2 Mbps
            _2mbit = 1,
            ///125 Kbps
            _125kbps = 2,
            ///500 Kbps
            _500kbps = 3,
        } = ._1mbit,
        _unused2: u30 = 0,
    };
    ///Data rate override setting.
    pub const rateoverride = Register(rateoverride_val).init(0x4000F000 + 0x51C);
};

///Watchdog Timer
pub const wdt = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start the watchdog
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start the watchdog
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40010000 + 0x000);

    //////////////////////////
    ///EVENTS_TIMEOUT
    const events_timeout_val = packed struct {
        ///EVENTS_TIMEOUT [0:0]
        ///Watchdog timeout
        events_timeout: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Watchdog timeout
    pub const events_timeout = Register(events_timeout_val).init(0x40010000 + 0x100);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///TIMEOUT [0:0]
        ///Write '1' to enable interrupt for event TIMEOUT
        timeout: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    const intenset_val_write = packed struct {
        ///TIMEOUT [0:0]
        ///Write '1' to enable interrupt for event TIMEOUT
        timeout: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40010000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///TIMEOUT [0:0]
        ///Write '1' to disable interrupt for event TIMEOUT
        timeout: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    const intenclr_val_write = packed struct {
        ///TIMEOUT [0:0]
        ///Write '1' to disable interrupt for event TIMEOUT
        timeout: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40010000 + 0x308);

    //////////////////////////
    ///RUNSTATUS
    const runstatus_val = packed struct {
        ///RUNSTATUS [0:0]
        ///Indicates whether or not the watchdog is running
        runstatus: packed enum(u1) {
            ///Watchdog not running
            not_running = 0,
            ///Watchdog is running
            running = 1,
        } = .not_running,
        _unused1: u31 = 0,
    };
    ///Run status
    pub const runstatus = RegisterRW(runstatus_val, void).init(0x40010000 + 0x400);

    //////////////////////////
    ///REQSTATUS
    const reqstatus_val = packed struct {
        ///RR0 [0:0]
        ///Request status for RR[0] register
        rr0: packed enum(u1) {
            ///RR[0] register is not enabled, or are already requesting reload
            disabled_or_requested = 0,
            ///RR[0] register is enabled, and are not yet requesting reload
            enabled_and_unrequested = 1,
        } = .enabled_and_unrequested,
        ///RR1 [1:1]
        ///Request status for RR[1] register
        rr1: packed enum(u1) {
            ///RR[1] register is not enabled, or are already requesting reload
            disabled_or_requested = 0,
            ///RR[1] register is enabled, and are not yet requesting reload
            enabled_and_unrequested = 1,
        } = .disabled_or_requested,
        ///RR2 [2:2]
        ///Request status for RR[2] register
        rr2: packed enum(u1) {
            ///RR[2] register is not enabled, or are already requesting reload
            disabled_or_requested = 0,
            ///RR[2] register is enabled, and are not yet requesting reload
            enabled_and_unrequested = 1,
        } = .disabled_or_requested,
        ///RR3 [3:3]
        ///Request status for RR[3] register
        rr3: packed enum(u1) {
            ///RR[3] register is not enabled, or are already requesting reload
            disabled_or_requested = 0,
            ///RR[3] register is enabled, and are not yet requesting reload
            enabled_and_unrequested = 1,
        } = .disabled_or_requested,
        ///RR4 [4:4]
        ///Request status for RR[4] register
        rr4: packed enum(u1) {
            ///RR[4] register is not enabled, or are already requesting reload
            disabled_or_requested = 0,
            ///RR[4] register is enabled, and are not yet requesting reload
            enabled_and_unrequested = 1,
        } = .disabled_or_requested,
        ///RR5 [5:5]
        ///Request status for RR[5] register
        rr5: packed enum(u1) {
            ///RR[5] register is not enabled, or are already requesting reload
            disabled_or_requested = 0,
            ///RR[5] register is enabled, and are not yet requesting reload
            enabled_and_unrequested = 1,
        } = .disabled_or_requested,
        ///RR6 [6:6]
        ///Request status for RR[6] register
        rr6: packed enum(u1) {
            ///RR[6] register is not enabled, or are already requesting reload
            disabled_or_requested = 0,
            ///RR[6] register is enabled, and are not yet requesting reload
            enabled_and_unrequested = 1,
        } = .disabled_or_requested,
        ///RR7 [7:7]
        ///Request status for RR[7] register
        rr7: packed enum(u1) {
            ///RR[7] register is not enabled, or are already requesting reload
            disabled_or_requested = 0,
            ///RR[7] register is enabled, and are not yet requesting reload
            enabled_and_unrequested = 1,
        } = .disabled_or_requested,
        _unused8: u24 = 0,
    };
    ///Request status
    pub const reqstatus = RegisterRW(reqstatus_val, void).init(0x40010000 + 0x404);

    //////////////////////////
    ///CRV
    const crv_val = packed struct {
        ///CRV [0:31]
        ///Counter reload value in number of cycles of the 32.768 kHz clock
        crv: u32 = 4294967295,
    };
    ///Counter reload value
    pub const crv = Register(crv_val).init(0x40010000 + 0x504);

    //////////////////////////
    ///RREN
    const rren_val = packed struct {
        ///RR0 [0:0]
        ///Enable or disable RR[0] register
        rr0: packed enum(u1) {
            ///Disable RR[0] register
            disabled = 0,
            ///Enable RR[0] register
            enabled = 1,
        } = .enabled,
        ///RR1 [1:1]
        ///Enable or disable RR[1] register
        rr1: packed enum(u1) {
            ///Disable RR[1] register
            disabled = 0,
            ///Enable RR[1] register
            enabled = 1,
        } = .disabled,
        ///RR2 [2:2]
        ///Enable or disable RR[2] register
        rr2: packed enum(u1) {
            ///Disable RR[2] register
            disabled = 0,
            ///Enable RR[2] register
            enabled = 1,
        } = .disabled,
        ///RR3 [3:3]
        ///Enable or disable RR[3] register
        rr3: packed enum(u1) {
            ///Disable RR[3] register
            disabled = 0,
            ///Enable RR[3] register
            enabled = 1,
        } = .disabled,
        ///RR4 [4:4]
        ///Enable or disable RR[4] register
        rr4: packed enum(u1) {
            ///Disable RR[4] register
            disabled = 0,
            ///Enable RR[4] register
            enabled = 1,
        } = .disabled,
        ///RR5 [5:5]
        ///Enable or disable RR[5] register
        rr5: packed enum(u1) {
            ///Disable RR[5] register
            disabled = 0,
            ///Enable RR[5] register
            enabled = 1,
        } = .disabled,
        ///RR6 [6:6]
        ///Enable or disable RR[6] register
        rr6: packed enum(u1) {
            ///Disable RR[6] register
            disabled = 0,
            ///Enable RR[6] register
            enabled = 1,
        } = .disabled,
        ///RR7 [7:7]
        ///Enable or disable RR[7] register
        rr7: packed enum(u1) {
            ///Disable RR[7] register
            disabled = 0,
            ///Enable RR[7] register
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    ///Enable register for reload request registers
    pub const rren = Register(rren_val).init(0x40010000 + 0x508);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///SLEEP [0:0]
        ///Configure the watchdog to either be paused, or kept running, while the CPU is sleeping
        sleep: packed enum(u1) {
            ///Pause watchdog while the CPU is sleeping
            pause = 0,
            ///Keep the watchdog running while the CPU is sleeping
            run = 1,
        } = .run,
        _unused1: u2 = 0,
        ///HALT [3:3]
        ///Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger
        halt: packed enum(u1) {
            ///Pause watchdog while the CPU is halted by the debugger
            pause = 0,
            ///Keep the watchdog running while the CPU is halted by the debugger
            run = 1,
        } = .pause,
        _unused4: u28 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x40010000 + 0x50C);

    //////////////////////////
    ///RR[%s]
    const rr_val = packed struct {
        ///RR [0:31]
        ///Reload request register
        rr: packed enum(u32) {
            ///Value to request a reload of the watchdog timer
            reload = 0x6E524635,
            _zero = 0,
        } = ._zero,
    };
    ///Description collection: Reload request n
    pub const rr = RegisterRW(void, rr_val).initRange(0x40010000 + 0x600, 4, 8);
};

///Real time counter 1
pub const rtc1 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start RTC COUNTER
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start RTC COUNTER
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40011000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop RTC COUNTER
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop RTC COUNTER
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40011000 + 0x004);

    //////////////////////////
    ///TASKS_CLEAR
    const tasks_clear_val = packed struct {
        ///TASKS_CLEAR [0:0]
        ///Clear RTC COUNTER
        tasks_clear: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Clear RTC COUNTER
    pub const tasks_clear = RegisterRW(void, tasks_clear_val).init(0x40011000 + 0x008);

    //////////////////////////
    ///TASKS_TRIGOVRFLW
    const tasks_trigovrflw_val = packed struct {
        ///TASKS_TRIGOVRFLW [0:0]
        ///Set COUNTER to 0xFFFFF0
        tasks_trigovrflw: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Set COUNTER to 0xFFFFF0
    pub const tasks_trigovrflw = RegisterRW(void, tasks_trigovrflw_val).init(0x40011000 + 0x00C);

    //////////////////////////
    ///EVENTS_TICK
    const events_tick_val = packed struct {
        ///EVENTS_TICK [0:0]
        ///Event on COUNTER increment
        events_tick: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Event on COUNTER increment
    pub const events_tick = Register(events_tick_val).init(0x40011000 + 0x100);

    //////////////////////////
    ///EVENTS_OVRFLW
    const events_ovrflw_val = packed struct {
        ///EVENTS_OVRFLW [0:0]
        ///Event on COUNTER overflow
        events_ovrflw: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Event on COUNTER overflow
    pub const events_ovrflw = Register(events_ovrflw_val).init(0x40011000 + 0x104);

    //////////////////////////
    ///EVENTS_COMPARE[%s]
    const events_compare_val = packed struct {
        ///EVENTS_COMPARE [0:0]
        ///Compare event on CC[n] match
        events_compare: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Compare event on CC[n] match
    pub const events_compare = Register(events_compare_val).initRange(0x40011000 + 0x140, 4, 4);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable interrupt for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to enable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenset_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable interrupt for event TICK
        tick: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to enable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40011000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable interrupt for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to disable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenclr_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable interrupt for event TICK
        tick: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to disable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40011000 + 0x308);

    //////////////////////////
    ///EVTEN
    const evten_val = packed struct {
        ///TICK [0:0]
        ///Enable or disable event routing for event TICK
        tick: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Enable or disable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Enable or disable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Enable or disable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Enable or disable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Enable or disable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    ///Enable or disable event routing
    pub const evten = Register(evten_val).init(0x40011000 + 0x340);

    //////////////////////////
    ///EVTENSET
    const evtenset_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable event routing for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to enable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const evtenset_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable event routing for event TICK
        tick: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to enable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Enable event routing
    pub const evtenset = RegisterRW(evtenset_val_read, evtenset_val_write).init(0x40011000 + 0x344);

    //////////////////////////
    ///EVTENCLR
    const evtenclr_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable event routing for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to disable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const evtenclr_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable event routing for event TICK
        tick: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to disable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Disable event routing
    pub const evtenclr = RegisterRW(evtenclr_val_read, evtenclr_val_write).init(0x40011000 + 0x348);

    //////////////////////////
    ///COUNTER
    const counter_val = packed struct {
        ///COUNTER [0:23]
        ///Counter value
        counter: u24 = 0,
        _unused24: u8 = 0,
    };
    ///Current COUNTER value
    pub const counter = RegisterRW(counter_val, void).init(0x40011000 + 0x504);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:11]
        ///Prescaler value
        prescaler: u12 = 0,
        _unused12: u20 = 0,
    };
    ///12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped
    pub const prescaler = Register(prescaler_val).init(0x40011000 + 0x508);

    //////////////////////////
    ///CC[%s]
    const cc_val = packed struct {
        ///COMPARE [0:23]
        ///Compare value
        compare: u24 = 0,
        _unused24: u8 = 0,
    };
    ///Description collection: Compare register n
    pub const cc = Register(cc_val).initRange(0x40011000 + 0x540, 4, 4);
};

///Quadrature Decoder
pub const qdec = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Task starting the quadrature decoder
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Task starting the quadrature decoder
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40012000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Task stopping the quadrature decoder
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Task stopping the quadrature decoder
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40012000 + 0x004);

    //////////////////////////
    ///TASKS_READCLRACC
    const tasks_readclracc_val = packed struct {
        ///TASKS_READCLRACC [0:0]
        ///Read and clear ACC and ACCDBL
        tasks_readclracc: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Read and clear ACC and ACCDBL
    pub const tasks_readclracc = RegisterRW(void, tasks_readclracc_val).init(0x40012000 + 0x008);

    //////////////////////////
    ///TASKS_RDCLRACC
    const tasks_rdclracc_val = packed struct {
        ///TASKS_RDCLRACC [0:0]
        ///Read and clear ACC
        tasks_rdclracc: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Read and clear ACC
    pub const tasks_rdclracc = RegisterRW(void, tasks_rdclracc_val).init(0x40012000 + 0x00C);

    //////////////////////////
    ///TASKS_RDCLRDBL
    const tasks_rdclrdbl_val = packed struct {
        ///TASKS_RDCLRDBL [0:0]
        ///Read and clear ACCDBL
        tasks_rdclrdbl: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Read and clear ACCDBL
    pub const tasks_rdclrdbl = RegisterRW(void, tasks_rdclrdbl_val).init(0x40012000 + 0x010);

    //////////////////////////
    ///EVENTS_SAMPLERDY
    const events_samplerdy_val = packed struct {
        ///EVENTS_SAMPLERDY [0:0]
        ///Event being generated for every new sample value written to the SAMPLE register
        events_samplerdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Event being generated for every new sample value written to the SAMPLE register
    pub const events_samplerdy = Register(events_samplerdy_val).init(0x40012000 + 0x100);

    //////////////////////////
    ///EVENTS_REPORTRDY
    const events_reportrdy_val = packed struct {
        ///EVENTS_REPORTRDY [0:0]
        ///Non-null report ready
        events_reportrdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Non-null report ready
    pub const events_reportrdy = Register(events_reportrdy_val).init(0x40012000 + 0x104);

    //////////////////////////
    ///EVENTS_ACCOF
    const events_accof_val = packed struct {
        ///EVENTS_ACCOF [0:0]
        ///ACC or ACCDBL register overflow
        events_accof: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///ACC or ACCDBL register overflow
    pub const events_accof = Register(events_accof_val).init(0x40012000 + 0x108);

    //////////////////////////
    ///EVENTS_DBLRDY
    const events_dblrdy_val = packed struct {
        ///EVENTS_DBLRDY [0:0]
        ///Double displacement(s) detected
        events_dblrdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Double displacement(s) detected
    pub const events_dblrdy = Register(events_dblrdy_val).init(0x40012000 + 0x10C);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///QDEC has been stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///QDEC has been stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40012000 + 0x110);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///REPORTRDY_READCLRACC [0:0]
        ///Shortcut between event REPORTRDY and task READCLRACC
        reportrdy_readclracc: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///SAMPLERDY_STOP [1:1]
        ///Shortcut between event SAMPLERDY and task STOP
        samplerdy_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///REPORTRDY_RDCLRACC [2:2]
        ///Shortcut between event REPORTRDY and task RDCLRACC
        reportrdy_rdclracc: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///REPORTRDY_STOP [3:3]
        ///Shortcut between event REPORTRDY and task STOP
        reportrdy_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///DBLRDY_RDCLRDBL [4:4]
        ///Shortcut between event DBLRDY and task RDCLRDBL
        dblrdy_rdclrdbl: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///DBLRDY_STOP [5:5]
        ///Shortcut between event DBLRDY and task STOP
        dblrdy_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///SAMPLERDY_READCLRACC [6:6]
        ///Shortcut between event SAMPLERDY and task READCLRACC
        samplerdy_readclracc: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused7: u25 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40012000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///SAMPLERDY [0:0]
        ///Write '1' to enable interrupt for event SAMPLERDY
        samplerdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REPORTRDY [1:1]
        ///Write '1' to enable interrupt for event REPORTRDY
        reportrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ACCOF [2:2]
        ///Write '1' to enable interrupt for event ACCOF
        accof: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DBLRDY [3:3]
        ///Write '1' to enable interrupt for event DBLRDY
        dblrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STOPPED [4:4]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u27 = 0,
    };
    const intenset_val_write = packed struct {
        ///SAMPLERDY [0:0]
        ///Write '1' to enable interrupt for event SAMPLERDY
        samplerdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REPORTRDY [1:1]
        ///Write '1' to enable interrupt for event REPORTRDY
        reportrdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ACCOF [2:2]
        ///Write '1' to enable interrupt for event ACCOF
        accof: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///DBLRDY [3:3]
        ///Write '1' to enable interrupt for event DBLRDY
        dblrdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///STOPPED [4:4]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u27 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40012000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///SAMPLERDY [0:0]
        ///Write '1' to disable interrupt for event SAMPLERDY
        samplerdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REPORTRDY [1:1]
        ///Write '1' to disable interrupt for event REPORTRDY
        reportrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ACCOF [2:2]
        ///Write '1' to disable interrupt for event ACCOF
        accof: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DBLRDY [3:3]
        ///Write '1' to disable interrupt for event DBLRDY
        dblrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STOPPED [4:4]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u27 = 0,
    };
    const intenclr_val_write = packed struct {
        ///SAMPLERDY [0:0]
        ///Write '1' to disable interrupt for event SAMPLERDY
        samplerdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REPORTRDY [1:1]
        ///Write '1' to disable interrupt for event REPORTRDY
        reportrdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ACCOF [2:2]
        ///Write '1' to disable interrupt for event ACCOF
        accof: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///DBLRDY [3:3]
        ///Write '1' to disable interrupt for event DBLRDY
        dblrdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///STOPPED [4:4]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u27 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40012000 + 0x308);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:0]
        ///Enable or disable the quadrature decoder
        enable: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Enable the quadrature decoder
    pub const enable = Register(enable_val).init(0x40012000 + 0x500);

    //////////////////////////
    ///LEDPOL
    const ledpol_val = packed struct {
        ///LEDPOL [0:0]
        ///LED output pin polarity
        ledpol: packed enum(u1) {
            ///Led active on output pin low
            active_low = 0,
            ///Led active on output pin high
            active_high = 1,
        } = .active_low,
        _unused1: u31 = 0,
    };
    ///LED output pin polarity
    pub const ledpol = Register(ledpol_val).init(0x40012000 + 0x504);

    //////////////////////////
    ///SAMPLEPER
    const sampleper_val = packed struct {
        ///SAMPLEPER [0:3]
        ///Sample period. The SAMPLE register will be updated for every new sample
        sampleper: packed enum(u4) {
            ///128 us
            _128us = 0,
            ///256 us
            _256us = 1,
            ///512 us
            _512us = 2,
            ///1024 us
            _1024us = 3,
            ///2048 us
            _2048us = 4,
            ///4096 us
            _4096us = 5,
            ///8192 us
            _8192us = 6,
            ///16384 us
            _16384us = 7,
            ///32768 us
            _32ms = 8,
            ///65536 us
            _65ms = 9,
            ///131072 us
            _131ms = 10,
        } = ._128us,
        _unused4: u28 = 0,
    };
    ///Sample period
    pub const sampleper = Register(sampleper_val).init(0x40012000 + 0x508);

    //////////////////////////
    ///SAMPLE
    const sample_val = packed struct {
        ///SAMPLE [0:31]
        ///Last motion sample
        sample: u32 = 0,
    };
    ///Motion sample value
    pub const sample = RegisterRW(sample_val, void).init(0x40012000 + 0x50C);

    //////////////////////////
    ///REPORTPER
    const reportper_val = packed struct {
        ///REPORTPER [0:3]
        ///Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated
        reportper: packed enum(u4) {
            ///10 samples / report
            _10smpl = 0,
            ///40 samples / report
            _40smpl = 1,
            ///80 samples / report
            _80smpl = 2,
            ///120 samples / report
            _120smpl = 3,
            ///160 samples / report
            _160smpl = 4,
            ///200 samples / report
            _200smpl = 5,
            ///240 samples / report
            _240smpl = 6,
            ///280 samples / report
            _280smpl = 7,
            ///1 sample / report
            _1smpl = 8,
        } = ._10smpl,
        _unused4: u28 = 0,
    };
    ///Number of samples to be taken before REPORTRDY and DBLRDY events can be generated
    pub const reportper = Register(reportper_val).init(0x40012000 + 0x510);

    //////////////////////////
    ///ACC
    const acc_val = packed struct {
        ///ACC [0:31]
        ///Register accumulating all valid samples (not double transition) read from the SAMPLE register
        acc: u32 = 0,
    };
    ///Register accumulating the valid transitions
    pub const acc = RegisterRW(acc_val, void).init(0x40012000 + 0x514);

    //////////////////////////
    ///ACCREAD
    const accread_val = packed struct {
        ///ACCREAD [0:31]
        ///Snapshot of the ACC register.
        accread: u32 = 0,
    };
    ///Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task
    pub const accread = RegisterRW(accread_val, void).init(0x40012000 + 0x518);

    //////////////////////////
    ///DBFEN
    const dbfen_val = packed struct {
        ///DBFEN [0:0]
        ///Enable input debounce filters
        dbfen: packed enum(u1) {
            ///Debounce input filters disabled
            disabled = 0,
            ///Debounce input filters enabled
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Enable input debounce filters
    pub const dbfen = Register(dbfen_val).init(0x40012000 + 0x528);

    //////////////////////////
    ///LEDPRE
    const ledpre_val = packed struct {
        ///LEDPRE [0:8]
        ///Period in us the LED is switched on prior to sampling
        ledpre: u9 = 16,
        _unused9: u23 = 0,
    };
    ///Time period the LED is switched ON prior to sampling
    pub const ledpre = Register(ledpre_val).init(0x40012000 + 0x540);

    //////////////////////////
    ///ACCDBL
    const accdbl_val = packed struct {
        ///ACCDBL [0:3]
        ///Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 ).
        accdbl: u4 = 0,
        _unused4: u28 = 0,
    };
    ///Register accumulating the number of detected double transitions
    pub const accdbl = RegisterRW(accdbl_val, void).init(0x40012000 + 0x544);

    //////////////////////////
    ///ACCDBLREAD
    const accdblread_val = packed struct {
        ///ACCDBLREAD [0:3]
        ///Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered.
        accdblread: u4 = 0,
        _unused4: u28 = 0,
    };
    ///Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task
    pub const accdblread = RegisterRW(accdblread_val, void).init(0x40012000 + 0x548);
};

///Comparator
pub const comp = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start comparator
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start comparator
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40013000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop comparator
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop comparator
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40013000 + 0x004);

    //////////////////////////
    ///TASKS_SAMPLE
    const tasks_sample_val = packed struct {
        ///TASKS_SAMPLE [0:0]
        ///Sample comparator value
        tasks_sample: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Sample comparator value
    pub const tasks_sample = RegisterRW(void, tasks_sample_val).init(0x40013000 + 0x008);

    //////////////////////////
    ///EVENTS_READY
    const events_ready_val = packed struct {
        ///EVENTS_READY [0:0]
        ///COMP is ready and output is valid
        events_ready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///COMP is ready and output is valid
    pub const events_ready = Register(events_ready_val).init(0x40013000 + 0x100);

    //////////////////////////
    ///EVENTS_DOWN
    const events_down_val = packed struct {
        ///EVENTS_DOWN [0:0]
        ///Downward crossing
        events_down: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Downward crossing
    pub const events_down = Register(events_down_val).init(0x40013000 + 0x104);

    //////////////////////////
    ///EVENTS_UP
    const events_up_val = packed struct {
        ///EVENTS_UP [0:0]
        ///Upward crossing
        events_up: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Upward crossing
    pub const events_up = Register(events_up_val).init(0x40013000 + 0x108);

    //////////////////////////
    ///EVENTS_CROSS
    const events_cross_val = packed struct {
        ///EVENTS_CROSS [0:0]
        ///Downward or upward crossing
        events_cross: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Downward or upward crossing
    pub const events_cross = Register(events_cross_val).init(0x40013000 + 0x10C);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///READY_SAMPLE [0:0]
        ///Shortcut between event READY and task SAMPLE
        ready_sample: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///READY_STOP [1:1]
        ///Shortcut between event READY and task STOP
        ready_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///DOWN_STOP [2:2]
        ///Shortcut between event DOWN and task STOP
        down_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///UP_STOP [3:3]
        ///Shortcut between event UP and task STOP
        up_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///CROSS_STOP [4:4]
        ///Shortcut between event CROSS and task STOP
        cross_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused5: u27 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40013000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///READY [0:0]
        ///Enable or disable interrupt for event READY
        ready: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///DOWN [1:1]
        ///Enable or disable interrupt for event DOWN
        down: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///UP [2:2]
        ///Enable or disable interrupt for event UP
        up: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///CROSS [3:3]
        ///Enable or disable interrupt for event CROSS
        cross: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40013000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///READY [0:0]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DOWN [1:1]
        ///Write '1' to enable interrupt for event DOWN
        down: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///UP [2:2]
        ///Write '1' to enable interrupt for event UP
        up: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CROSS [3:3]
        ///Write '1' to enable interrupt for event CROSS
        cross: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused4: u28 = 0,
    };
    const intenset_val_write = packed struct {
        ///READY [0:0]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///DOWN [1:1]
        ///Write '1' to enable interrupt for event DOWN
        down: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///UP [2:2]
        ///Write '1' to enable interrupt for event UP
        up: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CROSS [3:3]
        ///Write '1' to enable interrupt for event CROSS
        cross: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused4: u28 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40013000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///READY [0:0]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DOWN [1:1]
        ///Write '1' to disable interrupt for event DOWN
        down: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///UP [2:2]
        ///Write '1' to disable interrupt for event UP
        up: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CROSS [3:3]
        ///Write '1' to disable interrupt for event CROSS
        cross: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused4: u28 = 0,
    };
    const intenclr_val_write = packed struct {
        ///READY [0:0]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///DOWN [1:1]
        ///Write '1' to disable interrupt for event DOWN
        down: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///UP [2:2]
        ///Write '1' to disable interrupt for event UP
        up: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CROSS [3:3]
        ///Write '1' to disable interrupt for event CROSS
        cross: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused4: u28 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40013000 + 0x308);

    //////////////////////////
    ///RESULT
    const result_val = packed struct {
        ///RESULT [0:0]
        ///Result of last compare. Decision point SAMPLE task.
        result: packed enum(u1) {
            ///Input voltage is below the threshold (VIN+ &lt; VIN-)
            below = 0,
            ///Input voltage is above the threshold (VIN+ &gt; VIN-)
            above = 1,
        } = .below,
        _unused1: u31 = 0,
    };
    ///Compare result
    pub const result = RegisterRW(result_val, void).init(0x40013000 + 0x400);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:1]
        ///Enable or disable COMP
        enable: packed enum(u2) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 2,
        } = .disabled,
        _unused2: u30 = 0,
    };
    ///COMP enable
    pub const enable = Register(enable_val).init(0x40013000 + 0x500);

    //////////////////////////
    ///PSEL
    const psel_val = packed struct {
        ///PSEL [0:2]
        ///Analog pin select
        psel: packed enum(u3) {
            ///AIN0 selected as analog input
            analog_input0 = 0,
            ///AIN1 selected as analog input
            analog_input1 = 1,
            ///AIN2 selected as analog input
            analog_input2 = 2,
            ///AIN3 selected as analog input
            analog_input3 = 3,
            ///AIN4 selected as analog input
            analog_input4 = 4,
            ///AIN5 selected as analog input
            analog_input5 = 5,
            ///AIN6 selected as analog input
            analog_input6 = 6,
            ///AIN7 selected as analog input
            analog_input7 = 7,
        } = .analog_input0,
        _unused3: u29 = 0,
    };
    ///Pin select
    pub const psel = Register(psel_val).init(0x40013000 + 0x504);

    //////////////////////////
    ///REFSEL
    const refsel_val = packed struct {
        ///REFSEL [0:2]
        ///Reference select
        refsel: packed enum(u3) {
            ///VREF = internal 1.2 V reference (VDD &gt;= 1.7 V)
            int1v2 = 0,
            ///VREF = internal 1.8 V reference (VDD &gt;= VREF + 0.2 V)
            int1v8 = 1,
            ///VREF = internal 2.4 V reference (VDD &gt;= VREF + 0.2 V)
            int2v4 = 2,
            ///VREF = VDD
            vdd = 4,
            ///VREF = AREF
            aref = 5,
        } = .vdd,
        _unused3: u29 = 0,
    };
    ///Reference source select for single-ended mode
    pub const refsel = Register(refsel_val).init(0x40013000 + 0x508);

    //////////////////////////
    ///EXTREFSEL
    const extrefsel_val = packed struct {
        ///EXTREFSEL [0:2]
        ///External analog reference select
        extrefsel: packed enum(u3) {
            ///Use AIN0 as external analog reference
            analog_reference0 = 0,
            ///Use AIN1 as external analog reference
            analog_reference1 = 1,
            ///Use AIN2 as external analog reference
            analog_reference2 = 2,
            ///Use AIN3 as external analog reference
            analog_reference3 = 3,
            ///Use AIN4 as external analog reference
            analog_reference4 = 4,
            ///Use AIN5 as external analog reference
            analog_reference5 = 5,
            ///Use AIN6 as external analog reference
            analog_reference6 = 6,
            ///Use AIN7 as external analog reference
            analog_reference7 = 7,
        } = .analog_reference0,
        _unused3: u29 = 0,
    };
    ///External reference select
    pub const extrefsel = Register(extrefsel_val).init(0x40013000 + 0x50C);

    //////////////////////////
    ///TH
    const th_val = packed struct {
        ///THDOWN [0:5]
        ///VDOWN = (THDOWN+1)/64*VREF
        thdown: u6 = 0,
        _unused6: u2 = 0,
        ///THUP [8:13]
        ///VUP = (THUP+1)/64*VREF
        thup: u6 = 0,
        _unused14: u18 = 0,
    };
    ///Threshold configuration for hysteresis unit
    pub const th = Register(th_val).init(0x40013000 + 0x530);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///SP [0:1]
        ///Speed and power modes
        sp: packed enum(u2) {
            ///Low-power mode
            low = 0,
            ///Normal mode
            normal = 1,
            ///High-speed mode
            high = 2,
        } = .low,
        _unused2: u6 = 0,
        ///MAIN [8:8]
        ///Main operation modes
        main: packed enum(u1) {
            ///Single-ended mode
            se = 0,
            ///Differential mode
            diff = 1,
        } = .se,
        _unused9: u23 = 0,
    };
    ///Mode configuration
    pub const mode = Register(mode_val).init(0x40013000 + 0x534);

    //////////////////////////
    ///HYST
    const hyst_val = packed struct {
        ///HYST [0:0]
        ///Comparator hysteresis
        hyst: packed enum(u1) {
            ///Comparator hysteresis disabled
            no_hyst = 0,
            ///Comparator hysteresis enabled
            hyst50m_v = 1,
        } = .no_hyst,
        _unused1: u31 = 0,
    };
    ///Comparator hysteresis enable
    pub const hyst = Register(hyst_val).init(0x40013000 + 0x538);
};

///Low-power comparator
pub const lpcomp = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start comparator
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start comparator
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40013000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop comparator
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop comparator
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40013000 + 0x004);

    //////////////////////////
    ///TASKS_SAMPLE
    const tasks_sample_val = packed struct {
        ///TASKS_SAMPLE [0:0]
        ///Sample comparator value
        tasks_sample: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Sample comparator value
    pub const tasks_sample = RegisterRW(void, tasks_sample_val).init(0x40013000 + 0x008);

    //////////////////////////
    ///EVENTS_READY
    const events_ready_val = packed struct {
        ///EVENTS_READY [0:0]
        ///LPCOMP is ready and output is valid
        events_ready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///LPCOMP is ready and output is valid
    pub const events_ready = Register(events_ready_val).init(0x40013000 + 0x100);

    //////////////////////////
    ///EVENTS_DOWN
    const events_down_val = packed struct {
        ///EVENTS_DOWN [0:0]
        ///Downward crossing
        events_down: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Downward crossing
    pub const events_down = Register(events_down_val).init(0x40013000 + 0x104);

    //////////////////////////
    ///EVENTS_UP
    const events_up_val = packed struct {
        ///EVENTS_UP [0:0]
        ///Upward crossing
        events_up: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Upward crossing
    pub const events_up = Register(events_up_val).init(0x40013000 + 0x108);

    //////////////////////////
    ///EVENTS_CROSS
    const events_cross_val = packed struct {
        ///EVENTS_CROSS [0:0]
        ///Downward or upward crossing
        events_cross: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Downward or upward crossing
    pub const events_cross = Register(events_cross_val).init(0x40013000 + 0x10C);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///READY_SAMPLE [0:0]
        ///Shortcut between event READY and task SAMPLE
        ready_sample: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///READY_STOP [1:1]
        ///Shortcut between event READY and task STOP
        ready_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///DOWN_STOP [2:2]
        ///Shortcut between event DOWN and task STOP
        down_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///UP_STOP [3:3]
        ///Shortcut between event UP and task STOP
        up_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///CROSS_STOP [4:4]
        ///Shortcut between event CROSS and task STOP
        cross_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused5: u27 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40013000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///READY [0:0]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DOWN [1:1]
        ///Write '1' to enable interrupt for event DOWN
        down: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///UP [2:2]
        ///Write '1' to enable interrupt for event UP
        up: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CROSS [3:3]
        ///Write '1' to enable interrupt for event CROSS
        cross: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused4: u28 = 0,
    };
    const intenset_val_write = packed struct {
        ///READY [0:0]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///DOWN [1:1]
        ///Write '1' to enable interrupt for event DOWN
        down: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///UP [2:2]
        ///Write '1' to enable interrupt for event UP
        up: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CROSS [3:3]
        ///Write '1' to enable interrupt for event CROSS
        cross: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused4: u28 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40013000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///READY [0:0]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///DOWN [1:1]
        ///Write '1' to disable interrupt for event DOWN
        down: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///UP [2:2]
        ///Write '1' to disable interrupt for event UP
        up: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///CROSS [3:3]
        ///Write '1' to disable interrupt for event CROSS
        cross: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused4: u28 = 0,
    };
    const intenclr_val_write = packed struct {
        ///READY [0:0]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///DOWN [1:1]
        ///Write '1' to disable interrupt for event DOWN
        down: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///UP [2:2]
        ///Write '1' to disable interrupt for event UP
        up: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CROSS [3:3]
        ///Write '1' to disable interrupt for event CROSS
        cross: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused4: u28 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40013000 + 0x308);

    //////////////////////////
    ///RESULT
    const result_val = packed struct {
        ///RESULT [0:0]
        ///Result of last compare. Decision point SAMPLE task.
        result: packed enum(u1) {
            ///Input voltage is below the reference threshold (VIN+ &lt; VIN-)
            below = 0,
            ///Input voltage is above the reference threshold (VIN+ &gt; VIN-)
            above = 1,
        } = .below,
        _unused1: u31 = 0,
    };
    ///Compare result
    pub const result = RegisterRW(result_val, void).init(0x40013000 + 0x400);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:1]
        ///Enable or disable LPCOMP
        enable: packed enum(u2) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused2: u30 = 0,
    };
    ///Enable LPCOMP
    pub const enable = Register(enable_val).init(0x40013000 + 0x500);

    //////////////////////////
    ///PSEL
    const psel_val = packed struct {
        ///PSEL [0:2]
        ///Analog pin select
        psel: packed enum(u3) {
            ///AIN0 selected as analog input
            analog_input0 = 0,
            ///AIN1 selected as analog input
            analog_input1 = 1,
            ///AIN2 selected as analog input
            analog_input2 = 2,
            ///AIN3 selected as analog input
            analog_input3 = 3,
            ///AIN4 selected as analog input
            analog_input4 = 4,
            ///AIN5 selected as analog input
            analog_input5 = 5,
            ///AIN6 selected as analog input
            analog_input6 = 6,
            ///AIN7 selected as analog input
            analog_input7 = 7,
        } = .analog_input0,
        _unused3: u29 = 0,
    };
    ///Input pin select
    pub const psel = Register(psel_val).init(0x40013000 + 0x504);

    //////////////////////////
    ///REFSEL
    const refsel_val = packed struct {
        ///REFSEL [0:3]
        ///Reference select
        refsel: packed enum(u4) {
            ///VDD * 1/8 selected as reference
            ref1_8vdd = 0,
            ///VDD * 2/8 selected as reference
            ref2_8vdd = 1,
            ///VDD * 3/8 selected as reference
            ref3_8vdd = 2,
            ///VDD * 4/8 selected as reference
            ref4_8vdd = 3,
            ///VDD * 5/8 selected as reference
            ref5_8vdd = 4,
            ///VDD * 6/8 selected as reference
            ref6_8vdd = 5,
            ///VDD * 7/8 selected as reference
            ref7_8vdd = 6,
            ///External analog reference selected
            aref = 7,
            ///VDD * 1/16 selected as reference
            ref1_16vdd = 8,
            ///VDD * 3/16 selected as reference
            ref3_16vdd = 9,
            ///VDD * 5/16 selected as reference
            ref5_16vdd = 10,
            ///VDD * 7/16 selected as reference
            ref7_16vdd = 11,
            ///VDD * 9/16 selected as reference
            ref9_16vdd = 12,
            ///VDD * 11/16 selected as reference
            ref11_16vdd = 13,
            ///VDD * 13/16 selected as reference
            ref13_16vdd = 14,
            ///VDD * 15/16 selected as reference
            ref15_16vdd = 15,
        } = .ref5_8vdd,
        _unused4: u28 = 0,
    };
    ///Reference select
    pub const refsel = Register(refsel_val).init(0x40013000 + 0x508);

    //////////////////////////
    ///EXTREFSEL
    const extrefsel_val = packed struct {
        ///EXTREFSEL [0:0]
        ///External analog reference select
        extrefsel: packed enum(u1) {
            ///Use AIN0 as external analog reference
            analog_reference0 = 0,
            ///Use AIN1 as external analog reference
            analog_reference1 = 1,
        } = .analog_reference0,
        _unused1: u31 = 0,
    };
    ///External reference select
    pub const extrefsel = Register(extrefsel_val).init(0x40013000 + 0x50C);

    //////////////////////////
    ///ANADETECT
    const anadetect_val = packed struct {
        ///ANADETECT [0:1]
        ///Analog detect configuration
        anadetect: packed enum(u2) {
            ///Generate ANADETECT on crossing, both upward crossing and downward crossing
            cross = 0,
            ///Generate ANADETECT on upward crossing only
            up = 1,
            ///Generate ANADETECT on downward crossing only
            down = 2,
        } = .cross,
        _unused2: u30 = 0,
    };
    ///Analog detect configuration
    pub const anadetect = Register(anadetect_val).init(0x40013000 + 0x520);

    //////////////////////////
    ///HYST
    const hyst_val = packed struct {
        ///HYST [0:0]
        ///Comparator hysteresis enable
        hyst: packed enum(u1) {
            ///Comparator hysteresis disabled
            disabled = 0,
            ///Comparator hysteresis enabled
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Comparator hysteresis enable
    pub const hyst = Register(hyst_val).init(0x40013000 + 0x538);
};

///Event generator unit 0
pub const egu0 = struct {

    //////////////////////////
    ///TASKS_TRIGGER[%s]
    const tasks_trigger_val = packed struct {
        ///TASKS_TRIGGER [0:0]
        ///Trigger n for triggering the corresponding TRIGGERED[n] event
        tasks_trigger: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event
    pub const tasks_trigger = RegisterRW(void, tasks_trigger_val).initRange(0x40014000 + 0x000, 4, 16);

    //////////////////////////
    ///EVENTS_TRIGGERED[%s]
    const events_triggered_val = packed struct {
        ///EVENTS_TRIGGERED [0:0]
        ///Event number n generated by triggering the corresponding TRIGGER[n] task
        events_triggered: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task
    pub const events_triggered = Register(events_triggered_val).initRange(0x40014000 + 0x100, 4, 16);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///TRIGGERED0 [0:0]
        ///Enable or disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Enable or disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Enable or disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Enable or disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Enable or disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Enable or disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Enable or disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Enable or disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Enable or disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Enable or disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Enable or disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Enable or disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Enable or disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Enable or disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Enable or disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Enable or disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40014000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenset_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40014000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenclr_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40014000 + 0x308);
};

///Software interrupt 0
pub const swi0 = struct {

    //////////////////////////
    ///UNUSED
    const unused_val = packed struct {
        _unused0: u32 = 0,
    };
    ///Unused.
    pub const unused = RegisterRW(unused_val, void).init(0x40014000 + 0x000);
};

///Event generator unit 1
pub const egu1 = struct {

    //////////////////////////
    ///TASKS_TRIGGER[%s]
    const tasks_trigger_val = packed struct {
        ///TASKS_TRIGGER [0:0]
        ///Trigger n for triggering the corresponding TRIGGERED[n] event
        tasks_trigger: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event
    pub const tasks_trigger = RegisterRW(void, tasks_trigger_val).initRange(0x40015000 + 0x000, 4, 16);

    //////////////////////////
    ///EVENTS_TRIGGERED[%s]
    const events_triggered_val = packed struct {
        ///EVENTS_TRIGGERED [0:0]
        ///Event number n generated by triggering the corresponding TRIGGER[n] task
        events_triggered: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task
    pub const events_triggered = Register(events_triggered_val).initRange(0x40015000 + 0x100, 4, 16);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///TRIGGERED0 [0:0]
        ///Enable or disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Enable or disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Enable or disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Enable or disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Enable or disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Enable or disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Enable or disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Enable or disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Enable or disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Enable or disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Enable or disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Enable or disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Enable or disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Enable or disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Enable or disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Enable or disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40015000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenset_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40015000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenclr_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40015000 + 0x308);
};

///Software interrupt 1
pub const swi1 = struct {

    //////////////////////////
    ///UNUSED
    const unused_val = packed struct {
        _unused0: u32 = 0,
    };
    ///Unused.
    pub const unused = RegisterRW(unused_val, void).init(0x40015000 + 0x000);
};

///Event generator unit 2
pub const egu2 = struct {

    //////////////////////////
    ///TASKS_TRIGGER[%s]
    const tasks_trigger_val = packed struct {
        ///TASKS_TRIGGER [0:0]
        ///Trigger n for triggering the corresponding TRIGGERED[n] event
        tasks_trigger: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event
    pub const tasks_trigger = RegisterRW(void, tasks_trigger_val).initRange(0x40016000 + 0x000, 4, 16);

    //////////////////////////
    ///EVENTS_TRIGGERED[%s]
    const events_triggered_val = packed struct {
        ///EVENTS_TRIGGERED [0:0]
        ///Event number n generated by triggering the corresponding TRIGGER[n] task
        events_triggered: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task
    pub const events_triggered = Register(events_triggered_val).initRange(0x40016000 + 0x100, 4, 16);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///TRIGGERED0 [0:0]
        ///Enable or disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Enable or disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Enable or disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Enable or disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Enable or disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Enable or disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Enable or disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Enable or disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Enable or disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Enable or disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Enable or disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Enable or disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Enable or disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Enable or disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Enable or disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Enable or disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40016000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenset_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40016000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenclr_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40016000 + 0x308);
};

///Software interrupt 2
pub const swi2 = struct {

    //////////////////////////
    ///UNUSED
    const unused_val = packed struct {
        _unused0: u32 = 0,
    };
    ///Unused.
    pub const unused = RegisterRW(unused_val, void).init(0x40016000 + 0x000);
};

///Event generator unit 3
pub const egu3 = struct {

    //////////////////////////
    ///TASKS_TRIGGER[%s]
    const tasks_trigger_val = packed struct {
        ///TASKS_TRIGGER [0:0]
        ///Trigger n for triggering the corresponding TRIGGERED[n] event
        tasks_trigger: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event
    pub const tasks_trigger = RegisterRW(void, tasks_trigger_val).initRange(0x40017000 + 0x000, 4, 16);

    //////////////////////////
    ///EVENTS_TRIGGERED[%s]
    const events_triggered_val = packed struct {
        ///EVENTS_TRIGGERED [0:0]
        ///Event number n generated by triggering the corresponding TRIGGER[n] task
        events_triggered: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task
    pub const events_triggered = Register(events_triggered_val).initRange(0x40017000 + 0x100, 4, 16);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///TRIGGERED0 [0:0]
        ///Enable or disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Enable or disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Enable or disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Enable or disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Enable or disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Enable or disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Enable or disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Enable or disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Enable or disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Enable or disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Enable or disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Enable or disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Enable or disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Enable or disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Enable or disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Enable or disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40017000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenset_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40017000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenclr_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40017000 + 0x308);
};

///Software interrupt 3
pub const swi3 = struct {

    //////////////////////////
    ///UNUSED
    const unused_val = packed struct {
        _unused0: u32 = 0,
    };
    ///Unused.
    pub const unused = RegisterRW(unused_val, void).init(0x40017000 + 0x000);
};

///Event generator unit 4
pub const egu4 = struct {

    //////////////////////////
    ///TASKS_TRIGGER[%s]
    const tasks_trigger_val = packed struct {
        ///TASKS_TRIGGER [0:0]
        ///Trigger n for triggering the corresponding TRIGGERED[n] event
        tasks_trigger: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event
    pub const tasks_trigger = RegisterRW(void, tasks_trigger_val).initRange(0x40018000 + 0x000, 4, 16);

    //////////////////////////
    ///EVENTS_TRIGGERED[%s]
    const events_triggered_val = packed struct {
        ///EVENTS_TRIGGERED [0:0]
        ///Event number n generated by triggering the corresponding TRIGGER[n] task
        events_triggered: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task
    pub const events_triggered = Register(events_triggered_val).initRange(0x40018000 + 0x100, 4, 16);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///TRIGGERED0 [0:0]
        ///Enable or disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Enable or disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Enable or disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Enable or disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Enable or disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Enable or disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Enable or disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Enable or disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Enable or disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Enable or disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Enable or disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Enable or disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Enable or disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Enable or disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Enable or disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Enable or disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40018000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenset_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40018000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenclr_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40018000 + 0x308);
};

///Software interrupt 4
pub const swi4 = struct {

    //////////////////////////
    ///UNUSED
    const unused_val = packed struct {
        _unused0: u32 = 0,
    };
    ///Unused.
    pub const unused = RegisterRW(unused_val, void).init(0x40018000 + 0x000);
};

///Event generator unit 5
pub const egu5 = struct {

    //////////////////////////
    ///TASKS_TRIGGER[%s]
    const tasks_trigger_val = packed struct {
        ///TASKS_TRIGGER [0:0]
        ///Trigger n for triggering the corresponding TRIGGERED[n] event
        tasks_trigger: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event
    pub const tasks_trigger = RegisterRW(void, tasks_trigger_val).initRange(0x40019000 + 0x000, 4, 16);

    //////////////////////////
    ///EVENTS_TRIGGERED[%s]
    const events_triggered_val = packed struct {
        ///EVENTS_TRIGGERED [0:0]
        ///Event number n generated by triggering the corresponding TRIGGER[n] task
        events_triggered: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task
    pub const events_triggered = Register(events_triggered_val).initRange(0x40019000 + 0x100, 4, 16);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///TRIGGERED0 [0:0]
        ///Enable or disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Enable or disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Enable or disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Enable or disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Enable or disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Enable or disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Enable or disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Enable or disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Enable or disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Enable or disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Enable or disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Enable or disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Enable or disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Enable or disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Enable or disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Enable or disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40019000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenset_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to enable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to enable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to enable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to enable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to enable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to enable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to enable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to enable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to enable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to enable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to enable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to enable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to enable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to enable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to enable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to enable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40019000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused16: u16 = 0,
    };
    const intenclr_val_write = packed struct {
        ///TRIGGERED0 [0:0]
        ///Write '1' to disable interrupt for event TRIGGERED[0]
        triggered0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED1 [1:1]
        ///Write '1' to disable interrupt for event TRIGGERED[1]
        triggered1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED2 [2:2]
        ///Write '1' to disable interrupt for event TRIGGERED[2]
        triggered2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED3 [3:3]
        ///Write '1' to disable interrupt for event TRIGGERED[3]
        triggered3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED4 [4:4]
        ///Write '1' to disable interrupt for event TRIGGERED[4]
        triggered4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED5 [5:5]
        ///Write '1' to disable interrupt for event TRIGGERED[5]
        triggered5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED6 [6:6]
        ///Write '1' to disable interrupt for event TRIGGERED[6]
        triggered6: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED7 [7:7]
        ///Write '1' to disable interrupt for event TRIGGERED[7]
        triggered7: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED8 [8:8]
        ///Write '1' to disable interrupt for event TRIGGERED[8]
        triggered8: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED9 [9:9]
        ///Write '1' to disable interrupt for event TRIGGERED[9]
        triggered9: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED10 [10:10]
        ///Write '1' to disable interrupt for event TRIGGERED[10]
        triggered10: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED11 [11:11]
        ///Write '1' to disable interrupt for event TRIGGERED[11]
        triggered11: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED12 [12:12]
        ///Write '1' to disable interrupt for event TRIGGERED[12]
        triggered12: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED13 [13:13]
        ///Write '1' to disable interrupt for event TRIGGERED[13]
        triggered13: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED14 [14:14]
        ///Write '1' to disable interrupt for event TRIGGERED[14]
        triggered14: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TRIGGERED15 [15:15]
        ///Write '1' to disable interrupt for event TRIGGERED[15]
        triggered15: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40019000 + 0x308);
};

///Software interrupt 5
pub const swi5 = struct {

    //////////////////////////
    ///UNUSED
    const unused_val = packed struct {
        _unused0: u32 = 0,
    };
    ///Unused.
    pub const unused = RegisterRW(unused_val, void).init(0x40019000 + 0x000);
};

///Timer/Counter 3
pub const timer3 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start Timer
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start Timer
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x4001A000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop Timer
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop Timer
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4001A000 + 0x004);

    //////////////////////////
    ///TASKS_COUNT
    const tasks_count_val = packed struct {
        ///TASKS_COUNT [0:0]
        ///Increment Timer (Counter mode only)
        tasks_count: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Increment Timer (Counter mode only)
    pub const tasks_count = RegisterRW(void, tasks_count_val).init(0x4001A000 + 0x008);

    //////////////////////////
    ///TASKS_CLEAR
    const tasks_clear_val = packed struct {
        ///TASKS_CLEAR [0:0]
        ///Clear time
        tasks_clear: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Clear time
    pub const tasks_clear = RegisterRW(void, tasks_clear_val).init(0x4001A000 + 0x00C);

    //////////////////////////
    ///TASKS_SHUTDOWN
    const tasks_shutdown_val = packed struct {
        ///TASKS_SHUTDOWN [0:0]
        ///Deprecated field -  Shut down timer
        tasks_shutdown: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Deprecated register - Shut down timer
    pub const tasks_shutdown = RegisterRW(void, tasks_shutdown_val).init(0x4001A000 + 0x010);

    //////////////////////////
    ///TASKS_CAPTURE[%s]
    const tasks_capture_val = packed struct {
        ///TASKS_CAPTURE [0:0]
        ///Capture Timer value to CC[n] register
        tasks_capture: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Capture Timer value to CC[n] register
    pub const tasks_capture = RegisterRW(void, tasks_capture_val).initRange(0x4001A000 + 0x040, 4, 6);

    //////////////////////////
    ///EVENTS_COMPARE[%s]
    const events_compare_val = packed struct {
        ///EVENTS_COMPARE [0:0]
        ///Compare event on CC[n] match
        events_compare: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Compare event on CC[n] match
    pub const events_compare = Register(events_compare_val).initRange(0x4001A000 + 0x140, 4, 6);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///COMPARE0_CLEAR [0:0]
        ///Shortcut between event COMPARE[0] and task CLEAR
        compare0_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE1_CLEAR [1:1]
        ///Shortcut between event COMPARE[1] and task CLEAR
        compare1_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE2_CLEAR [2:2]
        ///Shortcut between event COMPARE[2] and task CLEAR
        compare2_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE3_CLEAR [3:3]
        ///Shortcut between event COMPARE[3] and task CLEAR
        compare3_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE4_CLEAR [4:4]
        ///Shortcut between event COMPARE[4] and task CLEAR
        compare4_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE5_CLEAR [5:5]
        ///Shortcut between event COMPARE[5] and task CLEAR
        compare5_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused6: u2 = 0,
        ///COMPARE0_STOP [8:8]
        ///Shortcut between event COMPARE[0] and task STOP
        compare0_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE1_STOP [9:9]
        ///Shortcut between event COMPARE[1] and task STOP
        compare1_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE2_STOP [10:10]
        ///Shortcut between event COMPARE[2] and task STOP
        compare2_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE3_STOP [11:11]
        ///Shortcut between event COMPARE[3] and task STOP
        compare3_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE4_STOP [12:12]
        ///Shortcut between event COMPARE[4] and task STOP
        compare4_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE5_STOP [13:13]
        ///Shortcut between event COMPARE[5] and task STOP
        compare5_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused14: u18 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x4001A000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE4 [20:20]
        ///Write '1' to enable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE5 [21:21]
        ///Write '1' to enable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE4 [20:20]
        ///Write '1' to enable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE5 [21:21]
        ///Write '1' to enable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4001A000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE4 [20:20]
        ///Write '1' to disable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE5 [21:21]
        ///Write '1' to disable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE4 [20:20]
        ///Write '1' to disable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE5 [21:21]
        ///Write '1' to disable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4001A000 + 0x308);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///MODE [0:1]
        ///Timer mode
        mode: packed enum(u2) {
            ///Select Timer mode
            timer = 0,
            ///Deprecated enumerator -  Select Counter mode
            counter = 1,
            ///Select Low Power Counter mode
            low_power_counter = 2,
        } = .timer,
        _unused2: u30 = 0,
    };
    ///Timer mode selection
    pub const mode = Register(mode_val).init(0x4001A000 + 0x504);

    //////////////////////////
    ///BITMODE
    const bitmode_val = packed struct {
        ///BITMODE [0:1]
        ///Timer bit width
        bitmode: packed enum(u2) {
            ///16 bit timer bit width
            _16bit = 0,
            ///8 bit timer bit width
            _08bit = 1,
            ///24 bit timer bit width
            _24bit = 2,
            ///32 bit timer bit width
            _32bit = 3,
        } = ._16bit,
        _unused2: u30 = 0,
    };
    ///Configure the number of bits used by the TIMER
    pub const bitmode = Register(bitmode_val).init(0x4001A000 + 0x508);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:3]
        ///Prescaler value
        prescaler: u4 = 4,
        _unused4: u28 = 0,
    };
    ///Timer prescaler register
    pub const prescaler = Register(prescaler_val).init(0x4001A000 + 0x510);

    //////////////////////////
    ///CC[%s]
    const cc_val = packed struct {
        ///CC [0:31]
        ///Capture/Compare value
        cc: u32 = 0,
    };
    ///Description collection: Capture/Compare register n
    pub const cc = Register(cc_val).initRange(0x4001A000 + 0x540, 4, 6);
};

///Timer/Counter 4
pub const timer4 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start Timer
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start Timer
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x4001B000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop Timer
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop Timer
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4001B000 + 0x004);

    //////////////////////////
    ///TASKS_COUNT
    const tasks_count_val = packed struct {
        ///TASKS_COUNT [0:0]
        ///Increment Timer (Counter mode only)
        tasks_count: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Increment Timer (Counter mode only)
    pub const tasks_count = RegisterRW(void, tasks_count_val).init(0x4001B000 + 0x008);

    //////////////////////////
    ///TASKS_CLEAR
    const tasks_clear_val = packed struct {
        ///TASKS_CLEAR [0:0]
        ///Clear time
        tasks_clear: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Clear time
    pub const tasks_clear = RegisterRW(void, tasks_clear_val).init(0x4001B000 + 0x00C);

    //////////////////////////
    ///TASKS_SHUTDOWN
    const tasks_shutdown_val = packed struct {
        ///TASKS_SHUTDOWN [0:0]
        ///Deprecated field -  Shut down timer
        tasks_shutdown: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Deprecated register - Shut down timer
    pub const tasks_shutdown = RegisterRW(void, tasks_shutdown_val).init(0x4001B000 + 0x010);

    //////////////////////////
    ///TASKS_CAPTURE[%s]
    const tasks_capture_val = packed struct {
        ///TASKS_CAPTURE [0:0]
        ///Capture Timer value to CC[n] register
        tasks_capture: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Capture Timer value to CC[n] register
    pub const tasks_capture = RegisterRW(void, tasks_capture_val).initRange(0x4001B000 + 0x040, 4, 6);

    //////////////////////////
    ///EVENTS_COMPARE[%s]
    const events_compare_val = packed struct {
        ///EVENTS_COMPARE [0:0]
        ///Compare event on CC[n] match
        events_compare: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Compare event on CC[n] match
    pub const events_compare = Register(events_compare_val).initRange(0x4001B000 + 0x140, 4, 6);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///COMPARE0_CLEAR [0:0]
        ///Shortcut between event COMPARE[0] and task CLEAR
        compare0_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE1_CLEAR [1:1]
        ///Shortcut between event COMPARE[1] and task CLEAR
        compare1_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE2_CLEAR [2:2]
        ///Shortcut between event COMPARE[2] and task CLEAR
        compare2_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE3_CLEAR [3:3]
        ///Shortcut between event COMPARE[3] and task CLEAR
        compare3_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE4_CLEAR [4:4]
        ///Shortcut between event COMPARE[4] and task CLEAR
        compare4_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE5_CLEAR [5:5]
        ///Shortcut between event COMPARE[5] and task CLEAR
        compare5_clear: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused6: u2 = 0,
        ///COMPARE0_STOP [8:8]
        ///Shortcut between event COMPARE[0] and task STOP
        compare0_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE1_STOP [9:9]
        ///Shortcut between event COMPARE[1] and task STOP
        compare1_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE2_STOP [10:10]
        ///Shortcut between event COMPARE[2] and task STOP
        compare2_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE3_STOP [11:11]
        ///Shortcut between event COMPARE[3] and task STOP
        compare3_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE4_STOP [12:12]
        ///Shortcut between event COMPARE[4] and task STOP
        compare4_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///COMPARE5_STOP [13:13]
        ///Shortcut between event COMPARE[5] and task STOP
        compare5_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused14: u18 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x4001B000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE4 [20:20]
        ///Write '1' to enable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE5 [21:21]
        ///Write '1' to enable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE4 [20:20]
        ///Write '1' to enable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE5 [21:21]
        ///Write '1' to enable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4001B000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE4 [20:20]
        ///Write '1' to disable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE5 [21:21]
        ///Write '1' to disable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused22: u10 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u16 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE4 [20:20]
        ///Write '1' to disable interrupt for event COMPARE[4]
        compare4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE5 [21:21]
        ///Write '1' to disable interrupt for event COMPARE[5]
        compare5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused22: u10 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4001B000 + 0x308);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///MODE [0:1]
        ///Timer mode
        mode: packed enum(u2) {
            ///Select Timer mode
            timer = 0,
            ///Deprecated enumerator -  Select Counter mode
            counter = 1,
            ///Select Low Power Counter mode
            low_power_counter = 2,
        } = .timer,
        _unused2: u30 = 0,
    };
    ///Timer mode selection
    pub const mode = Register(mode_val).init(0x4001B000 + 0x504);

    //////////////////////////
    ///BITMODE
    const bitmode_val = packed struct {
        ///BITMODE [0:1]
        ///Timer bit width
        bitmode: packed enum(u2) {
            ///16 bit timer bit width
            _16bit = 0,
            ///8 bit timer bit width
            _08bit = 1,
            ///24 bit timer bit width
            _24bit = 2,
            ///32 bit timer bit width
            _32bit = 3,
        } = ._16bit,
        _unused2: u30 = 0,
    };
    ///Configure the number of bits used by the TIMER
    pub const bitmode = Register(bitmode_val).init(0x4001B000 + 0x508);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:3]
        ///Prescaler value
        prescaler: u4 = 4,
        _unused4: u28 = 0,
    };
    ///Timer prescaler register
    pub const prescaler = Register(prescaler_val).init(0x4001B000 + 0x510);

    //////////////////////////
    ///CC[%s]
    const cc_val = packed struct {
        ///CC [0:31]
        ///Capture/Compare value
        cc: u32 = 0,
    };
    ///Description collection: Capture/Compare register n
    pub const cc = Register(cc_val).initRange(0x4001B000 + 0x540, 4, 6);
};

///Pulse width modulation unit 0
pub const pwm0 = struct {

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4001C000 + 0x004);

    //////////////////////////
    ///TASKS_SEQSTART[%s]
    const tasks_seqstart_val = packed struct {
        ///TASKS_SEQSTART [0:0]
        ///Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
        tasks_seqstart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
    pub const tasks_seqstart = RegisterRW(void, tasks_seqstart_val).initRange(0x4001C000 + 0x008, 4, 2);

    //////////////////////////
    ///TASKS_NEXTSTEP
    const tasks_nextstep_val = packed struct {
        ///TASKS_NEXTSTEP [0:0]
        ///Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
        tasks_nextstep: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
    pub const tasks_nextstep = RegisterRW(void, tasks_nextstep_val).init(0x4001C000 + 0x010);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///Response to STOP task, emitted when PWM pulses are no longer generated
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Response to STOP task, emitted when PWM pulses are no longer generated
    pub const events_stopped = Register(events_stopped_val).init(0x4001C000 + 0x104);

    //////////////////////////
    ///EVENTS_SEQSTARTED[%s]
    const events_seqstarted_val = packed struct {
        ///EVENTS_SEQSTARTED [0:0]
        ///First PWM period started on sequence n
        events_seqstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: First PWM period started on sequence n
    pub const events_seqstarted = Register(events_seqstarted_val).initRange(0x4001C000 + 0x108, 4, 2);

    //////////////////////////
    ///EVENTS_SEQEND[%s]
    const events_seqend_val = packed struct {
        ///EVENTS_SEQEND [0:0]
        ///Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
        events_seqend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
    pub const events_seqend = Register(events_seqend_val).initRange(0x4001C000 + 0x110, 4, 2);

    //////////////////////////
    ///EVENTS_PWMPERIODEND
    const events_pwmperiodend_val = packed struct {
        ///EVENTS_PWMPERIODEND [0:0]
        ///Emitted at the end of each PWM period
        events_pwmperiodend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Emitted at the end of each PWM period
    pub const events_pwmperiodend = Register(events_pwmperiodend_val).init(0x4001C000 + 0x118);

    //////////////////////////
    ///EVENTS_LOOPSDONE
    const events_loopsdone_val = packed struct {
        ///EVENTS_LOOPSDONE [0:0]
        ///Concatenated sequences have been played the amount of times defined in LOOP.CNT
        events_loopsdone: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Concatenated sequences have been played the amount of times defined in LOOP.CNT
    pub const events_loopsdone = Register(events_loopsdone_val).init(0x4001C000 + 0x11C);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///SEQEND0_STOP [0:0]
        ///Shortcut between event SEQEND[0] and task STOP
        seqend0_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///SEQEND1_STOP [1:1]
        ///Shortcut between event SEQEND[1] and task STOP
        seqend1_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_SEQSTART0 [2:2]
        ///Shortcut between event LOOPSDONE and task SEQSTART[0]
        loopsdone_seqstart0: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_SEQSTART1 [3:3]
        ///Shortcut between event LOOPSDONE and task SEQSTART[1]
        loopsdone_seqstart1: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_STOP [4:4]
        ///Shortcut between event LOOPSDONE and task STOP
        loopsdone_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused5: u27 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x4001C000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Enable or disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Enable or disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Enable or disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Enable or disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Enable or disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Enable or disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x4001C000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to enable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to enable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Write '1' to enable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Write '1' to enable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Write '1' to enable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Write '1' to enable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to enable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to enable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND0 [4:4]
        ///Write '1' to enable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND1 [5:5]
        ///Write '1' to enable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PWMPERIODEND [6:6]
        ///Write '1' to enable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///LOOPSDONE [7:7]
        ///Write '1' to enable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4001C000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Write '1' to disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Write '1' to disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Write '1' to disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Write '1' to disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND0 [4:4]
        ///Write '1' to disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND1 [5:5]
        ///Write '1' to disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PWMPERIODEND [6:6]
        ///Write '1' to disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///LOOPSDONE [7:7]
        ///Write '1' to disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4001C000 + 0x308);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:0]
        ///Enable or disable PWM module
        enable: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///PWM module enable register
    pub const enable = Register(enable_val).init(0x4001C000 + 0x500);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///UPDOWN [0:0]
        ///Selects up mode or up-and-down mode for the counter
        updown: packed enum(u1) {
            ///Up counter, edge-aligned PWM duty cycle
            up = 0,
            ///Up and down counter, center-aligned PWM duty cycle
            up_and_down = 1,
        } = .up,
        _unused1: u31 = 0,
    };
    ///Selects operating mode of the wave counter
    pub const mode = Register(mode_val).init(0x4001C000 + 0x504);

    //////////////////////////
    ///COUNTERTOP
    const countertop_val = packed struct {
        ///COUNTERTOP [0:14]
        ///Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used.
        countertop: u15 = 1023,
        _unused15: u17 = 0,
    };
    ///Value up to which the pulse generator counter counts
    pub const countertop = Register(countertop_val).init(0x4001C000 + 0x508);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:2]
        ///Prescaler of PWM_CLK
        prescaler: packed enum(u3) {
            ///Divide by 1 (16 MHz)
            div_1 = 0,
            ///Divide by 2 (8 MHz)
            div_2 = 1,
            ///Divide by 4 (4 MHz)
            div_4 = 2,
            ///Divide by 8 (2 MHz)
            div_8 = 3,
            ///Divide by 16 (1 MHz)
            div_16 = 4,
            ///Divide by 32 (500 kHz)
            div_32 = 5,
            ///Divide by 64 (250 kHz)
            div_64 = 6,
            ///Divide by 128 (125 kHz)
            div_128 = 7,
        } = .div_1,
        _unused3: u29 = 0,
    };
    ///Configuration for PWM_CLK
    pub const prescaler = Register(prescaler_val).init(0x4001C000 + 0x50C);

    //////////////////////////
    ///DECODER
    const decoder_val = packed struct {
        ///LOAD [0:1]
        ///How a sequence is read from RAM and spread to the compare register
        load: packed enum(u2) {
            ///1st half word (16-bit) used in all PWM channels 0..3
            common = 0,
            ///1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3
            grouped = 1,
            ///1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3
            individual = 2,
            ///1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP
            wave_form = 3,
        } = .common,
        _unused2: u6 = 0,
        ///MODE [8:8]
        ///Selects source for advancing the active sequence
        mode: packed enum(u1) {
            ///SEQ[n].REFRESH is used to determine loading internal compare registers
            refresh_count = 0,
            ///NEXTSTEP task causes a new value to be loaded to internal compare registers
            next_step = 1,
        } = .refresh_count,
        _unused9: u23 = 0,
    };
    ///Configuration of the decoder
    pub const decoder = Register(decoder_val).init(0x4001C000 + 0x510);

    //////////////////////////
    ///LOOP
    const loop_val = packed struct {
        ///CNT [0:15]
        ///Number of playbacks of pattern cycles
        cnt: packed enum(u16) {
            ///Looping disabled (stop at the end of the sequence)
            disabled = 0,
        } = .disabled,
        _unused16: u16 = 0,
    };
    ///Number of playbacks of a loop
    pub const loop = Register(loop_val).init(0x4001C000 + 0x514);
};

///Pulse Density Modulation (Digital Microphone) Interface
pub const pdm = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Starts continuous PDM transfer
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Starts continuous PDM transfer
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x4001D000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stops PDM transfer
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stops PDM transfer
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4001D000 + 0x004);

    //////////////////////////
    ///EVENTS_STARTED
    const events_started_val = packed struct {
        ///EVENTS_STARTED [0:0]
        ///PDM transfer has started
        events_started: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///PDM transfer has started
    pub const events_started = Register(events_started_val).init(0x4001D000 + 0x100);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///PDM transfer has finished
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///PDM transfer has finished
    pub const events_stopped = Register(events_stopped_val).init(0x4001D000 + 0x104);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM
    pub const events_end = Register(events_end_val).init(0x4001D000 + 0x108);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///STARTED [0:0]
        ///Enable or disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///STOPPED [1:1]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///END [2:2]
        ///Enable or disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x4001D000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///STARTED [0:0]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///END [2:2]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenset_val_write = packed struct {
        ///STARTED [0:0]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///END [2:2]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4001D000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///STARTED [0:0]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///END [2:2]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenclr_val_write = packed struct {
        ///STARTED [0:0]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///END [2:2]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4001D000 + 0x308);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:0]
        ///Enable or disable PDM module
        enable: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///PDM module enable register
    pub const enable = Register(enable_val).init(0x4001D000 + 0x500);

    //////////////////////////
    ///PDMCLKCTRL
    const pdmclkctrl_val = packed struct {
        ///FREQ [0:31]
        ///PDM_CLK frequency configuration
        freq: packed enum(u32) {
            ///PDM_CLK = 32 MHz / 32 = 1.000 MHz
            _1000k = 0x08000000,
            ///PDM_CLK = 32 MHz / 31 = 1.032 MHz. Nominal clock for RATIO=Ratio64.
            default = 0x08400000,
            ///PDM_CLK = 32 MHz / 30 = 1.067 MHz
            _1067k = 0x08800000,
            ///PDM_CLK = 32 MHz / 26 = 1.231 MHz
            _1231k = 0x09800000,
            ///PDM_CLK = 32 MHz / 25 = 1.280 MHz. Nominal clock for RATIO=Ratio80.
            _1280k = 0x0A000000,
            ///PDM_CLK = 32 MHz / 24 = 1.333 MHz
            _1333k = 0x0A800000,
            _zero = 0,
        } = ._zero,
    };
    ///PDM clock generator control
    pub const pdmclkctrl = Register(pdmclkctrl_val).init(0x4001D000 + 0x504);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///OPERATION [0:0]
        ///Mono or stereo operation
        operation: packed enum(u1) {
            ///Sample and store one pair (left + right) of 16-bit samples per RAM word R=[31:16]; L=[15:0]
            stereo = 0,
            ///Sample and store two successive left samples (16 bits each) per RAM word L1=[31:16]; L0=[15:0]
            mono = 1,
        } = .stereo,
        ///EDGE [1:1]
        ///Defines on which PDM_CLK edge left (or mono) is sampled
        edge: packed enum(u1) {
            ///Left (or mono) is sampled on falling edge of PDM_CLK
            left_falling = 0,
            ///Left (or mono) is sampled on rising edge of PDM_CLK
            left_rising = 1,
        } = .left_falling,
        _unused2: u30 = 0,
    };
    ///Defines the routing of the connected PDM microphones' signals
    pub const mode = Register(mode_val).init(0x4001D000 + 0x508);

    //////////////////////////
    ///GAINL
    const gainl_val = packed struct {
        ///GAINL [0:6]
        ///Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00    -20 dB gain adjust 0x01  -19.5 dB gain adjust (...) 0x27   -0.5 dB gain adjust 0x28      0 dB gain adjust 0x29   +0.5 dB gain adjust (...) 0x4F  +19.5 dB gain adjust 0x50    +20 dB gain adjust
        gainl: packed enum(u7) {
            ///-20 dB gain adjustment (minimum)
            min_gain = 0x00,
            ///0 dB gain adjustment
            default_gain = 0x28,
            ///+20 dB gain adjustment (maximum)
            max_gain = 0x50,
            _zero = 0,
        } = ._zero,
        _unused7: u25 = 0,
    };
    ///Left output gain adjustment
    pub const gainl = Register(gainl_val).init(0x4001D000 + 0x518);

    //////////////////////////
    ///GAINR
    const gainr_val = packed struct {
        ///GAINR [0:6]
        ///Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)
        gainr: packed enum(u7) {
            ///-20 dB gain adjustment (minimum)
            min_gain = 0x00,
            ///0 dB gain adjustment
            default_gain = 0x28,
            ///+20 dB gain adjustment (maximum)
            max_gain = 0x50,
            _zero = 0,
        } = ._zero,
        _unused7: u25 = 0,
    };
    ///Right output gain adjustment
    pub const gainr = Register(gainr_val).init(0x4001D000 + 0x51C);

    //////////////////////////
    ///RATIO
    const ratio_val = packed struct {
        ///RATIO [0:0]
        ///Selects the ratio between PDM_CLK and output sample rate
        ratio: packed enum(u1) {
            ///Ratio of 64
            ratio64 = 0,
            ///Ratio of 80
            ratio80 = 1,
        } = .ratio64,
        _unused1: u31 = 0,
    };
    ///Selects the ratio between PDM_CLK and output sample rate. Change PDMCLKCTRL accordingly.
    pub const ratio = Register(ratio_val).init(0x4001D000 + 0x520);
};

///Access control lists
pub const acl = struct {};

///Non Volatile Memory Controller
pub const nvmc = struct {

    //////////////////////////
    ///READY
    const ready_val = packed struct {
        ///READY [0:0]
        ///NVMC is ready or busy
        ready: packed enum(u1) {
            ///NVMC is busy (on-going write or erase operation)
            busy = 0,
            ///NVMC is ready
            ready = 1,
        } = .ready,
        _unused1: u31 = 0,
    };
    ///Ready flag
    pub const ready = RegisterRW(ready_val, void).init(0x4001E000 + 0x400);

    //////////////////////////
    ///READYNEXT
    const readynext_val = packed struct {
        ///READYNEXT [0:0]
        ///NVMC can accept a new write operation
        readynext: packed enum(u1) {
            ///NVMC cannot accept any write operation
            busy = 0,
            ///NVMC is ready
            ready = 1,
        } = .ready,
        _unused1: u31 = 0,
    };
    ///Ready flag
    pub const readynext = RegisterRW(readynext_val, void).init(0x4001E000 + 0x408);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///WEN [0:1]
        ///Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated.
        wen: packed enum(u2) {
            ///Read only access
            ren = 0,
            ///Write enabled
            wen = 1,
            ///Erase enabled
            een = 2,
        } = .ren,
        _unused2: u30 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x4001E000 + 0x504);

    //////////////////////////
    ///ERASEPAGE
    const erasepage_val = packed struct {
        ///ERASEPAGE [0:31]
        ///Register for starting erase of a page in code area
        erasepage: u32 = 0,
    };
    ///Register for erasing a page in code area
    pub const erasepage = RegisterRW(void, erasepage_val).init(0x4001E000 + 0x508);

    //////////////////////////
    ///ERASEPCR1
    const erasepcr1_val = packed struct {
        ///ERASEPCR1 [0:31]
        ///Register for erasing a page in code area, equivalent to ERASEPAGE
        erasepcr1: u32 = 0,
    };
    ///Deprecated register - Register for erasing a page in code area, equivalent to ERASEPAGE
    pub const erasepcr1 = RegisterRW(void, erasepcr1_val).init(0x4001E000 + 0x508);

    //////////////////////////
    ///ERASEALL
    const eraseall_val = packed struct {
        ///ERASEALL [0:0]
        ///Erase all non-volatile memory including UICR registers. The erase must be enabled using CONFIG.WEN before the non-volatile memory can be erased.
        eraseall: packed enum(u1) {
            ///No operation
            no_operation = 0,
            ///Start chip erase
            erase = 1,
        } = .no_operation,
        _unused1: u31 = 0,
    };
    ///Register for erasing all non-volatile user memory
    pub const eraseall = RegisterRW(void, eraseall_val).init(0x4001E000 + 0x50C);

    //////////////////////////
    ///ERASEPCR0
    const erasepcr0_val = packed struct {
        ///ERASEPCR0 [0:31]
        ///Register for starting erase of a page in code area, equivalent to ERASEPAGE
        erasepcr0: u32 = 0,
    };
    ///Deprecated register - Register for erasing a page in code area, equivalent to ERASEPAGE
    pub const erasepcr0 = RegisterRW(void, erasepcr0_val).init(0x4001E000 + 0x510);

    //////////////////////////
    ///ERASEUICR
    const eraseuicr_val = packed struct {
        ///ERASEUICR [0:0]
        ///Register starting erase of all user information configuration registers. The erase must be enabled using CONFIG.WEN before the UICR can be erased.
        eraseuicr: packed enum(u1) {
            ///No operation
            no_operation = 0,
            ///Start erase of UICR
            erase = 1,
        } = .no_operation,
        _unused1: u31 = 0,
    };
    ///Register for erasing user information configuration registers
    pub const eraseuicr = RegisterRW(void, eraseuicr_val).init(0x4001E000 + 0x514);

    //////////////////////////
    ///ERASEPAGEPARTIAL
    const erasepagepartial_val = packed struct {
        ///ERASEPAGEPARTIAL [0:31]
        ///Register for starting partial erase of a page in code area
        erasepagepartial: u32 = 0,
    };
    ///Register for partial erase of a page in code area
    pub const erasepagepartial = RegisterRW(void, erasepagepartial_val).init(0x4001E000 + 0x518);

    //////////////////////////
    ///ERASEPAGEPARTIALCFG
    const erasepagepartialcfg_val = packed struct {
        ///DURATION [0:6]
        ///Duration of the partial erase in milliseconds
        duration: u7 = 10,
        _unused7: u25 = 0,
    };
    ///Register for partial erase configuration
    pub const erasepagepartialcfg = Register(erasepagepartialcfg_val).init(0x4001E000 + 0x51C);

    //////////////////////////
    ///ICACHECNF
    const icachecnf_val = packed struct {
        ///CACHEEN [0:0]
        ///Cache enable
        cacheen: packed enum(u1) {
            ///Disable cache. Invalidates all cache entries.
            disabled = 0,
            ///Enable cache
            enabled = 1,
        } = .disabled,
        _unused1: u7 = 0,
        ///CACHEPROFEN [8:8]
        ///Cache profiling enable
        cacheprofen: packed enum(u1) {
            ///Disable cache profiling
            disabled = 0,
            ///Enable cache profiling
            enabled = 1,
        } = .disabled,
        _unused9: u23 = 0,
    };
    ///I-code cache configuration register
    pub const icachecnf = Register(icachecnf_val).init(0x4001E000 + 0x540);

    //////////////////////////
    ///IHIT
    const ihit_val = packed struct {
        ///HITS [0:31]
        ///Number of cache hits. Register is writable, but only to '0'.
        hits: u32 = 0,
    };
    ///I-code cache hit counter
    pub const ihit = Register(ihit_val).init(0x4001E000 + 0x548);

    //////////////////////////
    ///IMISS
    const imiss_val = packed struct {
        ///MISSES [0:31]
        ///Number of cache misses. Register is writable, but only to '0'.
        misses: u32 = 0,
    };
    ///I-code cache miss counter
    pub const imiss = Register(imiss_val).init(0x4001E000 + 0x54C);
};

///Programmable Peripheral Interconnect
pub const ppi = struct {

    //////////////////////////
    ///CHEN
    const chen_val = packed struct {
        ///CH0 [0:0]
        ///Enable or disable channel 0
        ch0: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH1 [1:1]
        ///Enable or disable channel 1
        ch1: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH2 [2:2]
        ///Enable or disable channel 2
        ch2: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH3 [3:3]
        ///Enable or disable channel 3
        ch3: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH4 [4:4]
        ///Enable or disable channel 4
        ch4: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH5 [5:5]
        ///Enable or disable channel 5
        ch5: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH6 [6:6]
        ///Enable or disable channel 6
        ch6: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH7 [7:7]
        ///Enable or disable channel 7
        ch7: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH8 [8:8]
        ///Enable or disable channel 8
        ch8: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH9 [9:9]
        ///Enable or disable channel 9
        ch9: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH10 [10:10]
        ///Enable or disable channel 10
        ch10: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH11 [11:11]
        ///Enable or disable channel 11
        ch11: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH12 [12:12]
        ///Enable or disable channel 12
        ch12: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH13 [13:13]
        ///Enable or disable channel 13
        ch13: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH14 [14:14]
        ///Enable or disable channel 14
        ch14: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH15 [15:15]
        ///Enable or disable channel 15
        ch15: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH16 [16:16]
        ///Enable or disable channel 16
        ch16: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH17 [17:17]
        ///Enable or disable channel 17
        ch17: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH18 [18:18]
        ///Enable or disable channel 18
        ch18: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH19 [19:19]
        ///Enable or disable channel 19
        ch19: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH20 [20:20]
        ///Enable or disable channel 20
        ch20: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH21 [21:21]
        ///Enable or disable channel 21
        ch21: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH22 [22:22]
        ///Enable or disable channel 22
        ch22: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH23 [23:23]
        ///Enable or disable channel 23
        ch23: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH24 [24:24]
        ///Enable or disable channel 24
        ch24: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH25 [25:25]
        ///Enable or disable channel 25
        ch25: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH26 [26:26]
        ///Enable or disable channel 26
        ch26: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH27 [27:27]
        ///Enable or disable channel 27
        ch27: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH28 [28:28]
        ///Enable or disable channel 28
        ch28: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH29 [29:29]
        ///Enable or disable channel 29
        ch29: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH30 [30:30]
        ///Enable or disable channel 30
        ch30: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
        ///CH31 [31:31]
        ///Enable or disable channel 31
        ch31: packed enum(u1) {
            ///Disable channel
            disabled = 0,
            ///Enable channel
            enabled = 1,
        } = .disabled,
    };
    ///Channel enable register
    pub const chen = Register(chen_val).init(0x4001F000 + 0x500);

    //////////////////////////
    ///CHENSET
    const chenset_val_read = packed struct {
        ///CH0 [0:0]
        ///Channel 0 enable set register.  Writing '0' has no effect
        ch0: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH1 [1:1]
        ///Channel 1 enable set register.  Writing '0' has no effect
        ch1: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH2 [2:2]
        ///Channel 2 enable set register.  Writing '0' has no effect
        ch2: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH3 [3:3]
        ///Channel 3 enable set register.  Writing '0' has no effect
        ch3: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH4 [4:4]
        ///Channel 4 enable set register.  Writing '0' has no effect
        ch4: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH5 [5:5]
        ///Channel 5 enable set register.  Writing '0' has no effect
        ch5: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH6 [6:6]
        ///Channel 6 enable set register.  Writing '0' has no effect
        ch6: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH7 [7:7]
        ///Channel 7 enable set register.  Writing '0' has no effect
        ch7: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH8 [8:8]
        ///Channel 8 enable set register.  Writing '0' has no effect
        ch8: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH9 [9:9]
        ///Channel 9 enable set register.  Writing '0' has no effect
        ch9: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH10 [10:10]
        ///Channel 10 enable set register.  Writing '0' has no effect
        ch10: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH11 [11:11]
        ///Channel 11 enable set register.  Writing '0' has no effect
        ch11: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH12 [12:12]
        ///Channel 12 enable set register.  Writing '0' has no effect
        ch12: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH13 [13:13]
        ///Channel 13 enable set register.  Writing '0' has no effect
        ch13: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH14 [14:14]
        ///Channel 14 enable set register.  Writing '0' has no effect
        ch14: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH15 [15:15]
        ///Channel 15 enable set register.  Writing '0' has no effect
        ch15: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH16 [16:16]
        ///Channel 16 enable set register.  Writing '0' has no effect
        ch16: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH17 [17:17]
        ///Channel 17 enable set register.  Writing '0' has no effect
        ch17: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH18 [18:18]
        ///Channel 18 enable set register.  Writing '0' has no effect
        ch18: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH19 [19:19]
        ///Channel 19 enable set register.  Writing '0' has no effect
        ch19: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH20 [20:20]
        ///Channel 20 enable set register.  Writing '0' has no effect
        ch20: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH21 [21:21]
        ///Channel 21 enable set register.  Writing '0' has no effect
        ch21: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH22 [22:22]
        ///Channel 22 enable set register.  Writing '0' has no effect
        ch22: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH23 [23:23]
        ///Channel 23 enable set register.  Writing '0' has no effect
        ch23: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH24 [24:24]
        ///Channel 24 enable set register.  Writing '0' has no effect
        ch24: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH25 [25:25]
        ///Channel 25 enable set register.  Writing '0' has no effect
        ch25: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH26 [26:26]
        ///Channel 26 enable set register.  Writing '0' has no effect
        ch26: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH27 [27:27]
        ///Channel 27 enable set register.  Writing '0' has no effect
        ch27: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH28 [28:28]
        ///Channel 28 enable set register.  Writing '0' has no effect
        ch28: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH29 [29:29]
        ///Channel 29 enable set register.  Writing '0' has no effect
        ch29: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH30 [30:30]
        ///Channel 30 enable set register.  Writing '0' has no effect
        ch30: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH31 [31:31]
        ///Channel 31 enable set register.  Writing '0' has no effect
        ch31: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
    };
    const chenset_val_write = packed struct {
        ///CH0 [0:0]
        ///Channel 0 enable set register.  Writing '0' has no effect
        ch0: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH1 [1:1]
        ///Channel 1 enable set register.  Writing '0' has no effect
        ch1: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH2 [2:2]
        ///Channel 2 enable set register.  Writing '0' has no effect
        ch2: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH3 [3:3]
        ///Channel 3 enable set register.  Writing '0' has no effect
        ch3: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH4 [4:4]
        ///Channel 4 enable set register.  Writing '0' has no effect
        ch4: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH5 [5:5]
        ///Channel 5 enable set register.  Writing '0' has no effect
        ch5: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH6 [6:6]
        ///Channel 6 enable set register.  Writing '0' has no effect
        ch6: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH7 [7:7]
        ///Channel 7 enable set register.  Writing '0' has no effect
        ch7: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH8 [8:8]
        ///Channel 8 enable set register.  Writing '0' has no effect
        ch8: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH9 [9:9]
        ///Channel 9 enable set register.  Writing '0' has no effect
        ch9: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH10 [10:10]
        ///Channel 10 enable set register.  Writing '0' has no effect
        ch10: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH11 [11:11]
        ///Channel 11 enable set register.  Writing '0' has no effect
        ch11: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH12 [12:12]
        ///Channel 12 enable set register.  Writing '0' has no effect
        ch12: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH13 [13:13]
        ///Channel 13 enable set register.  Writing '0' has no effect
        ch13: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH14 [14:14]
        ///Channel 14 enable set register.  Writing '0' has no effect
        ch14: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH15 [15:15]
        ///Channel 15 enable set register.  Writing '0' has no effect
        ch15: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH16 [16:16]
        ///Channel 16 enable set register.  Writing '0' has no effect
        ch16: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH17 [17:17]
        ///Channel 17 enable set register.  Writing '0' has no effect
        ch17: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH18 [18:18]
        ///Channel 18 enable set register.  Writing '0' has no effect
        ch18: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH19 [19:19]
        ///Channel 19 enable set register.  Writing '0' has no effect
        ch19: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH20 [20:20]
        ///Channel 20 enable set register.  Writing '0' has no effect
        ch20: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH21 [21:21]
        ///Channel 21 enable set register.  Writing '0' has no effect
        ch21: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH22 [22:22]
        ///Channel 22 enable set register.  Writing '0' has no effect
        ch22: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH23 [23:23]
        ///Channel 23 enable set register.  Writing '0' has no effect
        ch23: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH24 [24:24]
        ///Channel 24 enable set register.  Writing '0' has no effect
        ch24: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH25 [25:25]
        ///Channel 25 enable set register.  Writing '0' has no effect
        ch25: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH26 [26:26]
        ///Channel 26 enable set register.  Writing '0' has no effect
        ch26: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH27 [27:27]
        ///Channel 27 enable set register.  Writing '0' has no effect
        ch27: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH28 [28:28]
        ///Channel 28 enable set register.  Writing '0' has no effect
        ch28: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH29 [29:29]
        ///Channel 29 enable set register.  Writing '0' has no effect
        ch29: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH30 [30:30]
        ///Channel 30 enable set register.  Writing '0' has no effect
        ch30: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
        ///CH31 [31:31]
        ///Channel 31 enable set register.  Writing '0' has no effect
        ch31: packed enum(u1) {
            ///Write: Enable channel
            set = 1,
            _zero = 0,
        } = ._zero,
    };
    ///Channel enable set register
    pub const chenset = RegisterRW(chenset_val_read, chenset_val_write).init(0x4001F000 + 0x504);

    //////////////////////////
    ///CHENCLR
    const chenclr_val_read = packed struct {
        ///CH0 [0:0]
        ///Channel 0 enable clear register.  Writing '0' has no effect
        ch0: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH1 [1:1]
        ///Channel 1 enable clear register.  Writing '0' has no effect
        ch1: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH2 [2:2]
        ///Channel 2 enable clear register.  Writing '0' has no effect
        ch2: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH3 [3:3]
        ///Channel 3 enable clear register.  Writing '0' has no effect
        ch3: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH4 [4:4]
        ///Channel 4 enable clear register.  Writing '0' has no effect
        ch4: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH5 [5:5]
        ///Channel 5 enable clear register.  Writing '0' has no effect
        ch5: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH6 [6:6]
        ///Channel 6 enable clear register.  Writing '0' has no effect
        ch6: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH7 [7:7]
        ///Channel 7 enable clear register.  Writing '0' has no effect
        ch7: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH8 [8:8]
        ///Channel 8 enable clear register.  Writing '0' has no effect
        ch8: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH9 [9:9]
        ///Channel 9 enable clear register.  Writing '0' has no effect
        ch9: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH10 [10:10]
        ///Channel 10 enable clear register.  Writing '0' has no effect
        ch10: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH11 [11:11]
        ///Channel 11 enable clear register.  Writing '0' has no effect
        ch11: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH12 [12:12]
        ///Channel 12 enable clear register.  Writing '0' has no effect
        ch12: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH13 [13:13]
        ///Channel 13 enable clear register.  Writing '0' has no effect
        ch13: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH14 [14:14]
        ///Channel 14 enable clear register.  Writing '0' has no effect
        ch14: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH15 [15:15]
        ///Channel 15 enable clear register.  Writing '0' has no effect
        ch15: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH16 [16:16]
        ///Channel 16 enable clear register.  Writing '0' has no effect
        ch16: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH17 [17:17]
        ///Channel 17 enable clear register.  Writing '0' has no effect
        ch17: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH18 [18:18]
        ///Channel 18 enable clear register.  Writing '0' has no effect
        ch18: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH19 [19:19]
        ///Channel 19 enable clear register.  Writing '0' has no effect
        ch19: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH20 [20:20]
        ///Channel 20 enable clear register.  Writing '0' has no effect
        ch20: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH21 [21:21]
        ///Channel 21 enable clear register.  Writing '0' has no effect
        ch21: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH22 [22:22]
        ///Channel 22 enable clear register.  Writing '0' has no effect
        ch22: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH23 [23:23]
        ///Channel 23 enable clear register.  Writing '0' has no effect
        ch23: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH24 [24:24]
        ///Channel 24 enable clear register.  Writing '0' has no effect
        ch24: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH25 [25:25]
        ///Channel 25 enable clear register.  Writing '0' has no effect
        ch25: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH26 [26:26]
        ///Channel 26 enable clear register.  Writing '0' has no effect
        ch26: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH27 [27:27]
        ///Channel 27 enable clear register.  Writing '0' has no effect
        ch27: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH28 [28:28]
        ///Channel 28 enable clear register.  Writing '0' has no effect
        ch28: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH29 [29:29]
        ///Channel 29 enable clear register.  Writing '0' has no effect
        ch29: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH30 [30:30]
        ///Channel 30 enable clear register.  Writing '0' has no effect
        ch30: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
        ///CH31 [31:31]
        ///Channel 31 enable clear register.  Writing '0' has no effect
        ch31: packed enum(u1) {
            ///Read: channel disabled
            disabled = 0,
            ///Read: channel enabled
            enabled = 1,
        } = .disabled,
    };
    const chenclr_val_write = packed struct {
        ///CH0 [0:0]
        ///Channel 0 enable clear register.  Writing '0' has no effect
        ch0: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH1 [1:1]
        ///Channel 1 enable clear register.  Writing '0' has no effect
        ch1: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH2 [2:2]
        ///Channel 2 enable clear register.  Writing '0' has no effect
        ch2: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH3 [3:3]
        ///Channel 3 enable clear register.  Writing '0' has no effect
        ch3: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH4 [4:4]
        ///Channel 4 enable clear register.  Writing '0' has no effect
        ch4: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH5 [5:5]
        ///Channel 5 enable clear register.  Writing '0' has no effect
        ch5: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH6 [6:6]
        ///Channel 6 enable clear register.  Writing '0' has no effect
        ch6: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH7 [7:7]
        ///Channel 7 enable clear register.  Writing '0' has no effect
        ch7: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH8 [8:8]
        ///Channel 8 enable clear register.  Writing '0' has no effect
        ch8: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH9 [9:9]
        ///Channel 9 enable clear register.  Writing '0' has no effect
        ch9: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH10 [10:10]
        ///Channel 10 enable clear register.  Writing '0' has no effect
        ch10: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH11 [11:11]
        ///Channel 11 enable clear register.  Writing '0' has no effect
        ch11: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH12 [12:12]
        ///Channel 12 enable clear register.  Writing '0' has no effect
        ch12: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH13 [13:13]
        ///Channel 13 enable clear register.  Writing '0' has no effect
        ch13: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH14 [14:14]
        ///Channel 14 enable clear register.  Writing '0' has no effect
        ch14: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH15 [15:15]
        ///Channel 15 enable clear register.  Writing '0' has no effect
        ch15: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH16 [16:16]
        ///Channel 16 enable clear register.  Writing '0' has no effect
        ch16: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH17 [17:17]
        ///Channel 17 enable clear register.  Writing '0' has no effect
        ch17: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH18 [18:18]
        ///Channel 18 enable clear register.  Writing '0' has no effect
        ch18: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH19 [19:19]
        ///Channel 19 enable clear register.  Writing '0' has no effect
        ch19: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH20 [20:20]
        ///Channel 20 enable clear register.  Writing '0' has no effect
        ch20: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH21 [21:21]
        ///Channel 21 enable clear register.  Writing '0' has no effect
        ch21: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH22 [22:22]
        ///Channel 22 enable clear register.  Writing '0' has no effect
        ch22: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH23 [23:23]
        ///Channel 23 enable clear register.  Writing '0' has no effect
        ch23: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH24 [24:24]
        ///Channel 24 enable clear register.  Writing '0' has no effect
        ch24: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH25 [25:25]
        ///Channel 25 enable clear register.  Writing '0' has no effect
        ch25: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH26 [26:26]
        ///Channel 26 enable clear register.  Writing '0' has no effect
        ch26: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH27 [27:27]
        ///Channel 27 enable clear register.  Writing '0' has no effect
        ch27: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH28 [28:28]
        ///Channel 28 enable clear register.  Writing '0' has no effect
        ch28: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH29 [29:29]
        ///Channel 29 enable clear register.  Writing '0' has no effect
        ch29: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH30 [30:30]
        ///Channel 30 enable clear register.  Writing '0' has no effect
        ch30: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///CH31 [31:31]
        ///Channel 31 enable clear register.  Writing '0' has no effect
        ch31: packed enum(u1) {
            ///Write: disable channel
            clear = 1,
            _zero = 0,
        } = ._zero,
    };
    ///Channel enable clear register
    pub const chenclr = RegisterRW(chenclr_val_read, chenclr_val_write).init(0x4001F000 + 0x508);

    //////////////////////////
    ///CHG[%s]
    const chg_val = packed struct {
        ///CH0 [0:0]
        ///Include or exclude channel 0
        ch0: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH1 [1:1]
        ///Include or exclude channel 1
        ch1: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH2 [2:2]
        ///Include or exclude channel 2
        ch2: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH3 [3:3]
        ///Include or exclude channel 3
        ch3: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH4 [4:4]
        ///Include or exclude channel 4
        ch4: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH5 [5:5]
        ///Include or exclude channel 5
        ch5: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH6 [6:6]
        ///Include or exclude channel 6
        ch6: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH7 [7:7]
        ///Include or exclude channel 7
        ch7: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH8 [8:8]
        ///Include or exclude channel 8
        ch8: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH9 [9:9]
        ///Include or exclude channel 9
        ch9: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH10 [10:10]
        ///Include or exclude channel 10
        ch10: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH11 [11:11]
        ///Include or exclude channel 11
        ch11: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH12 [12:12]
        ///Include or exclude channel 12
        ch12: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH13 [13:13]
        ///Include or exclude channel 13
        ch13: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH14 [14:14]
        ///Include or exclude channel 14
        ch14: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH15 [15:15]
        ///Include or exclude channel 15
        ch15: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH16 [16:16]
        ///Include or exclude channel 16
        ch16: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH17 [17:17]
        ///Include or exclude channel 17
        ch17: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH18 [18:18]
        ///Include or exclude channel 18
        ch18: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH19 [19:19]
        ///Include or exclude channel 19
        ch19: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH20 [20:20]
        ///Include or exclude channel 20
        ch20: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH21 [21:21]
        ///Include or exclude channel 21
        ch21: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH22 [22:22]
        ///Include or exclude channel 22
        ch22: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH23 [23:23]
        ///Include or exclude channel 23
        ch23: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH24 [24:24]
        ///Include or exclude channel 24
        ch24: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH25 [25:25]
        ///Include or exclude channel 25
        ch25: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH26 [26:26]
        ///Include or exclude channel 26
        ch26: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH27 [27:27]
        ///Include or exclude channel 27
        ch27: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH28 [28:28]
        ///Include or exclude channel 28
        ch28: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH29 [29:29]
        ///Include or exclude channel 29
        ch29: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH30 [30:30]
        ///Include or exclude channel 30
        ch30: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
        ///CH31 [31:31]
        ///Include or exclude channel 31
        ch31: packed enum(u1) {
            ///Exclude
            excluded = 0,
            ///Include
            included = 1,
        } = .excluded,
    };
    ///Description collection: Channel group n
    pub const chg = Register(chg_val).initRange(0x4001F000 + 0x800, 4, 6);
};

///Memory Watch Unit
pub const mwu = struct {

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///REGION0WA [0:0]
        ///Enable or disable interrupt for event REGION0WA
        region0wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION0RA [1:1]
        ///Enable or disable interrupt for event REGION0RA
        region0ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION1WA [2:2]
        ///Enable or disable interrupt for event REGION1WA
        region1wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION1RA [3:3]
        ///Enable or disable interrupt for event REGION1RA
        region1ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION2WA [4:4]
        ///Enable or disable interrupt for event REGION2WA
        region2wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION2RA [5:5]
        ///Enable or disable interrupt for event REGION2RA
        region2ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION3WA [6:6]
        ///Enable or disable interrupt for event REGION3WA
        region3wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION3RA [7:7]
        ///Enable or disable interrupt for event REGION3RA
        region3ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused8: u16 = 0,
        ///PREGION0WA [24:24]
        ///Enable or disable interrupt for event PREGION0WA
        pregion0wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///PREGION0RA [25:25]
        ///Enable or disable interrupt for event PREGION0RA
        pregion0ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///PREGION1WA [26:26]
        ///Enable or disable interrupt for event PREGION1WA
        pregion1wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///PREGION1RA [27:27]
        ///Enable or disable interrupt for event PREGION1RA
        pregion1ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused28: u4 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40020000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///REGION0WA [0:0]
        ///Write '1' to enable interrupt for event REGION0WA
        region0wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION0RA [1:1]
        ///Write '1' to enable interrupt for event REGION0RA
        region0ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION1WA [2:2]
        ///Write '1' to enable interrupt for event REGION1WA
        region1wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION1RA [3:3]
        ///Write '1' to enable interrupt for event REGION1RA
        region1ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION2WA [4:4]
        ///Write '1' to enable interrupt for event REGION2WA
        region2wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION2RA [5:5]
        ///Write '1' to enable interrupt for event REGION2RA
        region2ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION3WA [6:6]
        ///Write '1' to enable interrupt for event REGION3WA
        region3wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION3RA [7:7]
        ///Write '1' to enable interrupt for event REGION3RA
        region3ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u16 = 0,
        ///PREGION0WA [24:24]
        ///Write '1' to enable interrupt for event PREGION0WA
        pregion0wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION0RA [25:25]
        ///Write '1' to enable interrupt for event PREGION0RA
        pregion0ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION1WA [26:26]
        ///Write '1' to enable interrupt for event PREGION1WA
        pregion1wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION1RA [27:27]
        ///Write '1' to enable interrupt for event PREGION1RA
        pregion1ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused28: u4 = 0,
    };
    const intenset_val_write = packed struct {
        ///REGION0WA [0:0]
        ///Write '1' to enable interrupt for event REGION0WA
        region0wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION0RA [1:1]
        ///Write '1' to enable interrupt for event REGION0RA
        region0ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION1WA [2:2]
        ///Write '1' to enable interrupt for event REGION1WA
        region1wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION1RA [3:3]
        ///Write '1' to enable interrupt for event REGION1RA
        region1ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION2WA [4:4]
        ///Write '1' to enable interrupt for event REGION2WA
        region2wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION2RA [5:5]
        ///Write '1' to enable interrupt for event REGION2RA
        region2ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION3WA [6:6]
        ///Write '1' to enable interrupt for event REGION3WA
        region3wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION3RA [7:7]
        ///Write '1' to enable interrupt for event REGION3RA
        region3ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u16 = 0,
        ///PREGION0WA [24:24]
        ///Write '1' to enable interrupt for event PREGION0WA
        pregion0wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION0RA [25:25]
        ///Write '1' to enable interrupt for event PREGION0RA
        pregion0ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION1WA [26:26]
        ///Write '1' to enable interrupt for event PREGION1WA
        pregion1wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION1RA [27:27]
        ///Write '1' to enable interrupt for event PREGION1RA
        pregion1ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused28: u4 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40020000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///REGION0WA [0:0]
        ///Write '1' to disable interrupt for event REGION0WA
        region0wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION0RA [1:1]
        ///Write '1' to disable interrupt for event REGION0RA
        region0ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION1WA [2:2]
        ///Write '1' to disable interrupt for event REGION1WA
        region1wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION1RA [3:3]
        ///Write '1' to disable interrupt for event REGION1RA
        region1ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION2WA [4:4]
        ///Write '1' to disable interrupt for event REGION2WA
        region2wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION2RA [5:5]
        ///Write '1' to disable interrupt for event REGION2RA
        region2ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION3WA [6:6]
        ///Write '1' to disable interrupt for event REGION3WA
        region3wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION3RA [7:7]
        ///Write '1' to disable interrupt for event REGION3RA
        region3ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u16 = 0,
        ///PREGION0WA [24:24]
        ///Write '1' to disable interrupt for event PREGION0WA
        pregion0wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION0RA [25:25]
        ///Write '1' to disable interrupt for event PREGION0RA
        pregion0ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION1WA [26:26]
        ///Write '1' to disable interrupt for event PREGION1WA
        pregion1wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION1RA [27:27]
        ///Write '1' to disable interrupt for event PREGION1RA
        pregion1ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused28: u4 = 0,
    };
    const intenclr_val_write = packed struct {
        ///REGION0WA [0:0]
        ///Write '1' to disable interrupt for event REGION0WA
        region0wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION0RA [1:1]
        ///Write '1' to disable interrupt for event REGION0RA
        region0ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION1WA [2:2]
        ///Write '1' to disable interrupt for event REGION1WA
        region1wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION1RA [3:3]
        ///Write '1' to disable interrupt for event REGION1RA
        region1ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION2WA [4:4]
        ///Write '1' to disable interrupt for event REGION2WA
        region2wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION2RA [5:5]
        ///Write '1' to disable interrupt for event REGION2RA
        region2ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION3WA [6:6]
        ///Write '1' to disable interrupt for event REGION3WA
        region3wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION3RA [7:7]
        ///Write '1' to disable interrupt for event REGION3RA
        region3ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u16 = 0,
        ///PREGION0WA [24:24]
        ///Write '1' to disable interrupt for event PREGION0WA
        pregion0wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION0RA [25:25]
        ///Write '1' to disable interrupt for event PREGION0RA
        pregion0ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION1WA [26:26]
        ///Write '1' to disable interrupt for event PREGION1WA
        pregion1wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION1RA [27:27]
        ///Write '1' to disable interrupt for event PREGION1RA
        pregion1ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused28: u4 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40020000 + 0x308);

    //////////////////////////
    ///NMIEN
    const nmien_val = packed struct {
        ///REGION0WA [0:0]
        ///Enable or disable interrupt for event REGION0WA
        region0wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION0RA [1:1]
        ///Enable or disable interrupt for event REGION0RA
        region0ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION1WA [2:2]
        ///Enable or disable interrupt for event REGION1WA
        region1wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION1RA [3:3]
        ///Enable or disable interrupt for event REGION1RA
        region1ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION2WA [4:4]
        ///Enable or disable interrupt for event REGION2WA
        region2wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION2RA [5:5]
        ///Enable or disable interrupt for event REGION2RA
        region2ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION3WA [6:6]
        ///Enable or disable interrupt for event REGION3WA
        region3wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///REGION3RA [7:7]
        ///Enable or disable interrupt for event REGION3RA
        region3ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused8: u16 = 0,
        ///PREGION0WA [24:24]
        ///Enable or disable interrupt for event PREGION0WA
        pregion0wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///PREGION0RA [25:25]
        ///Enable or disable interrupt for event PREGION0RA
        pregion0ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///PREGION1WA [26:26]
        ///Enable or disable interrupt for event PREGION1WA
        pregion1wa: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///PREGION1RA [27:27]
        ///Enable or disable interrupt for event PREGION1RA
        pregion1ra: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused28: u4 = 0,
    };
    ///Enable or disable interrupt
    pub const nmien = Register(nmien_val).init(0x40020000 + 0x320);

    //////////////////////////
    ///NMIENSET
    const nmienset_val_read = packed struct {
        ///REGION0WA [0:0]
        ///Write '1' to enable interrupt for event REGION0WA
        region0wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION0RA [1:1]
        ///Write '1' to enable interrupt for event REGION0RA
        region0ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION1WA [2:2]
        ///Write '1' to enable interrupt for event REGION1WA
        region1wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION1RA [3:3]
        ///Write '1' to enable interrupt for event REGION1RA
        region1ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION2WA [4:4]
        ///Write '1' to enable interrupt for event REGION2WA
        region2wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION2RA [5:5]
        ///Write '1' to enable interrupt for event REGION2RA
        region2ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION3WA [6:6]
        ///Write '1' to enable interrupt for event REGION3WA
        region3wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION3RA [7:7]
        ///Write '1' to enable interrupt for event REGION3RA
        region3ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u16 = 0,
        ///PREGION0WA [24:24]
        ///Write '1' to enable interrupt for event PREGION0WA
        pregion0wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION0RA [25:25]
        ///Write '1' to enable interrupt for event PREGION0RA
        pregion0ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION1WA [26:26]
        ///Write '1' to enable interrupt for event PREGION1WA
        pregion1wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION1RA [27:27]
        ///Write '1' to enable interrupt for event PREGION1RA
        pregion1ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused28: u4 = 0,
    };
    const nmienset_val_write = packed struct {
        ///REGION0WA [0:0]
        ///Write '1' to enable interrupt for event REGION0WA
        region0wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION0RA [1:1]
        ///Write '1' to enable interrupt for event REGION0RA
        region0ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION1WA [2:2]
        ///Write '1' to enable interrupt for event REGION1WA
        region1wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION1RA [3:3]
        ///Write '1' to enable interrupt for event REGION1RA
        region1ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION2WA [4:4]
        ///Write '1' to enable interrupt for event REGION2WA
        region2wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION2RA [5:5]
        ///Write '1' to enable interrupt for event REGION2RA
        region2ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION3WA [6:6]
        ///Write '1' to enable interrupt for event REGION3WA
        region3wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///REGION3RA [7:7]
        ///Write '1' to enable interrupt for event REGION3RA
        region3ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u16 = 0,
        ///PREGION0WA [24:24]
        ///Write '1' to enable interrupt for event PREGION0WA
        pregion0wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION0RA [25:25]
        ///Write '1' to enable interrupt for event PREGION0RA
        pregion0ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION1WA [26:26]
        ///Write '1' to enable interrupt for event PREGION1WA
        pregion1wa: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION1RA [27:27]
        ///Write '1' to enable interrupt for event PREGION1RA
        pregion1ra: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused28: u4 = 0,
    };
    ///Enable interrupt
    pub const nmienset = RegisterRW(nmienset_val_read, nmienset_val_write).init(0x40020000 + 0x324);

    //////////////////////////
    ///NMIENCLR
    const nmienclr_val_read = packed struct {
        ///REGION0WA [0:0]
        ///Write '1' to disable interrupt for event REGION0WA
        region0wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION0RA [1:1]
        ///Write '1' to disable interrupt for event REGION0RA
        region0ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION1WA [2:2]
        ///Write '1' to disable interrupt for event REGION1WA
        region1wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION1RA [3:3]
        ///Write '1' to disable interrupt for event REGION1RA
        region1ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION2WA [4:4]
        ///Write '1' to disable interrupt for event REGION2WA
        region2wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION2RA [5:5]
        ///Write '1' to disable interrupt for event REGION2RA
        region2ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION3WA [6:6]
        ///Write '1' to disable interrupt for event REGION3WA
        region3wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///REGION3RA [7:7]
        ///Write '1' to disable interrupt for event REGION3RA
        region3ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u16 = 0,
        ///PREGION0WA [24:24]
        ///Write '1' to disable interrupt for event PREGION0WA
        pregion0wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION0RA [25:25]
        ///Write '1' to disable interrupt for event PREGION0RA
        pregion0ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION1WA [26:26]
        ///Write '1' to disable interrupt for event PREGION1WA
        pregion1wa: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PREGION1RA [27:27]
        ///Write '1' to disable interrupt for event PREGION1RA
        pregion1ra: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused28: u4 = 0,
    };
    const nmienclr_val_write = packed struct {
        ///REGION0WA [0:0]
        ///Write '1' to disable interrupt for event REGION0WA
        region0wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION0RA [1:1]
        ///Write '1' to disable interrupt for event REGION0RA
        region0ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION1WA [2:2]
        ///Write '1' to disable interrupt for event REGION1WA
        region1wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION1RA [3:3]
        ///Write '1' to disable interrupt for event REGION1RA
        region1ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION2WA [4:4]
        ///Write '1' to disable interrupt for event REGION2WA
        region2wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION2RA [5:5]
        ///Write '1' to disable interrupt for event REGION2RA
        region2ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION3WA [6:6]
        ///Write '1' to disable interrupt for event REGION3WA
        region3wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///REGION3RA [7:7]
        ///Write '1' to disable interrupt for event REGION3RA
        region3ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u16 = 0,
        ///PREGION0WA [24:24]
        ///Write '1' to disable interrupt for event PREGION0WA
        pregion0wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION0RA [25:25]
        ///Write '1' to disable interrupt for event PREGION0RA
        pregion0ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION1WA [26:26]
        ///Write '1' to disable interrupt for event PREGION1WA
        pregion1wa: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PREGION1RA [27:27]
        ///Write '1' to disable interrupt for event PREGION1RA
        pregion1ra: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused28: u4 = 0,
    };
    ///Disable interrupt
    pub const nmienclr = RegisterRW(nmienclr_val_read, nmienclr_val_write).init(0x40020000 + 0x328);

    //////////////////////////
    ///REGIONEN
    const regionen_val = packed struct {
        ///RGN0WA [0:0]
        ///Enable/disable write access watch in region[0]
        rgn0wa: packed enum(u1) {
            ///Disable write access watch in this region
            disable = 0,
            ///Enable write access watch in this region
            enable = 1,
        } = .disable,
        ///RGN0RA [1:1]
        ///Enable/disable read access watch in region[0]
        rgn0ra: packed enum(u1) {
            ///Disable read access watch in this region
            disable = 0,
            ///Enable read access watch in this region
            enable = 1,
        } = .disable,
        ///RGN1WA [2:2]
        ///Enable/disable write access watch in region[1]
        rgn1wa: packed enum(u1) {
            ///Disable write access watch in this region
            disable = 0,
            ///Enable write access watch in this region
            enable = 1,
        } = .disable,
        ///RGN1RA [3:3]
        ///Enable/disable read access watch in region[1]
        rgn1ra: packed enum(u1) {
            ///Disable read access watch in this region
            disable = 0,
            ///Enable read access watch in this region
            enable = 1,
        } = .disable,
        ///RGN2WA [4:4]
        ///Enable/disable write access watch in region[2]
        rgn2wa: packed enum(u1) {
            ///Disable write access watch in this region
            disable = 0,
            ///Enable write access watch in this region
            enable = 1,
        } = .disable,
        ///RGN2RA [5:5]
        ///Enable/disable read access watch in region[2]
        rgn2ra: packed enum(u1) {
            ///Disable read access watch in this region
            disable = 0,
            ///Enable read access watch in this region
            enable = 1,
        } = .disable,
        ///RGN3WA [6:6]
        ///Enable/disable write access watch in region[3]
        rgn3wa: packed enum(u1) {
            ///Disable write access watch in this region
            disable = 0,
            ///Enable write access watch in this region
            enable = 1,
        } = .disable,
        ///RGN3RA [7:7]
        ///Enable/disable read access watch in region[3]
        rgn3ra: packed enum(u1) {
            ///Disable read access watch in this region
            disable = 0,
            ///Enable read access watch in this region
            enable = 1,
        } = .disable,
        _unused8: u16 = 0,
        ///PRGN0WA [24:24]
        ///Enable/disable write access watch in PREGION[0]
        prgn0wa: packed enum(u1) {
            ///Disable write access watch in this PREGION
            disable = 0,
            ///Enable write access watch in this PREGION
            enable = 1,
        } = .disable,
        ///PRGN0RA [25:25]
        ///Enable/disable read access watch in PREGION[0]
        prgn0ra: packed enum(u1) {
            ///Disable read access watch in this PREGION
            disable = 0,
            ///Enable read access watch in this PREGION
            enable = 1,
        } = .disable,
        ///PRGN1WA [26:26]
        ///Enable/disable write access watch in PREGION[1]
        prgn1wa: packed enum(u1) {
            ///Disable write access watch in this PREGION
            disable = 0,
            ///Enable write access watch in this PREGION
            enable = 1,
        } = .disable,
        ///PRGN1RA [27:27]
        ///Enable/disable read access watch in PREGION[1]
        prgn1ra: packed enum(u1) {
            ///Disable read access watch in this PREGION
            disable = 0,
            ///Enable read access watch in this PREGION
            enable = 1,
        } = .disable,
        _unused28: u4 = 0,
    };
    ///Enable/disable regions watch
    pub const regionen = Register(regionen_val).init(0x40020000 + 0x510);

    //////////////////////////
    ///REGIONENSET
    const regionenset_val_read = packed struct {
        ///RGN0WA [0:0]
        ///Enable write access watch in region[0]
        rgn0wa: packed enum(u1) {
            ///Write access watch in this region is disabled
            disabled = 0,
            ///Write access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN0RA [1:1]
        ///Enable read access watch in region[0]
        rgn0ra: packed enum(u1) {
            ///Read access watch in this region is disabled
            disabled = 0,
            ///Read access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN1WA [2:2]
        ///Enable write access watch in region[1]
        rgn1wa: packed enum(u1) {
            ///Write access watch in this region is disabled
            disabled = 0,
            ///Write access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN1RA [3:3]
        ///Enable read access watch in region[1]
        rgn1ra: packed enum(u1) {
            ///Read access watch in this region is disabled
            disabled = 0,
            ///Read access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN2WA [4:4]
        ///Enable write access watch in region[2]
        rgn2wa: packed enum(u1) {
            ///Write access watch in this region is disabled
            disabled = 0,
            ///Write access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN2RA [5:5]
        ///Enable read access watch in region[2]
        rgn2ra: packed enum(u1) {
            ///Read access watch in this region is disabled
            disabled = 0,
            ///Read access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN3WA [6:6]
        ///Enable write access watch in region[3]
        rgn3wa: packed enum(u1) {
            ///Write access watch in this region is disabled
            disabled = 0,
            ///Write access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN3RA [7:7]
        ///Enable read access watch in region[3]
        rgn3ra: packed enum(u1) {
            ///Read access watch in this region is disabled
            disabled = 0,
            ///Read access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        _unused8: u16 = 0,
        ///PRGN0WA [24:24]
        ///Enable write access watch in PREGION[0]
        prgn0wa: packed enum(u1) {
            ///Write access watch in this PREGION is disabled
            disabled = 0,
            ///Write access watch in this PREGION is enabled
            enabled = 1,
        } = .disabled,
        ///PRGN0RA [25:25]
        ///Enable read access watch in PREGION[0]
        prgn0ra: packed enum(u1) {
            ///Read access watch in this PREGION is disabled
            disabled = 0,
            ///Read access watch in this PREGION is enabled
            enabled = 1,
        } = .disabled,
        ///PRGN1WA [26:26]
        ///Enable write access watch in PREGION[1]
        prgn1wa: packed enum(u1) {
            ///Write access watch in this PREGION is disabled
            disabled = 0,
            ///Write access watch in this PREGION is enabled
            enabled = 1,
        } = .disabled,
        ///PRGN1RA [27:27]
        ///Enable read access watch in PREGION[1]
        prgn1ra: packed enum(u1) {
            ///Read access watch in this PREGION is disabled
            disabled = 0,
            ///Read access watch in this PREGION is enabled
            enabled = 1,
        } = .disabled,
        _unused28: u4 = 0,
    };
    const regionenset_val_write = packed struct {
        ///RGN0WA [0:0]
        ///Enable write access watch in region[0]
        rgn0wa: packed enum(u1) {
            ///Enable write access watch in this region
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RGN0RA [1:1]
        ///Enable read access watch in region[0]
        rgn0ra: packed enum(u1) {
            ///Enable read access watch in this region
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RGN1WA [2:2]
        ///Enable write access watch in region[1]
        rgn1wa: packed enum(u1) {
            ///Enable write access watch in this region
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RGN1RA [3:3]
        ///Enable read access watch in region[1]
        rgn1ra: packed enum(u1) {
            ///Enable read access watch in this region
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RGN2WA [4:4]
        ///Enable write access watch in region[2]
        rgn2wa: packed enum(u1) {
            ///Enable write access watch in this region
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RGN2RA [5:5]
        ///Enable read access watch in region[2]
        rgn2ra: packed enum(u1) {
            ///Enable read access watch in this region
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RGN3WA [6:6]
        ///Enable write access watch in region[3]
        rgn3wa: packed enum(u1) {
            ///Enable write access watch in this region
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RGN3RA [7:7]
        ///Enable read access watch in region[3]
        rgn3ra: packed enum(u1) {
            ///Enable read access watch in this region
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u16 = 0,
        ///PRGN0WA [24:24]
        ///Enable write access watch in PREGION[0]
        prgn0wa: packed enum(u1) {
            ///Enable write access watch in this PREGION
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PRGN0RA [25:25]
        ///Enable read access watch in PREGION[0]
        prgn0ra: packed enum(u1) {
            ///Enable read access watch in this PREGION
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PRGN1WA [26:26]
        ///Enable write access watch in PREGION[1]
        prgn1wa: packed enum(u1) {
            ///Enable write access watch in this PREGION
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PRGN1RA [27:27]
        ///Enable read access watch in PREGION[1]
        prgn1ra: packed enum(u1) {
            ///Enable read access watch in this PREGION
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused28: u4 = 0,
    };
    ///Enable regions watch
    pub const regionenset = RegisterRW(regionenset_val_read, regionenset_val_write).init(0x40020000 + 0x514);

    //////////////////////////
    ///REGIONENCLR
    const regionenclr_val_read = packed struct {
        ///RGN0WA [0:0]
        ///Disable write access watch in region[0]
        rgn0wa: packed enum(u1) {
            ///Write access watch in this region is disabled
            disabled = 0,
            ///Write access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN0RA [1:1]
        ///Disable read access watch in region[0]
        rgn0ra: packed enum(u1) {
            ///Read access watch in this region is disabled
            disabled = 0,
            ///Read access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN1WA [2:2]
        ///Disable write access watch in region[1]
        rgn1wa: packed enum(u1) {
            ///Write access watch in this region is disabled
            disabled = 0,
            ///Write access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN1RA [3:3]
        ///Disable read access watch in region[1]
        rgn1ra: packed enum(u1) {
            ///Read access watch in this region is disabled
            disabled = 0,
            ///Read access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN2WA [4:4]
        ///Disable write access watch in region[2]
        rgn2wa: packed enum(u1) {
            ///Write access watch in this region is disabled
            disabled = 0,
            ///Write access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN2RA [5:5]
        ///Disable read access watch in region[2]
        rgn2ra: packed enum(u1) {
            ///Read access watch in this region is disabled
            disabled = 0,
            ///Read access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN3WA [6:6]
        ///Disable write access watch in region[3]
        rgn3wa: packed enum(u1) {
            ///Write access watch in this region is disabled
            disabled = 0,
            ///Write access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        ///RGN3RA [7:7]
        ///Disable read access watch in region[3]
        rgn3ra: packed enum(u1) {
            ///Read access watch in this region is disabled
            disabled = 0,
            ///Read access watch in this region is enabled
            enabled = 1,
        } = .disabled,
        _unused8: u16 = 0,
        ///PRGN0WA [24:24]
        ///Disable write access watch in PREGION[0]
        prgn0wa: packed enum(u1) {
            ///Write access watch in this PREGION is disabled
            disabled = 0,
            ///Write access watch in this PREGION is enabled
            enabled = 1,
        } = .disabled,
        ///PRGN0RA [25:25]
        ///Disable read access watch in PREGION[0]
        prgn0ra: packed enum(u1) {
            ///Read access watch in this PREGION is disabled
            disabled = 0,
            ///Read access watch in this PREGION is enabled
            enabled = 1,
        } = .disabled,
        ///PRGN1WA [26:26]
        ///Disable write access watch in PREGION[1]
        prgn1wa: packed enum(u1) {
            ///Write access watch in this PREGION is disabled
            disabled = 0,
            ///Write access watch in this PREGION is enabled
            enabled = 1,
        } = .disabled,
        ///PRGN1RA [27:27]
        ///Disable read access watch in PREGION[1]
        prgn1ra: packed enum(u1) {
            ///Read access watch in this PREGION is disabled
            disabled = 0,
            ///Read access watch in this PREGION is enabled
            enabled = 1,
        } = .disabled,
        _unused28: u4 = 0,
    };
    const regionenclr_val_write = packed struct {
        ///RGN0WA [0:0]
        ///Disable write access watch in region[0]
        rgn0wa: packed enum(u1) {
            ///Disable write access watch in this region
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RGN0RA [1:1]
        ///Disable read access watch in region[0]
        rgn0ra: packed enum(u1) {
            ///Disable read access watch in this region
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RGN1WA [2:2]
        ///Disable write access watch in region[1]
        rgn1wa: packed enum(u1) {
            ///Disable write access watch in this region
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RGN1RA [3:3]
        ///Disable read access watch in region[1]
        rgn1ra: packed enum(u1) {
            ///Disable read access watch in this region
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RGN2WA [4:4]
        ///Disable write access watch in region[2]
        rgn2wa: packed enum(u1) {
            ///Disable write access watch in this region
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RGN2RA [5:5]
        ///Disable read access watch in region[2]
        rgn2ra: packed enum(u1) {
            ///Disable read access watch in this region
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RGN3WA [6:6]
        ///Disable write access watch in region[3]
        rgn3wa: packed enum(u1) {
            ///Disable write access watch in this region
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RGN3RA [7:7]
        ///Disable read access watch in region[3]
        rgn3ra: packed enum(u1) {
            ///Disable read access watch in this region
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u16 = 0,
        ///PRGN0WA [24:24]
        ///Disable write access watch in PREGION[0]
        prgn0wa: packed enum(u1) {
            ///Disable write access watch in this PREGION
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PRGN0RA [25:25]
        ///Disable read access watch in PREGION[0]
        prgn0ra: packed enum(u1) {
            ///Disable read access watch in this PREGION
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PRGN1WA [26:26]
        ///Disable write access watch in PREGION[1]
        prgn1wa: packed enum(u1) {
            ///Disable write access watch in this PREGION
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PRGN1RA [27:27]
        ///Disable read access watch in PREGION[1]
        prgn1ra: packed enum(u1) {
            ///Disable read access watch in this PREGION
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused28: u4 = 0,
    };
    ///Disable regions watch
    pub const regionenclr = RegisterRW(regionenclr_val_read, regionenclr_val_write).init(0x40020000 + 0x518);
};

///Pulse width modulation unit 1
pub const pwm1 = struct {

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40021000 + 0x004);

    //////////////////////////
    ///TASKS_SEQSTART[%s]
    const tasks_seqstart_val = packed struct {
        ///TASKS_SEQSTART [0:0]
        ///Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
        tasks_seqstart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
    pub const tasks_seqstart = RegisterRW(void, tasks_seqstart_val).initRange(0x40021000 + 0x008, 4, 2);

    //////////////////////////
    ///TASKS_NEXTSTEP
    const tasks_nextstep_val = packed struct {
        ///TASKS_NEXTSTEP [0:0]
        ///Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
        tasks_nextstep: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
    pub const tasks_nextstep = RegisterRW(void, tasks_nextstep_val).init(0x40021000 + 0x010);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///Response to STOP task, emitted when PWM pulses are no longer generated
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Response to STOP task, emitted when PWM pulses are no longer generated
    pub const events_stopped = Register(events_stopped_val).init(0x40021000 + 0x104);

    //////////////////////////
    ///EVENTS_SEQSTARTED[%s]
    const events_seqstarted_val = packed struct {
        ///EVENTS_SEQSTARTED [0:0]
        ///First PWM period started on sequence n
        events_seqstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: First PWM period started on sequence n
    pub const events_seqstarted = Register(events_seqstarted_val).initRange(0x40021000 + 0x108, 4, 2);

    //////////////////////////
    ///EVENTS_SEQEND[%s]
    const events_seqend_val = packed struct {
        ///EVENTS_SEQEND [0:0]
        ///Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
        events_seqend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
    pub const events_seqend = Register(events_seqend_val).initRange(0x40021000 + 0x110, 4, 2);

    //////////////////////////
    ///EVENTS_PWMPERIODEND
    const events_pwmperiodend_val = packed struct {
        ///EVENTS_PWMPERIODEND [0:0]
        ///Emitted at the end of each PWM period
        events_pwmperiodend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Emitted at the end of each PWM period
    pub const events_pwmperiodend = Register(events_pwmperiodend_val).init(0x40021000 + 0x118);

    //////////////////////////
    ///EVENTS_LOOPSDONE
    const events_loopsdone_val = packed struct {
        ///EVENTS_LOOPSDONE [0:0]
        ///Concatenated sequences have been played the amount of times defined in LOOP.CNT
        events_loopsdone: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Concatenated sequences have been played the amount of times defined in LOOP.CNT
    pub const events_loopsdone = Register(events_loopsdone_val).init(0x40021000 + 0x11C);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///SEQEND0_STOP [0:0]
        ///Shortcut between event SEQEND[0] and task STOP
        seqend0_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///SEQEND1_STOP [1:1]
        ///Shortcut between event SEQEND[1] and task STOP
        seqend1_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_SEQSTART0 [2:2]
        ///Shortcut between event LOOPSDONE and task SEQSTART[0]
        loopsdone_seqstart0: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_SEQSTART1 [3:3]
        ///Shortcut between event LOOPSDONE and task SEQSTART[1]
        loopsdone_seqstart1: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_STOP [4:4]
        ///Shortcut between event LOOPSDONE and task STOP
        loopsdone_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused5: u27 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40021000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Enable or disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Enable or disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Enable or disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Enable or disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Enable or disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Enable or disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40021000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to enable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to enable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Write '1' to enable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Write '1' to enable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Write '1' to enable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Write '1' to enable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to enable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to enable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND0 [4:4]
        ///Write '1' to enable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND1 [5:5]
        ///Write '1' to enable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PWMPERIODEND [6:6]
        ///Write '1' to enable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///LOOPSDONE [7:7]
        ///Write '1' to enable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40021000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Write '1' to disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Write '1' to disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Write '1' to disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Write '1' to disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND0 [4:4]
        ///Write '1' to disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND1 [5:5]
        ///Write '1' to disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PWMPERIODEND [6:6]
        ///Write '1' to disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///LOOPSDONE [7:7]
        ///Write '1' to disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40021000 + 0x308);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:0]
        ///Enable or disable PWM module
        enable: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///PWM module enable register
    pub const enable = Register(enable_val).init(0x40021000 + 0x500);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///UPDOWN [0:0]
        ///Selects up mode or up-and-down mode for the counter
        updown: packed enum(u1) {
            ///Up counter, edge-aligned PWM duty cycle
            up = 0,
            ///Up and down counter, center-aligned PWM duty cycle
            up_and_down = 1,
        } = .up,
        _unused1: u31 = 0,
    };
    ///Selects operating mode of the wave counter
    pub const mode = Register(mode_val).init(0x40021000 + 0x504);

    //////////////////////////
    ///COUNTERTOP
    const countertop_val = packed struct {
        ///COUNTERTOP [0:14]
        ///Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used.
        countertop: u15 = 1023,
        _unused15: u17 = 0,
    };
    ///Value up to which the pulse generator counter counts
    pub const countertop = Register(countertop_val).init(0x40021000 + 0x508);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:2]
        ///Prescaler of PWM_CLK
        prescaler: packed enum(u3) {
            ///Divide by 1 (16 MHz)
            div_1 = 0,
            ///Divide by 2 (8 MHz)
            div_2 = 1,
            ///Divide by 4 (4 MHz)
            div_4 = 2,
            ///Divide by 8 (2 MHz)
            div_8 = 3,
            ///Divide by 16 (1 MHz)
            div_16 = 4,
            ///Divide by 32 (500 kHz)
            div_32 = 5,
            ///Divide by 64 (250 kHz)
            div_64 = 6,
            ///Divide by 128 (125 kHz)
            div_128 = 7,
        } = .div_1,
        _unused3: u29 = 0,
    };
    ///Configuration for PWM_CLK
    pub const prescaler = Register(prescaler_val).init(0x40021000 + 0x50C);

    //////////////////////////
    ///DECODER
    const decoder_val = packed struct {
        ///LOAD [0:1]
        ///How a sequence is read from RAM and spread to the compare register
        load: packed enum(u2) {
            ///1st half word (16-bit) used in all PWM channels 0..3
            common = 0,
            ///1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3
            grouped = 1,
            ///1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3
            individual = 2,
            ///1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP
            wave_form = 3,
        } = .common,
        _unused2: u6 = 0,
        ///MODE [8:8]
        ///Selects source for advancing the active sequence
        mode: packed enum(u1) {
            ///SEQ[n].REFRESH is used to determine loading internal compare registers
            refresh_count = 0,
            ///NEXTSTEP task causes a new value to be loaded to internal compare registers
            next_step = 1,
        } = .refresh_count,
        _unused9: u23 = 0,
    };
    ///Configuration of the decoder
    pub const decoder = Register(decoder_val).init(0x40021000 + 0x510);

    //////////////////////////
    ///LOOP
    const loop_val = packed struct {
        ///CNT [0:15]
        ///Number of playbacks of pattern cycles
        cnt: packed enum(u16) {
            ///Looping disabled (stop at the end of the sequence)
            disabled = 0,
        } = .disabled,
        _unused16: u16 = 0,
    };
    ///Number of playbacks of a loop
    pub const loop = Register(loop_val).init(0x40021000 + 0x514);
};

///Pulse width modulation unit 2
pub const pwm2 = struct {

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40022000 + 0x004);

    //////////////////////////
    ///TASKS_SEQSTART[%s]
    const tasks_seqstart_val = packed struct {
        ///TASKS_SEQSTART [0:0]
        ///Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
        tasks_seqstart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
    pub const tasks_seqstart = RegisterRW(void, tasks_seqstart_val).initRange(0x40022000 + 0x008, 4, 2);

    //////////////////////////
    ///TASKS_NEXTSTEP
    const tasks_nextstep_val = packed struct {
        ///TASKS_NEXTSTEP [0:0]
        ///Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
        tasks_nextstep: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
    pub const tasks_nextstep = RegisterRW(void, tasks_nextstep_val).init(0x40022000 + 0x010);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///Response to STOP task, emitted when PWM pulses are no longer generated
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Response to STOP task, emitted when PWM pulses are no longer generated
    pub const events_stopped = Register(events_stopped_val).init(0x40022000 + 0x104);

    //////////////////////////
    ///EVENTS_SEQSTARTED[%s]
    const events_seqstarted_val = packed struct {
        ///EVENTS_SEQSTARTED [0:0]
        ///First PWM period started on sequence n
        events_seqstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: First PWM period started on sequence n
    pub const events_seqstarted = Register(events_seqstarted_val).initRange(0x40022000 + 0x108, 4, 2);

    //////////////////////////
    ///EVENTS_SEQEND[%s]
    const events_seqend_val = packed struct {
        ///EVENTS_SEQEND [0:0]
        ///Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
        events_seqend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
    pub const events_seqend = Register(events_seqend_val).initRange(0x40022000 + 0x110, 4, 2);

    //////////////////////////
    ///EVENTS_PWMPERIODEND
    const events_pwmperiodend_val = packed struct {
        ///EVENTS_PWMPERIODEND [0:0]
        ///Emitted at the end of each PWM period
        events_pwmperiodend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Emitted at the end of each PWM period
    pub const events_pwmperiodend = Register(events_pwmperiodend_val).init(0x40022000 + 0x118);

    //////////////////////////
    ///EVENTS_LOOPSDONE
    const events_loopsdone_val = packed struct {
        ///EVENTS_LOOPSDONE [0:0]
        ///Concatenated sequences have been played the amount of times defined in LOOP.CNT
        events_loopsdone: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Concatenated sequences have been played the amount of times defined in LOOP.CNT
    pub const events_loopsdone = Register(events_loopsdone_val).init(0x40022000 + 0x11C);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///SEQEND0_STOP [0:0]
        ///Shortcut between event SEQEND[0] and task STOP
        seqend0_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///SEQEND1_STOP [1:1]
        ///Shortcut between event SEQEND[1] and task STOP
        seqend1_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_SEQSTART0 [2:2]
        ///Shortcut between event LOOPSDONE and task SEQSTART[0]
        loopsdone_seqstart0: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_SEQSTART1 [3:3]
        ///Shortcut between event LOOPSDONE and task SEQSTART[1]
        loopsdone_seqstart1: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_STOP [4:4]
        ///Shortcut between event LOOPSDONE and task STOP
        loopsdone_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused5: u27 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40022000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Enable or disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Enable or disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Enable or disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Enable or disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Enable or disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Enable or disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40022000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to enable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to enable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Write '1' to enable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Write '1' to enable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Write '1' to enable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Write '1' to enable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to enable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to enable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND0 [4:4]
        ///Write '1' to enable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND1 [5:5]
        ///Write '1' to enable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PWMPERIODEND [6:6]
        ///Write '1' to enable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///LOOPSDONE [7:7]
        ///Write '1' to enable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40022000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Write '1' to disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Write '1' to disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Write '1' to disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Write '1' to disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND0 [4:4]
        ///Write '1' to disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND1 [5:5]
        ///Write '1' to disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PWMPERIODEND [6:6]
        ///Write '1' to disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///LOOPSDONE [7:7]
        ///Write '1' to disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40022000 + 0x308);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:0]
        ///Enable or disable PWM module
        enable: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///PWM module enable register
    pub const enable = Register(enable_val).init(0x40022000 + 0x500);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///UPDOWN [0:0]
        ///Selects up mode or up-and-down mode for the counter
        updown: packed enum(u1) {
            ///Up counter, edge-aligned PWM duty cycle
            up = 0,
            ///Up and down counter, center-aligned PWM duty cycle
            up_and_down = 1,
        } = .up,
        _unused1: u31 = 0,
    };
    ///Selects operating mode of the wave counter
    pub const mode = Register(mode_val).init(0x40022000 + 0x504);

    //////////////////////////
    ///COUNTERTOP
    const countertop_val = packed struct {
        ///COUNTERTOP [0:14]
        ///Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used.
        countertop: u15 = 1023,
        _unused15: u17 = 0,
    };
    ///Value up to which the pulse generator counter counts
    pub const countertop = Register(countertop_val).init(0x40022000 + 0x508);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:2]
        ///Prescaler of PWM_CLK
        prescaler: packed enum(u3) {
            ///Divide by 1 (16 MHz)
            div_1 = 0,
            ///Divide by 2 (8 MHz)
            div_2 = 1,
            ///Divide by 4 (4 MHz)
            div_4 = 2,
            ///Divide by 8 (2 MHz)
            div_8 = 3,
            ///Divide by 16 (1 MHz)
            div_16 = 4,
            ///Divide by 32 (500 kHz)
            div_32 = 5,
            ///Divide by 64 (250 kHz)
            div_64 = 6,
            ///Divide by 128 (125 kHz)
            div_128 = 7,
        } = .div_1,
        _unused3: u29 = 0,
    };
    ///Configuration for PWM_CLK
    pub const prescaler = Register(prescaler_val).init(0x40022000 + 0x50C);

    //////////////////////////
    ///DECODER
    const decoder_val = packed struct {
        ///LOAD [0:1]
        ///How a sequence is read from RAM and spread to the compare register
        load: packed enum(u2) {
            ///1st half word (16-bit) used in all PWM channels 0..3
            common = 0,
            ///1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3
            grouped = 1,
            ///1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3
            individual = 2,
            ///1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP
            wave_form = 3,
        } = .common,
        _unused2: u6 = 0,
        ///MODE [8:8]
        ///Selects source for advancing the active sequence
        mode: packed enum(u1) {
            ///SEQ[n].REFRESH is used to determine loading internal compare registers
            refresh_count = 0,
            ///NEXTSTEP task causes a new value to be loaded to internal compare registers
            next_step = 1,
        } = .refresh_count,
        _unused9: u23 = 0,
    };
    ///Configuration of the decoder
    pub const decoder = Register(decoder_val).init(0x40022000 + 0x510);

    //////////////////////////
    ///LOOP
    const loop_val = packed struct {
        ///CNT [0:15]
        ///Number of playbacks of pattern cycles
        cnt: packed enum(u16) {
            ///Looping disabled (stop at the end of the sequence)
            disabled = 0,
        } = .disabled,
        _unused16: u16 = 0,
    };
    ///Number of playbacks of a loop
    pub const loop = Register(loop_val).init(0x40022000 + 0x514);
};

///Serial Peripheral Interface 2
pub const spi2 = struct {

    //////////////////////////
    ///EVENTS_READY
    const events_ready_val = packed struct {
        ///EVENTS_READY [0:0]
        ///TXD byte sent and RXD byte received
        events_ready: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///TXD byte sent and RXD byte received
    pub const events_ready = Register(events_ready_val).init(0x40023000 + 0x108);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to enable interrupt for event READY
        ready: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40023000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u2 = 0,
        ///READY [2:2]
        ///Write '1' to disable interrupt for event READY
        ready: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u29 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40023000 + 0x308);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable SPI
        enable: packed enum(u4) {
            ///Disable SPI
            disabled = 0,
            ///Enable SPI
            enabled = 1,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable SPI
    pub const enable = Register(enable_val).init(0x40023000 + 0x500);

    //////////////////////////
    ///RXD
    const rxd_val = packed struct {
        ///RXD [0:7]
        ///RX data received. Double buffered
        rxd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///RXD register
    pub const rxd = RegisterRW(rxd_val, void).init(0x40023000 + 0x518);

    //////////////////////////
    ///TXD
    const txd_val = packed struct {
        ///TXD [0:7]
        ///TX data to send. Double buffered
        txd: u8 = 0,
        _unused8: u24 = 0,
    };
    ///TXD register
    pub const txd = Register(txd_val).init(0x40023000 + 0x51C);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///SPI master data rate
        frequency: packed enum(u32) {
            ///125 kbps
            k125 = 0x02000000,
            ///250 kbps
            k250 = 0x04000000,
            ///500 kbps
            k500 = 0x08000000,
            ///1 Mbps
            m1 = 0x10000000,
            ///2 Mbps
            m2 = 0x20000000,
            ///4 Mbps
            m4 = 0x40000000,
            ///8 Mbps
            m8 = 0x80000000,
            _zero = 0,
        } = ._zero,
    };
    ///SPI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x40023000 + 0x524);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ORDER [0:0]
        ///Bit order
        order: packed enum(u1) {
            ///Most significant bit shifted out first
            msb_first = 0,
            ///Least significant bit shifted out first
            lsb_first = 1,
        } = .msb_first,
        ///CPHA [1:1]
        ///Serial clock (SCK) phase
        cpha: packed enum(u1) {
            ///Sample on leading edge of clock, shift serial data on trailing edge
            leading = 0,
            ///Sample on trailing edge of clock, shift serial data on leading edge
            trailing = 1,
        } = .leading,
        ///CPOL [2:2]
        ///Serial clock (SCK) polarity
        cpol: packed enum(u1) {
            ///Active high
            active_high = 0,
            ///Active low
            active_low = 1,
        } = .active_high,
        _unused3: u29 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x40023000 + 0x554);
};

///Serial Peripheral Interface Master with EasyDMA 2
pub const spim2 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start SPI transaction
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start SPI transaction
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40023000 + 0x010);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop SPI transaction
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop SPI transaction
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40023000 + 0x014);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend SPI transaction
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend SPI transaction
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x40023000 + 0x01C);

    //////////////////////////
    ///TASKS_RESUME
    const tasks_resume_val = packed struct {
        ///TASKS_RESUME [0:0]
        ///Resume SPI transaction
        tasks_resume: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Resume SPI transaction
    pub const tasks_resume = RegisterRW(void, tasks_resume_val).init(0x40023000 + 0x020);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///SPI transaction has stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///SPI transaction has stopped
    pub const events_stopped = Register(events_stopped_val).init(0x40023000 + 0x104);

    //////////////////////////
    ///EVENTS_ENDRX
    const events_endrx_val = packed struct {
        ///EVENTS_ENDRX [0:0]
        ///End of RXD buffer reached
        events_endrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer reached
    pub const events_endrx = Register(events_endrx_val).init(0x40023000 + 0x110);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///End of RXD buffer and TXD buffer reached
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer and TXD buffer reached
    pub const events_end = Register(events_end_val).init(0x40023000 + 0x118);

    //////////////////////////
    ///EVENTS_ENDTX
    const events_endtx_val = packed struct {
        ///EVENTS_ENDTX [0:0]
        ///End of TXD buffer reached
        events_endtx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of TXD buffer reached
    pub const events_endtx = Register(events_endtx_val).init(0x40023000 + 0x120);

    //////////////////////////
    ///EVENTS_STARTED
    const events_started_val = packed struct {
        ///EVENTS_STARTED [0:0]
        ///Transaction started
        events_started: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transaction started
    pub const events_started = Register(events_started_val).init(0x40023000 + 0x14C);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u17 = 0,
        ///END_START [17:17]
        ///Shortcut between event END and task START
        end_start: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused18: u14 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40023000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40023000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40023000 + 0x308);

    //////////////////////////
    ///STALLSTAT
    const stallstat_val = packed struct {
        ///TX [0:0]
        ///Stall status for EasyDMA RAM reads
        tx: packed enum(u1) {
            ///No stall
            nostall = 0,
            ///A stall has occurred
            stall = 1,
        } = .nostall,
        ///RX [1:1]
        ///Stall status for EasyDMA RAM writes
        rx: packed enum(u1) {
            ///No stall
            nostall = 0,
            ///A stall has occurred
            stall = 1,
        } = .nostall,
        _unused2: u30 = 0,
    };
    ///Stall status for EasyDMA RAM accesses. The fields in this register is set to STALL by hardware whenever a stall occurres and can be cleared (set to NOSTALL) by the CPU.
    pub const stallstat = Register(stallstat_val).init(0x40023000 + 0x400);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable SPIM
        enable: packed enum(u4) {
            ///Disable SPIM
            disabled = 0,
            ///Enable SPIM
            enabled = 7,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable SPIM
    pub const enable = Register(enable_val).init(0x40023000 + 0x500);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///SPI master data rate
        frequency: packed enum(u32) {
            ///125 kbps
            k125 = 0x02000000,
            ///250 kbps
            k250 = 0x04000000,
            ///500 kbps
            k500 = 0x08000000,
            ///1 Mbps
            m1 = 0x10000000,
            ///2 Mbps
            m2 = 0x20000000,
            ///4 Mbps
            m4 = 0x40000000,
            ///8 Mbps
            m8 = 0x80000000,
            ///16 Mbps
            m16 = 0x0A000000,
            ///32 Mbps
            m32 = 0x14000000,
            _zero = 0,
        } = ._zero,
    };
    ///SPI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x40023000 + 0x524);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ORDER [0:0]
        ///Bit order
        order: packed enum(u1) {
            ///Most significant bit shifted out first
            msb_first = 0,
            ///Least significant bit shifted out first
            lsb_first = 1,
        } = .msb_first,
        ///CPHA [1:1]
        ///Serial clock (SCK) phase
        cpha: packed enum(u1) {
            ///Sample on leading edge of clock, shift serial data on trailing edge
            leading = 0,
            ///Sample on trailing edge of clock, shift serial data on leading edge
            trailing = 1,
        } = .leading,
        ///CPOL [2:2]
        ///Serial clock (SCK) polarity
        cpol: packed enum(u1) {
            ///Active high
            active_high = 0,
            ///Active low
            active_low = 1,
        } = .active_high,
        _unused3: u29 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x40023000 + 0x554);

    //////////////////////////
    ///CSNPOL
    const csnpol_val = packed struct {
        ///CSNPOL [0:0]
        ///Polarity of CSN output
        csnpol: packed enum(u1) {
            ///Active low (idle state high)
            low = 0,
            ///Active high (idle state low)
            high = 1,
        } = .low,
        _unused1: u31 = 0,
    };
    ///Polarity of CSN output
    pub const csnpol = Register(csnpol_val).init(0x40023000 + 0x568);

    //////////////////////////
    ///PSELDCX
    const pseldcx_val = packed struct {
        ///PIN [0:4]
        ///Pin number
        pin: u5 = 31,
        ///PORT [5:5]
        ///Port number
        port: u1 = 1,
        _unused6: u25 = 0,
        ///CONNECT [31:31]
        ///Connection
        connect: packed enum(u1) {
            ///Disconnect
            disconnected = 1,
            ///Connect
            connected = 0,
        } = .disconnected,
    };
    ///Pin select for DCX signal
    pub const pseldcx = Register(pseldcx_val).init(0x40023000 + 0x56C);

    //////////////////////////
    ///DCXCNT
    const dcxcnt_val = packed struct {
        ///DCXCNT [0:3]
        ///This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes.
        dcxcnt: u4 = 0,
        _unused4: u28 = 0,
    };
    ///DCX configuration
    pub const dcxcnt = Register(dcxcnt_val).init(0x40023000 + 0x570);

    //////////////////////////
    ///ORC
    const orc_val = packed struct {
        ///ORC [0:7]
        ///Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT.
        orc: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT
    pub const orc = Register(orc_val).init(0x40023000 + 0x5C0);
};

///SPI Slave 2
pub const spis2 = struct {

    //////////////////////////
    ///TASKS_ACQUIRE
    const tasks_acquire_val = packed struct {
        ///TASKS_ACQUIRE [0:0]
        ///Acquire SPI semaphore
        tasks_acquire: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Acquire SPI semaphore
    pub const tasks_acquire = RegisterRW(void, tasks_acquire_val).init(0x40023000 + 0x024);

    //////////////////////////
    ///TASKS_RELEASE
    const tasks_release_val = packed struct {
        ///TASKS_RELEASE [0:0]
        ///Release SPI semaphore, enabling the SPI slave to acquire it
        tasks_release: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Release SPI semaphore, enabling the SPI slave to acquire it
    pub const tasks_release = RegisterRW(void, tasks_release_val).init(0x40023000 + 0x028);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///Granted transaction completed
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Granted transaction completed
    pub const events_end = Register(events_end_val).init(0x40023000 + 0x104);

    //////////////////////////
    ///EVENTS_ENDRX
    const events_endrx_val = packed struct {
        ///EVENTS_ENDRX [0:0]
        ///End of RXD buffer reached
        events_endrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer reached
    pub const events_endrx = Register(events_endrx_val).init(0x40023000 + 0x110);

    //////////////////////////
    ///EVENTS_ACQUIRED
    const events_acquired_val = packed struct {
        ///EVENTS_ACQUIRED [0:0]
        ///Semaphore acquired
        events_acquired: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Semaphore acquired
    pub const events_acquired = Register(events_acquired_val).init(0x40023000 + 0x128);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u2 = 0,
        ///END_ACQUIRE [2:2]
        ///Shortcut between event END and task ACQUIRE
        end_acquire: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused3: u29 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40023000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to enable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused11: u21 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to enable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused11: u21 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40023000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to disable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused11: u21 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///END [1:1]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u5 = 0,
        ///ACQUIRED [10:10]
        ///Write '1' to disable interrupt for event ACQUIRED
        acquired: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused11: u21 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40023000 + 0x308);

    //////////////////////////
    ///SEMSTAT
    const semstat_val = packed struct {
        ///SEMSTAT [0:1]
        ///Semaphore status
        semstat: packed enum(u2) {
            ///Semaphore is free
            free = 0,
            ///Semaphore is assigned to CPU
            cpu = 1,
            ///Semaphore is assigned to SPI slave
            spis = 2,
            ///Semaphore is assigned to SPI but a handover to the CPU is pending
            cpupending = 3,
        } = .cpu,
        _unused2: u30 = 0,
    };
    ///Semaphore status register
    pub const semstat = RegisterRW(semstat_val, void).init(0x40023000 + 0x400);

    //////////////////////////
    ///STATUS
    const status_val_read = packed struct {
        ///OVERREAD [0:0]
        ///TX buffer over-read detected, and prevented
        overread: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///OVERFLOW [1:1]
        ///RX buffer overflow detected, and prevented
        overflow: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        _unused2: u30 = 0,
    };
    const status_val_write = packed struct {
        ///OVERREAD [0:0]
        ///TX buffer over-read detected, and prevented
        overread: packed enum(u1) {
            ///Write: clear error on writing '1'
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///OVERFLOW [1:1]
        ///RX buffer overflow detected, and prevented
        overflow: packed enum(u1) {
            ///Write: clear error on writing '1'
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u30 = 0,
    };
    ///Status from last transaction
    pub const status = RegisterRW(status_val_read, status_val_write).init(0x40023000 + 0x440);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable SPI slave
        enable: packed enum(u4) {
            ///Disable SPI slave
            disabled = 0,
            ///Enable SPI slave
            enabled = 2,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable SPI slave
    pub const enable = Register(enable_val).init(0x40023000 + 0x500);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ORDER [0:0]
        ///Bit order
        order: packed enum(u1) {
            ///Most significant bit shifted out first
            msb_first = 0,
            ///Least significant bit shifted out first
            lsb_first = 1,
        } = .msb_first,
        ///CPHA [1:1]
        ///Serial clock (SCK) phase
        cpha: packed enum(u1) {
            ///Sample on leading edge of clock, shift serial data on trailing edge
            leading = 0,
            ///Sample on trailing edge of clock, shift serial data on leading edge
            trailing = 1,
        } = .leading,
        ///CPOL [2:2]
        ///Serial clock (SCK) polarity
        cpol: packed enum(u1) {
            ///Active high
            active_high = 0,
            ///Active low
            active_low = 1,
        } = .active_high,
        _unused3: u29 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x40023000 + 0x554);

    //////////////////////////
    ///DEF
    const def_val = packed struct {
        ///DEF [0:7]
        ///Default character. Character clocked out in case of an ignored transaction.
        def: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Default character. Character clocked out in case of an ignored transaction.
    pub const def = Register(def_val).init(0x40023000 + 0x55C);

    //////////////////////////
    ///ORC
    const orc_val = packed struct {
        ///ORC [0:7]
        ///Over-read character. Character clocked out after an over-read of the transmit buffer.
        orc: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Over-read character
    pub const orc = Register(orc_val).init(0x40023000 + 0x5C0);
};

///Real time counter 2
pub const rtc2 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start RTC COUNTER
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start RTC COUNTER
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40024000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop RTC COUNTER
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop RTC COUNTER
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40024000 + 0x004);

    //////////////////////////
    ///TASKS_CLEAR
    const tasks_clear_val = packed struct {
        ///TASKS_CLEAR [0:0]
        ///Clear RTC COUNTER
        tasks_clear: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Clear RTC COUNTER
    pub const tasks_clear = RegisterRW(void, tasks_clear_val).init(0x40024000 + 0x008);

    //////////////////////////
    ///TASKS_TRIGOVRFLW
    const tasks_trigovrflw_val = packed struct {
        ///TASKS_TRIGOVRFLW [0:0]
        ///Set COUNTER to 0xFFFFF0
        tasks_trigovrflw: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Set COUNTER to 0xFFFFF0
    pub const tasks_trigovrflw = RegisterRW(void, tasks_trigovrflw_val).init(0x40024000 + 0x00C);

    //////////////////////////
    ///EVENTS_TICK
    const events_tick_val = packed struct {
        ///EVENTS_TICK [0:0]
        ///Event on COUNTER increment
        events_tick: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Event on COUNTER increment
    pub const events_tick = Register(events_tick_val).init(0x40024000 + 0x100);

    //////////////////////////
    ///EVENTS_OVRFLW
    const events_ovrflw_val = packed struct {
        ///EVENTS_OVRFLW [0:0]
        ///Event on COUNTER overflow
        events_ovrflw: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Event on COUNTER overflow
    pub const events_ovrflw = Register(events_ovrflw_val).init(0x40024000 + 0x104);

    //////////////////////////
    ///EVENTS_COMPARE[%s]
    const events_compare_val = packed struct {
        ///EVENTS_COMPARE [0:0]
        ///Compare event on CC[n] match
        events_compare: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Compare event on CC[n] match
    pub const events_compare = Register(events_compare_val).initRange(0x40024000 + 0x140, 4, 4);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable interrupt for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to enable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenset_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable interrupt for event TICK
        tick: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to enable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40024000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable interrupt for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to disable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenclr_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable interrupt for event TICK
        tick: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to disable interrupt for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable interrupt for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable interrupt for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable interrupt for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable interrupt for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40024000 + 0x308);

    //////////////////////////
    ///EVTEN
    const evten_val = packed struct {
        ///TICK [0:0]
        ///Enable or disable event routing for event TICK
        tick: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Enable or disable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Enable or disable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Enable or disable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Enable or disable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Enable or disable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Disable
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    ///Enable or disable event routing
    pub const evten = Register(evten_val).init(0x40024000 + 0x340);

    //////////////////////////
    ///EVTENSET
    const evtenset_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable event routing for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to enable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to enable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to enable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to enable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const evtenset_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to enable event routing for event TICK
        tick: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to enable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to enable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to enable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to enable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to enable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Enable event routing
    pub const evtenset = RegisterRW(evtenset_val_read, evtenset_val_write).init(0x40024000 + 0x344);

    //////////////////////////
    ///EVTENCLR
    const evtenclr_val_read = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable event routing for event TICK
        tick: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///OVRFLW [1:1]
        ///Write '1' to disable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE1 [17:17]
        ///Write '1' to disable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE2 [18:18]
        ///Write '1' to disable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///COMPARE3 [19:19]
        ///Write '1' to disable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const evtenclr_val_write = packed struct {
        ///TICK [0:0]
        ///Write '1' to disable event routing for event TICK
        tick: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///OVRFLW [1:1]
        ///Write '1' to disable event routing for event OVRFLW
        ovrflw: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u14 = 0,
        ///COMPARE0 [16:16]
        ///Write '1' to disable event routing for event COMPARE[0]
        compare0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE1 [17:17]
        ///Write '1' to disable event routing for event COMPARE[1]
        compare1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE2 [18:18]
        ///Write '1' to disable event routing for event COMPARE[2]
        compare2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///COMPARE3 [19:19]
        ///Write '1' to disable event routing for event COMPARE[3]
        compare3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Disable event routing
    pub const evtenclr = RegisterRW(evtenclr_val_read, evtenclr_val_write).init(0x40024000 + 0x348);

    //////////////////////////
    ///COUNTER
    const counter_val = packed struct {
        ///COUNTER [0:23]
        ///Counter value
        counter: u24 = 0,
        _unused24: u8 = 0,
    };
    ///Current COUNTER value
    pub const counter = RegisterRW(counter_val, void).init(0x40024000 + 0x504);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:11]
        ///Prescaler value
        prescaler: u12 = 0,
        _unused12: u20 = 0,
    };
    ///12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped
    pub const prescaler = Register(prescaler_val).init(0x40024000 + 0x508);

    //////////////////////////
    ///CC[%s]
    const cc_val = packed struct {
        ///COMPARE [0:23]
        ///Compare value
        compare: u24 = 0,
        _unused24: u8 = 0,
    };
    ///Description collection: Compare register n
    pub const cc = Register(cc_val).initRange(0x40024000 + 0x540, 4, 4);
};

///Inter-IC Sound
pub const i2s = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Starts continuous I2S transfer. Also starts MCK generator when this is enabled.
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Starts continuous I2S transfer. Also starts MCK generator when this is enabled.
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x40025000 + 0x000);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the STOPPED event to be generated.
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the STOPPED event to be generated.
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x40025000 + 0x004);

    //////////////////////////
    ///EVENTS_RXPTRUPD
    const events_rxptrupd_val = packed struct {
        ///EVENTS_RXPTRUPD [0:0]
        ///The RXD.PTR register has been copied to internal double-buffers.
        ///When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin.
        events_rxptrupd: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The RXD.PTR register has been copied to internal double-buffers.
    ///When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin.
    pub const events_rxptrupd = Register(events_rxptrupd_val).init(0x40025000 + 0x104);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///I2S transfer stopped.
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///I2S transfer stopped.
    pub const events_stopped = Register(events_stopped_val).init(0x40025000 + 0x108);

    //////////////////////////
    ///EVENTS_TXPTRUPD
    const events_txptrupd_val = packed struct {
        ///EVENTS_TXPTRUPD [0:0]
        ///The TDX.PTR register has been copied to internal double-buffers.
        ///When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin.
        events_txptrupd: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The TDX.PTR register has been copied to internal double-buffers.
    ///When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin.
    pub const events_txptrupd = Register(events_txptrupd_val).init(0x40025000 + 0x114);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        _unused0: u1 = 0,
        ///RXPTRUPD [1:1]
        ///Enable or disable interrupt for event RXPTRUPD
        rxptrupd: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///STOPPED [2:2]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused3: u2 = 0,
        ///TXPTRUPD [5:5]
        ///Enable or disable interrupt for event TXPTRUPD
        txptrupd: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused6: u26 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40025000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///RXPTRUPD [1:1]
        ///Write '1' to enable interrupt for event RXPTRUPD
        rxptrupd: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STOPPED [2:2]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u2 = 0,
        ///TXPTRUPD [5:5]
        ///Write '1' to enable interrupt for event TXPTRUPD
        txptrupd: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused6: u26 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///RXPTRUPD [1:1]
        ///Write '1' to enable interrupt for event RXPTRUPD
        rxptrupd: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///STOPPED [2:2]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u2 = 0,
        ///TXPTRUPD [5:5]
        ///Write '1' to enable interrupt for event TXPTRUPD
        txptrupd: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused6: u26 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40025000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///RXPTRUPD [1:1]
        ///Write '1' to disable interrupt for event RXPTRUPD
        rxptrupd: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STOPPED [2:2]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u2 = 0,
        ///TXPTRUPD [5:5]
        ///Write '1' to disable interrupt for event TXPTRUPD
        txptrupd: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused6: u26 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///RXPTRUPD [1:1]
        ///Write '1' to disable interrupt for event RXPTRUPD
        rxptrupd: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///STOPPED [2:2]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u2 = 0,
        ///TXPTRUPD [5:5]
        ///Write '1' to disable interrupt for event TXPTRUPD
        txptrupd: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused6: u26 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40025000 + 0x308);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:0]
        ///Enable I2S module.
        enable: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Enable I2S module.
    pub const enable = Register(enable_val).init(0x40025000 + 0x500);
};

///FPU
pub const fpu = struct {

    //////////////////////////
    ///UNUSED
    const unused_val = packed struct {
        _unused0: u32 = 0,
    };
    ///Unused.
    pub const unused = RegisterRW(unused_val, void).init(0x40026000 + 0x000);
};

///Universal serial bus device
pub const usbd = struct {

    //////////////////////////
    ///TASKS_STARTEPIN[%s]
    const tasks_startepin_val = packed struct {
        ///TASKS_STARTEPIN [0:0]
        ///Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host
        tasks_startepin: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host
    pub const tasks_startepin = RegisterRW(void, tasks_startepin_val).initRange(0x40027000 + 0x004, 4, 8);

    //////////////////////////
    ///TASKS_STARTISOIN
    const tasks_startisoin_val = packed struct {
        ///TASKS_STARTISOIN [0:0]
        ///Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint
        tasks_startisoin: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint
    pub const tasks_startisoin = RegisterRW(void, tasks_startisoin_val).init(0x40027000 + 0x024);

    //////////////////////////
    ///TASKS_STARTEPOUT[%s]
    const tasks_startepout_val = packed struct {
        ///TASKS_STARTEPOUT [0:0]
        ///Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host
        tasks_startepout: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host
    pub const tasks_startepout = RegisterRW(void, tasks_startepout_val).initRange(0x40027000 + 0x028, 4, 8);

    //////////////////////////
    ///TASKS_STARTISOOUT
    const tasks_startisoout_val = packed struct {
        ///TASKS_STARTISOOUT [0:0]
        ///Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint
        tasks_startisoout: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint
    pub const tasks_startisoout = RegisterRW(void, tasks_startisoout_val).init(0x40027000 + 0x048);

    //////////////////////////
    ///TASKS_EP0RCVOUT
    const tasks_ep0rcvout_val = packed struct {
        ///TASKS_EP0RCVOUT [0:0]
        ///Allows OUT data stage on control endpoint 0
        tasks_ep0rcvout: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Allows OUT data stage on control endpoint 0
    pub const tasks_ep0rcvout = RegisterRW(void, tasks_ep0rcvout_val).init(0x40027000 + 0x04C);

    //////////////////////////
    ///TASKS_EP0STATUS
    const tasks_ep0status_val = packed struct {
        ///TASKS_EP0STATUS [0:0]
        ///Allows status stage on control endpoint 0
        tasks_ep0status: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Allows status stage on control endpoint 0
    pub const tasks_ep0status = RegisterRW(void, tasks_ep0status_val).init(0x40027000 + 0x050);

    //////////////////////////
    ///TASKS_EP0STALL
    const tasks_ep0stall_val = packed struct {
        ///TASKS_EP0STALL [0:0]
        ///Stalls data and status stage on control endpoint 0
        tasks_ep0stall: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stalls data and status stage on control endpoint 0
    pub const tasks_ep0stall = RegisterRW(void, tasks_ep0stall_val).init(0x40027000 + 0x054);

    //////////////////////////
    ///TASKS_DPDMDRIVE
    const tasks_dpdmdrive_val = packed struct {
        ///TASKS_DPDMDRIVE [0:0]
        ///Forces D+ and D- lines into the state defined in the DPDMVALUE register
        tasks_dpdmdrive: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Forces D+ and D- lines into the state defined in the DPDMVALUE register
    pub const tasks_dpdmdrive = RegisterRW(void, tasks_dpdmdrive_val).init(0x40027000 + 0x058);

    //////////////////////////
    ///TASKS_DPDMNODRIVE
    const tasks_dpdmnodrive_val = packed struct {
        ///TASKS_DPDMNODRIVE [0:0]
        ///Stops forcing D+ and D- lines into any state (USB engine takes control)
        tasks_dpdmnodrive: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stops forcing D+ and D- lines into any state (USB engine takes control)
    pub const tasks_dpdmnodrive = RegisterRW(void, tasks_dpdmnodrive_val).init(0x40027000 + 0x05C);

    //////////////////////////
    ///EVENTS_USBRESET
    const events_usbreset_val = packed struct {
        ///EVENTS_USBRESET [0:0]
        ///Signals that a USB reset condition has been detected on USB lines
        events_usbreset: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Signals that a USB reset condition has been detected on USB lines
    pub const events_usbreset = Register(events_usbreset_val).init(0x40027000 + 0x100);

    //////////////////////////
    ///EVENTS_STARTED
    const events_started_val = packed struct {
        ///EVENTS_STARTED [0:0]
        ///Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register
        events_started: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register
    pub const events_started = Register(events_started_val).init(0x40027000 + 0x104);

    //////////////////////////
    ///EVENTS_ENDEPIN[%s]
    const events_endepin_val = packed struct {
        ///EVENTS_ENDEPIN [0:0]
        ///The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software.
        events_endepin: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software.
    pub const events_endepin = Register(events_endepin_val).initRange(0x40027000 + 0x108, 4, 8);

    //////////////////////////
    ///EVENTS_EP0DATADONE
    const events_ep0datadone_val = packed struct {
        ///EVENTS_EP0DATADONE [0:0]
        ///An acknowledged data transfer has taken place on the control endpoint
        events_ep0datadone: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///An acknowledged data transfer has taken place on the control endpoint
    pub const events_ep0datadone = Register(events_ep0datadone_val).init(0x40027000 + 0x128);

    //////////////////////////
    ///EVENTS_ENDISOIN
    const events_endisoin_val = packed struct {
        ///EVENTS_ENDISOIN [0:0]
        ///The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software.
        events_endisoin: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software.
    pub const events_endisoin = Register(events_endisoin_val).init(0x40027000 + 0x12C);

    //////////////////////////
    ///EVENTS_ENDEPOUT[%s]
    const events_endepout_val = packed struct {
        ///EVENTS_ENDEPOUT [0:0]
        ///The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software.
        events_endepout: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software.
    pub const events_endepout = Register(events_endepout_val).initRange(0x40027000 + 0x130, 4, 8);

    //////////////////////////
    ///EVENTS_ENDISOOUT
    const events_endisoout_val = packed struct {
        ///EVENTS_ENDISOOUT [0:0]
        ///The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software.
        events_endisoout: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software.
    pub const events_endisoout = Register(events_endisoout_val).init(0x40027000 + 0x150);

    //////////////////////////
    ///EVENTS_SOF
    const events_sof_val = packed struct {
        ///EVENTS_SOF [0:0]
        ///Signals that a SOF (start of frame) condition has been detected on USB lines
        events_sof: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Signals that a SOF (start of frame) condition has been detected on USB lines
    pub const events_sof = Register(events_sof_val).init(0x40027000 + 0x154);

    //////////////////////////
    ///EVENTS_USBEVENT
    const events_usbevent_val = packed struct {
        ///EVENTS_USBEVENT [0:0]
        ///An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause.
        events_usbevent: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause.
    pub const events_usbevent = Register(events_usbevent_val).init(0x40027000 + 0x158);

    //////////////////////////
    ///EVENTS_EP0SETUP
    const events_ep0setup_val = packed struct {
        ///EVENTS_EP0SETUP [0:0]
        ///A valid SETUP token has been received (and acknowledged) on the control endpoint
        events_ep0setup: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///A valid SETUP token has been received (and acknowledged) on the control endpoint
    pub const events_ep0setup = Register(events_ep0setup_val).init(0x40027000 + 0x15C);

    //////////////////////////
    ///EVENTS_EPDATA
    const events_epdata_val = packed struct {
        ///EVENTS_EPDATA [0:0]
        ///A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register
        events_epdata: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register
    pub const events_epdata = Register(events_epdata_val).init(0x40027000 + 0x160);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///EP0DATADONE_STARTEPIN0 [0:0]
        ///Shortcut between event EP0DATADONE and task STARTEPIN[0]
        ep0datadone_startepin0: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///EP0DATADONE_STARTEPOUT0 [1:1]
        ///Shortcut between event EP0DATADONE and task STARTEPOUT[0]
        ep0datadone_startepout0: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///EP0DATADONE_EP0STATUS [2:2]
        ///Shortcut between event EP0DATADONE and task EP0STATUS
        ep0datadone_ep0status: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT0_EP0STATUS [3:3]
        ///Shortcut between event ENDEPOUT[0] and task EP0STATUS
        endepout0_ep0status: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT0_EP0RCVOUT [4:4]
        ///Shortcut between event ENDEPOUT[0] and task EP0RCVOUT
        endepout0_ep0rcvout: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused5: u27 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40027000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///USBRESET [0:0]
        ///Enable or disable interrupt for event USBRESET
        usbreset: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///STARTED [1:1]
        ///Enable or disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPIN0 [2:2]
        ///Enable or disable interrupt for event ENDEPIN[0]
        endepin0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPIN1 [3:3]
        ///Enable or disable interrupt for event ENDEPIN[1]
        endepin1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPIN2 [4:4]
        ///Enable or disable interrupt for event ENDEPIN[2]
        endepin2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPIN3 [5:5]
        ///Enable or disable interrupt for event ENDEPIN[3]
        endepin3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPIN4 [6:6]
        ///Enable or disable interrupt for event ENDEPIN[4]
        endepin4: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPIN5 [7:7]
        ///Enable or disable interrupt for event ENDEPIN[5]
        endepin5: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPIN6 [8:8]
        ///Enable or disable interrupt for event ENDEPIN[6]
        endepin6: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPIN7 [9:9]
        ///Enable or disable interrupt for event ENDEPIN[7]
        endepin7: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///EP0DATADONE [10:10]
        ///Enable or disable interrupt for event EP0DATADONE
        ep0datadone: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDISOIN [11:11]
        ///Enable or disable interrupt for event ENDISOIN
        endisoin: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT0 [12:12]
        ///Enable or disable interrupt for event ENDEPOUT[0]
        endepout0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT1 [13:13]
        ///Enable or disable interrupt for event ENDEPOUT[1]
        endepout1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT2 [14:14]
        ///Enable or disable interrupt for event ENDEPOUT[2]
        endepout2: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT3 [15:15]
        ///Enable or disable interrupt for event ENDEPOUT[3]
        endepout3: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT4 [16:16]
        ///Enable or disable interrupt for event ENDEPOUT[4]
        endepout4: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT5 [17:17]
        ///Enable or disable interrupt for event ENDEPOUT[5]
        endepout5: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT6 [18:18]
        ///Enable or disable interrupt for event ENDEPOUT[6]
        endepout6: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT7 [19:19]
        ///Enable or disable interrupt for event ENDEPOUT[7]
        endepout7: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDISOOUT [20:20]
        ///Enable or disable interrupt for event ENDISOOUT
        endisoout: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SOF [21:21]
        ///Enable or disable interrupt for event SOF
        sof: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///USBEVENT [22:22]
        ///Enable or disable interrupt for event USBEVENT
        usbevent: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///EP0SETUP [23:23]
        ///Enable or disable interrupt for event EP0SETUP
        ep0setup: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///EPDATA [24:24]
        ///Enable or disable interrupt for event EPDATA
        epdata: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused25: u7 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40027000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///USBRESET [0:0]
        ///Write '1' to enable interrupt for event USBRESET
        usbreset: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STARTED [1:1]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN0 [2:2]
        ///Write '1' to enable interrupt for event ENDEPIN[0]
        endepin0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN1 [3:3]
        ///Write '1' to enable interrupt for event ENDEPIN[1]
        endepin1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN2 [4:4]
        ///Write '1' to enable interrupt for event ENDEPIN[2]
        endepin2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN3 [5:5]
        ///Write '1' to enable interrupt for event ENDEPIN[3]
        endepin3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN4 [6:6]
        ///Write '1' to enable interrupt for event ENDEPIN[4]
        endepin4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN5 [7:7]
        ///Write '1' to enable interrupt for event ENDEPIN[5]
        endepin5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN6 [8:8]
        ///Write '1' to enable interrupt for event ENDEPIN[6]
        endepin6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN7 [9:9]
        ///Write '1' to enable interrupt for event ENDEPIN[7]
        endepin7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///EP0DATADONE [10:10]
        ///Write '1' to enable interrupt for event EP0DATADONE
        ep0datadone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDISOIN [11:11]
        ///Write '1' to enable interrupt for event ENDISOIN
        endisoin: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT0 [12:12]
        ///Write '1' to enable interrupt for event ENDEPOUT[0]
        endepout0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT1 [13:13]
        ///Write '1' to enable interrupt for event ENDEPOUT[1]
        endepout1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT2 [14:14]
        ///Write '1' to enable interrupt for event ENDEPOUT[2]
        endepout2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT3 [15:15]
        ///Write '1' to enable interrupt for event ENDEPOUT[3]
        endepout3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT4 [16:16]
        ///Write '1' to enable interrupt for event ENDEPOUT[4]
        endepout4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT5 [17:17]
        ///Write '1' to enable interrupt for event ENDEPOUT[5]
        endepout5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT6 [18:18]
        ///Write '1' to enable interrupt for event ENDEPOUT[6]
        endepout6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT7 [19:19]
        ///Write '1' to enable interrupt for event ENDEPOUT[7]
        endepout7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDISOOUT [20:20]
        ///Write '1' to enable interrupt for event ENDISOOUT
        endisoout: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SOF [21:21]
        ///Write '1' to enable interrupt for event SOF
        sof: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///USBEVENT [22:22]
        ///Write '1' to enable interrupt for event USBEVENT
        usbevent: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///EP0SETUP [23:23]
        ///Write '1' to enable interrupt for event EP0SETUP
        ep0setup: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///EPDATA [24:24]
        ///Write '1' to enable interrupt for event EPDATA
        epdata: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused25: u7 = 0,
    };
    const intenset_val_write = packed struct {
        ///USBRESET [0:0]
        ///Write '1' to enable interrupt for event USBRESET
        usbreset: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///STARTED [1:1]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN0 [2:2]
        ///Write '1' to enable interrupt for event ENDEPIN[0]
        endepin0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN1 [3:3]
        ///Write '1' to enable interrupt for event ENDEPIN[1]
        endepin1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN2 [4:4]
        ///Write '1' to enable interrupt for event ENDEPIN[2]
        endepin2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN3 [5:5]
        ///Write '1' to enable interrupt for event ENDEPIN[3]
        endepin3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN4 [6:6]
        ///Write '1' to enable interrupt for event ENDEPIN[4]
        endepin4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN5 [7:7]
        ///Write '1' to enable interrupt for event ENDEPIN[5]
        endepin5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN6 [8:8]
        ///Write '1' to enable interrupt for event ENDEPIN[6]
        endepin6: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN7 [9:9]
        ///Write '1' to enable interrupt for event ENDEPIN[7]
        endepin7: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///EP0DATADONE [10:10]
        ///Write '1' to enable interrupt for event EP0DATADONE
        ep0datadone: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDISOIN [11:11]
        ///Write '1' to enable interrupt for event ENDISOIN
        endisoin: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT0 [12:12]
        ///Write '1' to enable interrupt for event ENDEPOUT[0]
        endepout0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT1 [13:13]
        ///Write '1' to enable interrupt for event ENDEPOUT[1]
        endepout1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT2 [14:14]
        ///Write '1' to enable interrupt for event ENDEPOUT[2]
        endepout2: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT3 [15:15]
        ///Write '1' to enable interrupt for event ENDEPOUT[3]
        endepout3: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT4 [16:16]
        ///Write '1' to enable interrupt for event ENDEPOUT[4]
        endepout4: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT5 [17:17]
        ///Write '1' to enable interrupt for event ENDEPOUT[5]
        endepout5: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT6 [18:18]
        ///Write '1' to enable interrupt for event ENDEPOUT[6]
        endepout6: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT7 [19:19]
        ///Write '1' to enable interrupt for event ENDEPOUT[7]
        endepout7: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDISOOUT [20:20]
        ///Write '1' to enable interrupt for event ENDISOOUT
        endisoout: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SOF [21:21]
        ///Write '1' to enable interrupt for event SOF
        sof: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///USBEVENT [22:22]
        ///Write '1' to enable interrupt for event USBEVENT
        usbevent: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///EP0SETUP [23:23]
        ///Write '1' to enable interrupt for event EP0SETUP
        ep0setup: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///EPDATA [24:24]
        ///Write '1' to enable interrupt for event EPDATA
        epdata: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused25: u7 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40027000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///USBRESET [0:0]
        ///Write '1' to disable interrupt for event USBRESET
        usbreset: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///STARTED [1:1]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN0 [2:2]
        ///Write '1' to disable interrupt for event ENDEPIN[0]
        endepin0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN1 [3:3]
        ///Write '1' to disable interrupt for event ENDEPIN[1]
        endepin1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN2 [4:4]
        ///Write '1' to disable interrupt for event ENDEPIN[2]
        endepin2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN3 [5:5]
        ///Write '1' to disable interrupt for event ENDEPIN[3]
        endepin3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN4 [6:6]
        ///Write '1' to disable interrupt for event ENDEPIN[4]
        endepin4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN5 [7:7]
        ///Write '1' to disable interrupt for event ENDEPIN[5]
        endepin5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN6 [8:8]
        ///Write '1' to disable interrupt for event ENDEPIN[6]
        endepin6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPIN7 [9:9]
        ///Write '1' to disable interrupt for event ENDEPIN[7]
        endepin7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///EP0DATADONE [10:10]
        ///Write '1' to disable interrupt for event EP0DATADONE
        ep0datadone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDISOIN [11:11]
        ///Write '1' to disable interrupt for event ENDISOIN
        endisoin: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT0 [12:12]
        ///Write '1' to disable interrupt for event ENDEPOUT[0]
        endepout0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT1 [13:13]
        ///Write '1' to disable interrupt for event ENDEPOUT[1]
        endepout1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT2 [14:14]
        ///Write '1' to disable interrupt for event ENDEPOUT[2]
        endepout2: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT3 [15:15]
        ///Write '1' to disable interrupt for event ENDEPOUT[3]
        endepout3: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT4 [16:16]
        ///Write '1' to disable interrupt for event ENDEPOUT[4]
        endepout4: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT5 [17:17]
        ///Write '1' to disable interrupt for event ENDEPOUT[5]
        endepout5: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT6 [18:18]
        ///Write '1' to disable interrupt for event ENDEPOUT[6]
        endepout6: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDEPOUT7 [19:19]
        ///Write '1' to disable interrupt for event ENDEPOUT[7]
        endepout7: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDISOOUT [20:20]
        ///Write '1' to disable interrupt for event ENDISOOUT
        endisoout: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SOF [21:21]
        ///Write '1' to disable interrupt for event SOF
        sof: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///USBEVENT [22:22]
        ///Write '1' to disable interrupt for event USBEVENT
        usbevent: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///EP0SETUP [23:23]
        ///Write '1' to disable interrupt for event EP0SETUP
        ep0setup: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///EPDATA [24:24]
        ///Write '1' to disable interrupt for event EPDATA
        epdata: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused25: u7 = 0,
    };
    const intenclr_val_write = packed struct {
        ///USBRESET [0:0]
        ///Write '1' to disable interrupt for event USBRESET
        usbreset: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///STARTED [1:1]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN0 [2:2]
        ///Write '1' to disable interrupt for event ENDEPIN[0]
        endepin0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN1 [3:3]
        ///Write '1' to disable interrupt for event ENDEPIN[1]
        endepin1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN2 [4:4]
        ///Write '1' to disable interrupt for event ENDEPIN[2]
        endepin2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN3 [5:5]
        ///Write '1' to disable interrupt for event ENDEPIN[3]
        endepin3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN4 [6:6]
        ///Write '1' to disable interrupt for event ENDEPIN[4]
        endepin4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN5 [7:7]
        ///Write '1' to disable interrupt for event ENDEPIN[5]
        endepin5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN6 [8:8]
        ///Write '1' to disable interrupt for event ENDEPIN[6]
        endepin6: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPIN7 [9:9]
        ///Write '1' to disable interrupt for event ENDEPIN[7]
        endepin7: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///EP0DATADONE [10:10]
        ///Write '1' to disable interrupt for event EP0DATADONE
        ep0datadone: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDISOIN [11:11]
        ///Write '1' to disable interrupt for event ENDISOIN
        endisoin: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT0 [12:12]
        ///Write '1' to disable interrupt for event ENDEPOUT[0]
        endepout0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT1 [13:13]
        ///Write '1' to disable interrupt for event ENDEPOUT[1]
        endepout1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT2 [14:14]
        ///Write '1' to disable interrupt for event ENDEPOUT[2]
        endepout2: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT3 [15:15]
        ///Write '1' to disable interrupt for event ENDEPOUT[3]
        endepout3: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT4 [16:16]
        ///Write '1' to disable interrupt for event ENDEPOUT[4]
        endepout4: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT5 [17:17]
        ///Write '1' to disable interrupt for event ENDEPOUT[5]
        endepout5: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT6 [18:18]
        ///Write '1' to disable interrupt for event ENDEPOUT[6]
        endepout6: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDEPOUT7 [19:19]
        ///Write '1' to disable interrupt for event ENDEPOUT[7]
        endepout7: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDISOOUT [20:20]
        ///Write '1' to disable interrupt for event ENDISOOUT
        endisoout: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SOF [21:21]
        ///Write '1' to disable interrupt for event SOF
        sof: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///USBEVENT [22:22]
        ///Write '1' to disable interrupt for event USBEVENT
        usbevent: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///EP0SETUP [23:23]
        ///Write '1' to disable interrupt for event EP0SETUP
        ep0setup: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///EPDATA [24:24]
        ///Write '1' to disable interrupt for event EPDATA
        epdata: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused25: u7 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40027000 + 0x308);

    //////////////////////////
    ///EVENTCAUSE
    const eventcause_val = packed struct {
        ///ISOOUTCRC [0:0]
        ///CRC error was detected on isochronous OUT endpoint 8. Write '1' to clear.
        isooutcrc: packed enum(u1) {
            ///No error detected
            not_detected = 0,
            ///Error detected
            detected = 1,
        } = .not_detected,
        _unused1: u7 = 0,
        ///SUSPEND [8:8]
        ///Signals that USB lines have been idle long enough for the device to enter suspend. Write '1' to clear.
        _suspend: packed enum(u1) {
            ///Suspend not detected
            not_detected = 0,
            ///Suspend detected
            detected = 1,
        } = .not_detected,
        ///RESUME [9:9]
        ///Signals that a RESUME condition (K state or activity restart) has been detected on USB lines. Write '1' to clear.
        _resume: packed enum(u1) {
            ///Resume not detected
            not_detected = 0,
            ///Resume detected
            detected = 1,
        } = .not_detected,
        ///USBWUALLOWED [10:10]
        ///USB MAC has been woken up and operational. Write '1' to clear.
        usbwuallowed: packed enum(u1) {
            ///Wake up not allowed
            not_allowed = 0,
            ///Wake up allowed
            allowed = 1,
        } = .not_allowed,
        ///READY [11:11]
        ///USB device is ready for normal operation. Write '1' to clear.
        ready: packed enum(u1) {
            ///USBEVENT was not issued due to USBD peripheral ready
            not_detected = 0,
            ///USBD peripheral is ready
            ready = 1,
        } = .not_detected,
        _unused12: u20 = 0,
    };
    ///Details on what caused the USBEVENT event
    pub const eventcause = Register(eventcause_val).init(0x40027000 + 0x400);

    //////////////////////////
    ///EPSTATUS
    const epstatus_val = packed struct {
        ///EPIN0 [0:0]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epin0: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPIN1 [1:1]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epin1: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPIN2 [2:2]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epin2: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPIN3 [3:3]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epin3: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPIN4 [4:4]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epin4: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPIN5 [5:5]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epin5: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPIN6 [6:6]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epin6: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPIN7 [7:7]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epin7: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPIN8 [8:8]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epin8: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        _unused9: u7 = 0,
        ///EPOUT0 [16:16]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epout0: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPOUT1 [17:17]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epout1: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPOUT2 [18:18]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epout2: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPOUT3 [19:19]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epout3: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPOUT4 [20:20]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epout4: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPOUT5 [21:21]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epout5: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPOUT6 [22:22]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epout6: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPOUT7 [23:23]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epout7: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        ///EPOUT8 [24:24]
        ///Captured state of endpoint's EasyDMA registers. Write '1' to clear.
        epout8: packed enum(u1) {
            ///EasyDMA registers have not been captured for this endpoint
            no_data = 0,
            ///EasyDMA registers have been captured for this endpoint
            data_done = 1,
        } = .no_data,
        _unused25: u7 = 0,
    };
    ///Provides information on which endpoint's EasyDMA registers have been captured
    pub const epstatus = Register(epstatus_val).init(0x40027000 + 0x468);

    //////////////////////////
    ///EPDATASTATUS
    const epdatastatus_val = packed struct {
        _unused0: u1 = 0,
        ///EPIN1 [1:1]
        ///Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        epin1: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_done = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            data_done = 1,
        } = .not_done,
        ///EPIN2 [2:2]
        ///Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        epin2: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_done = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            data_done = 1,
        } = .not_done,
        ///EPIN3 [3:3]
        ///Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        epin3: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_done = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            data_done = 1,
        } = .not_done,
        ///EPIN4 [4:4]
        ///Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        epin4: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_done = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            data_done = 1,
        } = .not_done,
        ///EPIN5 [5:5]
        ///Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        epin5: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_done = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            data_done = 1,
        } = .not_done,
        ///EPIN6 [6:6]
        ///Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        epin6: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_done = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            data_done = 1,
        } = .not_done,
        ///EPIN7 [7:7]
        ///Acknowledged data transfer on this IN endpoint. Write '1' to clear.
        epin7: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_done = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            data_done = 1,
        } = .not_done,
        _unused8: u9 = 0,
        ///EPOUT1 [17:17]
        ///Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        epout1: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_started = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            started = 1,
        } = .not_started,
        ///EPOUT2 [18:18]
        ///Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        epout2: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_started = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            started = 1,
        } = .not_started,
        ///EPOUT3 [19:19]
        ///Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        epout3: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_started = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            started = 1,
        } = .not_started,
        ///EPOUT4 [20:20]
        ///Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        epout4: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_started = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            started = 1,
        } = .not_started,
        ///EPOUT5 [21:21]
        ///Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        epout5: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_started = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            started = 1,
        } = .not_started,
        ///EPOUT6 [22:22]
        ///Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        epout6: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_started = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            started = 1,
        } = .not_started,
        ///EPOUT7 [23:23]
        ///Acknowledged data transfer on this OUT endpoint. Write '1' to clear.
        epout7: packed enum(u1) {
            ///No acknowledged data transfer on this endpoint
            not_started = 0,
            ///Acknowledged data transfer on this endpoint has occurred
            started = 1,
        } = .not_started,
        _unused24: u8 = 0,
    };
    ///Provides information on which endpoint(s) an acknowledged data transfer has occurred (EPDATA event)
    pub const epdatastatus = Register(epdatastatus_val).init(0x40027000 + 0x46C);

    //////////////////////////
    ///USBADDR
    const usbaddr_val = packed struct {
        ///ADDR [0:6]
        ///Device USB address
        addr: u7 = 0,
        _unused7: u25 = 0,
    };
    ///Device USB address
    pub const usbaddr = RegisterRW(usbaddr_val, void).init(0x40027000 + 0x470);

    //////////////////////////
    ///BMREQUESTTYPE
    const bmrequesttype_val = packed struct {
        ///RECIPIENT [0:4]
        ///Data transfer type
        recipient: packed enum(u5) {
            ///Device
            device = 0,
            ///Interface
            interface = 1,
            ///Endpoint
            endpoint = 2,
            ///Other
            other = 3,
        } = .device,
        ///TYPE [5:6]
        ///Data transfer type
        type: packed enum(u2) {
            ///Standard
            standard = 0,
            ///Class
            class = 1,
            ///Vendor
            vendor = 2,
        } = .standard,
        ///DIRECTION [7:7]
        ///Data transfer direction
        direction: packed enum(u1) {
            ///Host-to-device
            host_to_device = 0,
            ///Device-to-host
            device_to_host = 1,
        } = .host_to_device,
        _unused8: u24 = 0,
    };
    ///SETUP data, byte 0, bmRequestType
    pub const bmrequesttype = RegisterRW(bmrequesttype_val, void).init(0x40027000 + 0x480);

    //////////////////////////
    ///BREQUEST
    const brequest_val = packed struct {
        ///BREQUEST [0:7]
        ///SETUP data, byte 1, bRequest. Values provided for standard requests only, user must implement class and vendor values.
        brequest: packed enum(u8) {
            ///Standard request GET_STATUS
            std_get_status = 0,
            ///Standard request CLEAR_FEATURE
            std_clear_feature = 1,
            ///Standard request SET_FEATURE
            std_set_feature = 3,
            ///Standard request SET_ADDRESS
            std_set_address = 5,
            ///Standard request GET_DESCRIPTOR
            std_get_descriptor = 6,
            ///Standard request SET_DESCRIPTOR
            std_set_descriptor = 7,
            ///Standard request GET_CONFIGURATION
            std_get_configuration = 8,
            ///Standard request SET_CONFIGURATION
            std_set_configuration = 9,
            ///Standard request GET_INTERFACE
            std_get_interface = 10,
            ///Standard request SET_INTERFACE
            std_set_interface = 11,
            ///Standard request SYNCH_FRAME
            std_synch_frame = 12,
        } = .std_get_status,
        _unused8: u24 = 0,
    };
    ///SETUP data, byte 1, bRequest
    pub const brequest = RegisterRW(brequest_val, void).init(0x40027000 + 0x484);

    //////////////////////////
    ///WVALUEL
    const wvaluel_val = packed struct {
        ///WVALUEL [0:7]
        ///SETUP data, byte 2, LSB of wValue
        wvaluel: u8 = 0,
        _unused8: u24 = 0,
    };
    ///SETUP data, byte 2, LSB of wValue
    pub const wvaluel = RegisterRW(wvaluel_val, void).init(0x40027000 + 0x488);

    //////////////////////////
    ///WVALUEH
    const wvalueh_val = packed struct {
        ///WVALUEH [0:7]
        ///SETUP data, byte 3, MSB of wValue
        wvalueh: u8 = 0,
        _unused8: u24 = 0,
    };
    ///SETUP data, byte 3, MSB of wValue
    pub const wvalueh = RegisterRW(wvalueh_val, void).init(0x40027000 + 0x48C);

    //////////////////////////
    ///WINDEXL
    const windexl_val = packed struct {
        ///WINDEXL [0:7]
        ///SETUP data, byte 4, LSB of wIndex
        windexl: u8 = 0,
        _unused8: u24 = 0,
    };
    ///SETUP data, byte 4, LSB of wIndex
    pub const windexl = RegisterRW(windexl_val, void).init(0x40027000 + 0x490);

    //////////////////////////
    ///WINDEXH
    const windexh_val = packed struct {
        ///WINDEXH [0:7]
        ///SETUP data, byte 5, MSB of wIndex
        windexh: u8 = 0,
        _unused8: u24 = 0,
    };
    ///SETUP data, byte 5, MSB of wIndex
    pub const windexh = RegisterRW(windexh_val, void).init(0x40027000 + 0x494);

    //////////////////////////
    ///WLENGTHL
    const wlengthl_val = packed struct {
        ///WLENGTHL [0:7]
        ///SETUP data, byte 6, LSB of wLength
        wlengthl: u8 = 0,
        _unused8: u24 = 0,
    };
    ///SETUP data, byte 6, LSB of wLength
    pub const wlengthl = RegisterRW(wlengthl_val, void).init(0x40027000 + 0x498);

    //////////////////////////
    ///WLENGTHH
    const wlengthh_val = packed struct {
        ///WLENGTHH [0:7]
        ///SETUP data, byte 7, MSB of wLength
        wlengthh: u8 = 0,
        _unused8: u24 = 0,
    };
    ///SETUP data, byte 7, MSB of wLength
    pub const wlengthh = RegisterRW(wlengthh_val, void).init(0x40027000 + 0x49C);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:0]
        ///Enable USB
        enable: packed enum(u1) {
            ///USB peripheral is disabled
            disabled = 0,
            ///USB peripheral is enabled
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Enable USB
    pub const enable = Register(enable_val).init(0x40027000 + 0x500);

    //////////////////////////
    ///USBPULLUP
    const usbpullup_val = packed struct {
        ///CONNECT [0:0]
        ///Control of the USB pull-up on the D+ line
        connect: packed enum(u1) {
            ///Pull-up is disconnected
            disabled = 0,
            ///Pull-up is connected to D+
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///Control of the USB pull-up
    pub const usbpullup = Register(usbpullup_val).init(0x40027000 + 0x504);

    //////////////////////////
    ///DPDMVALUE
    const dpdmvalue_val = packed struct {
        ///STATE [0:4]
        ///State D+ and D- lines will be forced into by the DPDMDRIVE task
        state: packed enum(u5) {
            ///D+ forced low, D- forced high (K state) for a timing preset in hardware (50 us or 5 ms, depending on bus state)
            _resume = 1,
            ///D+ forced high, D- forced low (J state)
            j = 2,
            ///D+ forced low, D- forced high (K state)
            k = 4,
            _zero = 0,
        } = ._zero,
        _unused5: u27 = 0,
    };
    ///State D+ and D- lines will be forced into by the DPDMDRIVE task. The DPDMNODRIVE task reverts the control of the lines to MAC IP (no forcing).
    pub const dpdmvalue = Register(dpdmvalue_val).init(0x40027000 + 0x508);

    //////////////////////////
    ///DTOGGLE
    const dtoggle_val = packed struct {
        ///EP [0:2]
        ///Select bulk endpoint number
        ep: u3 = 0,
        _unused3: u4 = 0,
        ///IO [7:7]
        ///Selects IN or OUT endpoint
        io: packed enum(u1) {
            ///Selects OUT endpoint
            out = 0,
            ///Selects IN endpoint
            in = 1,
        } = .out,
        ///VALUE [8:9]
        ///Data toggle value
        value: packed enum(u2) {
            ///No action on data toggle when writing the register with this value
            nop = 0,
            ///Data toggle is DATA0 on endpoint set by EP and IO
            data0 = 1,
            ///Data toggle is DATA1 on endpoint set by EP and IO
            data1 = 2,
        } = .data0,
        _unused10: u22 = 0,
    };
    ///Data toggle control and status
    pub const dtoggle = Register(dtoggle_val).init(0x40027000 + 0x50C);

    //////////////////////////
    ///EPINEN
    const epinen_val = packed struct {
        ///IN0 [0:0]
        ///Enable IN endpoint 0
        in0: packed enum(u1) {
            ///Disable endpoint IN 0 (no response to IN tokens)
            disable = 0,
            ///Enable endpoint IN 0 (response to IN tokens)
            enable = 1,
        } = .enable,
        ///IN1 [1:1]
        ///Enable IN endpoint 1
        in1: packed enum(u1) {
            ///Disable endpoint IN 1 (no response to IN tokens)
            disable = 0,
            ///Enable endpoint IN 1 (response to IN tokens)
            enable = 1,
        } = .disable,
        ///IN2 [2:2]
        ///Enable IN endpoint 2
        in2: packed enum(u1) {
            ///Disable endpoint IN 2 (no response to IN tokens)
            disable = 0,
            ///Enable endpoint IN 2 (response to IN tokens)
            enable = 1,
        } = .disable,
        ///IN3 [3:3]
        ///Enable IN endpoint 3
        in3: packed enum(u1) {
            ///Disable endpoint IN 3 (no response to IN tokens)
            disable = 0,
            ///Enable endpoint IN 3 (response to IN tokens)
            enable = 1,
        } = .disable,
        ///IN4 [4:4]
        ///Enable IN endpoint 4
        in4: packed enum(u1) {
            ///Disable endpoint IN 4 (no response to IN tokens)
            disable = 0,
            ///Enable endpoint IN 4 (response to IN tokens)
            enable = 1,
        } = .disable,
        ///IN5 [5:5]
        ///Enable IN endpoint 5
        in5: packed enum(u1) {
            ///Disable endpoint IN 5 (no response to IN tokens)
            disable = 0,
            ///Enable endpoint IN 5 (response to IN tokens)
            enable = 1,
        } = .disable,
        ///IN6 [6:6]
        ///Enable IN endpoint 6
        in6: packed enum(u1) {
            ///Disable endpoint IN 6 (no response to IN tokens)
            disable = 0,
            ///Enable endpoint IN 6 (response to IN tokens)
            enable = 1,
        } = .disable,
        ///IN7 [7:7]
        ///Enable IN endpoint 7
        in7: packed enum(u1) {
            ///Disable endpoint IN 7 (no response to IN tokens)
            disable = 0,
            ///Enable endpoint IN 7 (response to IN tokens)
            enable = 1,
        } = .disable,
        ///ISOIN [8:8]
        ///Enable ISO IN endpoint
        isoin: packed enum(u1) {
            ///Disable ISO IN endpoint 8
            disable = 0,
            ///Enable ISO IN endpoint 8
            enable = 1,
        } = .disable,
        _unused9: u23 = 0,
    };
    ///Endpoint IN enable
    pub const epinen = Register(epinen_val).init(0x40027000 + 0x510);

    //////////////////////////
    ///EPOUTEN
    const epouten_val = packed struct {
        ///OUT0 [0:0]
        ///Enable OUT endpoint 0
        out0: packed enum(u1) {
            ///Disable endpoint OUT 0 (no response to OUT tokens)
            disable = 0,
            ///Enable endpoint OUT 0 (response to OUT tokens)
            enable = 1,
        } = .enable,
        ///OUT1 [1:1]
        ///Enable OUT endpoint 1
        out1: packed enum(u1) {
            ///Disable endpoint OUT 1 (no response to OUT tokens)
            disable = 0,
            ///Enable endpoint OUT 1 (response to OUT tokens)
            enable = 1,
        } = .disable,
        ///OUT2 [2:2]
        ///Enable OUT endpoint 2
        out2: packed enum(u1) {
            ///Disable endpoint OUT 2 (no response to OUT tokens)
            disable = 0,
            ///Enable endpoint OUT 2 (response to OUT tokens)
            enable = 1,
        } = .disable,
        ///OUT3 [3:3]
        ///Enable OUT endpoint 3
        out3: packed enum(u1) {
            ///Disable endpoint OUT 3 (no response to OUT tokens)
            disable = 0,
            ///Enable endpoint OUT 3 (response to OUT tokens)
            enable = 1,
        } = .disable,
        ///OUT4 [4:4]
        ///Enable OUT endpoint 4
        out4: packed enum(u1) {
            ///Disable endpoint OUT 4 (no response to OUT tokens)
            disable = 0,
            ///Enable endpoint OUT 4 (response to OUT tokens)
            enable = 1,
        } = .disable,
        ///OUT5 [5:5]
        ///Enable OUT endpoint 5
        out5: packed enum(u1) {
            ///Disable endpoint OUT 5 (no response to OUT tokens)
            disable = 0,
            ///Enable endpoint OUT 5 (response to OUT tokens)
            enable = 1,
        } = .disable,
        ///OUT6 [6:6]
        ///Enable OUT endpoint 6
        out6: packed enum(u1) {
            ///Disable endpoint OUT 6 (no response to OUT tokens)
            disable = 0,
            ///Enable endpoint OUT 6 (response to OUT tokens)
            enable = 1,
        } = .disable,
        ///OUT7 [7:7]
        ///Enable OUT endpoint 7
        out7: packed enum(u1) {
            ///Disable endpoint OUT 7 (no response to OUT tokens)
            disable = 0,
            ///Enable endpoint OUT 7 (response to OUT tokens)
            enable = 1,
        } = .disable,
        ///ISOOUT [8:8]
        ///Enable ISO OUT endpoint 8
        isoout: packed enum(u1) {
            ///Disable ISO OUT endpoint 8
            disable = 0,
            ///Enable ISO OUT endpoint 8
            enable = 1,
        } = .disable,
        _unused9: u23 = 0,
    };
    ///Endpoint OUT enable
    pub const epouten = Register(epouten_val).init(0x40027000 + 0x514);

    //////////////////////////
    ///EPSTALL
    const epstall_val = packed struct {
        ///EP [0:2]
        ///Select endpoint number
        ep: u3 = 0,
        _unused3: u4 = 0,
        ///IO [7:7]
        ///Selects IN or OUT endpoint
        io: packed enum(u1) {
            ///Selects OUT endpoint
            out = 0,
            ///Selects IN endpoint
            in = 1,
        } = .out,
        ///STALL [8:8]
        ///Stall selected endpoint
        stall: packed enum(u1) {
            ///Don't stall selected endpoint
            un_stall = 0,
            ///Stall selected endpoint
            stall = 1,
        } = .un_stall,
        _unused9: u23 = 0,
    };
    ///STALL endpoints
    pub const epstall = RegisterRW(void, epstall_val).init(0x40027000 + 0x518);

    //////////////////////////
    ///ISOSPLIT
    const isosplit_val = packed struct {
        ///SPLIT [0:15]
        ///Controls the split of ISO buffers
        split: packed enum(u16) {
            ///Full buffer dedicated to either iso IN or OUT
            one_dir = 0x0000,
            ///Lower half for IN, upper half for OUT
            half_in = 0x0080,
            _zero = 0,
        } = ._zero,
        _unused16: u16 = 0,
    };
    ///Controls the split of ISO buffers
    pub const isosplit = Register(isosplit_val).init(0x40027000 + 0x51C);

    //////////////////////////
    ///FRAMECNTR
    const framecntr_val = packed struct {
        ///FRAMECNTR [0:10]
        ///Returns the current value of the start of frame counter
        framecntr: u11 = 0,
        _unused11: u21 = 0,
    };
    ///Returns the current value of the start of frame counter
    pub const framecntr = RegisterRW(framecntr_val, void).init(0x40027000 + 0x520);

    //////////////////////////
    ///LOWPOWER
    const lowpower_val = packed struct {
        ///LOWPOWER [0:0]
        ///Controls USBD peripheral low-power mode during USB suspend
        lowpower: packed enum(u1) {
            ///Software must write this value to exit low power mode and before performing a remote wake-up
            force_normal = 0,
            ///Software must write this value to enter low power mode after DMA and software have finished interacting with the USB peripheral
            low_power = 1,
        } = .force_normal,
        _unused1: u31 = 0,
    };
    ///Controls USBD peripheral low power mode during USB suspend
    pub const lowpower = Register(lowpower_val).init(0x40027000 + 0x52C);

    //////////////////////////
    ///ISOINCONFIG
    const isoinconfig_val = packed struct {
        ///RESPONSE [0:0]
        ///Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent
        response: packed enum(u1) {
            ///Endpoint does not respond in that case
            no_resp = 0,
            ///Endpoint responds with a zero-length data packet in that case
            zero_data = 1,
        } = .no_resp,
        _unused1: u31 = 0,
    };
    ///Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent
    pub const isoinconfig = Register(isoinconfig_val).init(0x40027000 + 0x530);
};

///UART with EasyDMA 1
pub const uarte1 = struct {

    //////////////////////////
    ///TASKS_STARTRX
    const tasks_startrx_val = packed struct {
        ///TASKS_STARTRX [0:0]
        ///Start UART receiver
        tasks_startrx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start UART receiver
    pub const tasks_startrx = RegisterRW(void, tasks_startrx_val).init(0x40028000 + 0x000);

    //////////////////////////
    ///TASKS_STOPRX
    const tasks_stoprx_val = packed struct {
        ///TASKS_STOPRX [0:0]
        ///Stop UART receiver
        tasks_stoprx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop UART receiver
    pub const tasks_stoprx = RegisterRW(void, tasks_stoprx_val).init(0x40028000 + 0x004);

    //////////////////////////
    ///TASKS_STARTTX
    const tasks_starttx_val = packed struct {
        ///TASKS_STARTTX [0:0]
        ///Start UART transmitter
        tasks_starttx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start UART transmitter
    pub const tasks_starttx = RegisterRW(void, tasks_starttx_val).init(0x40028000 + 0x008);

    //////////////////////////
    ///TASKS_STOPTX
    const tasks_stoptx_val = packed struct {
        ///TASKS_STOPTX [0:0]
        ///Stop UART transmitter
        tasks_stoptx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop UART transmitter
    pub const tasks_stoptx = RegisterRW(void, tasks_stoptx_val).init(0x40028000 + 0x00C);

    //////////////////////////
    ///TASKS_FLUSHRX
    const tasks_flushrx_val = packed struct {
        ///TASKS_FLUSHRX [0:0]
        ///Flush RX FIFO into RX buffer
        tasks_flushrx: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Flush RX FIFO into RX buffer
    pub const tasks_flushrx = RegisterRW(void, tasks_flushrx_val).init(0x40028000 + 0x02C);

    //////////////////////////
    ///EVENTS_CTS
    const events_cts_val = packed struct {
        ///EVENTS_CTS [0:0]
        ///CTS is activated (set low). Clear To Send.
        events_cts: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///CTS is activated (set low). Clear To Send.
    pub const events_cts = Register(events_cts_val).init(0x40028000 + 0x100);

    //////////////////////////
    ///EVENTS_NCTS
    const events_ncts_val = packed struct {
        ///EVENTS_NCTS [0:0]
        ///CTS is deactivated (set high). Not Clear To Send.
        events_ncts: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///CTS is deactivated (set high). Not Clear To Send.
    pub const events_ncts = Register(events_ncts_val).init(0x40028000 + 0x104);

    //////////////////////////
    ///EVENTS_RXDRDY
    const events_rxdrdy_val = packed struct {
        ///EVENTS_RXDRDY [0:0]
        ///Data received in RXD (but potentially not yet transferred to Data RAM)
        events_rxdrdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Data received in RXD (but potentially not yet transferred to Data RAM)
    pub const events_rxdrdy = Register(events_rxdrdy_val).init(0x40028000 + 0x108);

    //////////////////////////
    ///EVENTS_ENDRX
    const events_endrx_val = packed struct {
        ///EVENTS_ENDRX [0:0]
        ///Receive buffer is filled up
        events_endrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Receive buffer is filled up
    pub const events_endrx = Register(events_endrx_val).init(0x40028000 + 0x110);

    //////////////////////////
    ///EVENTS_TXDRDY
    const events_txdrdy_val = packed struct {
        ///EVENTS_TXDRDY [0:0]
        ///Data sent from TXD
        events_txdrdy: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Data sent from TXD
    pub const events_txdrdy = Register(events_txdrdy_val).init(0x40028000 + 0x11C);

    //////////////////////////
    ///EVENTS_ENDTX
    const events_endtx_val = packed struct {
        ///EVENTS_ENDTX [0:0]
        ///Last TX byte transmitted
        events_endtx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Last TX byte transmitted
    pub const events_endtx = Register(events_endtx_val).init(0x40028000 + 0x120);

    //////////////////////////
    ///EVENTS_ERROR
    const events_error_val = packed struct {
        ///EVENTS_ERROR [0:0]
        ///Error detected
        events_error: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Error detected
    pub const events_error = Register(events_error_val).init(0x40028000 + 0x124);

    //////////////////////////
    ///EVENTS_RXTO
    const events_rxto_val = packed struct {
        ///EVENTS_RXTO [0:0]
        ///Receiver timeout
        events_rxto: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Receiver timeout
    pub const events_rxto = Register(events_rxto_val).init(0x40028000 + 0x144);

    //////////////////////////
    ///EVENTS_RXSTARTED
    const events_rxstarted_val = packed struct {
        ///EVENTS_RXSTARTED [0:0]
        ///UART receiver has started
        events_rxstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///UART receiver has started
    pub const events_rxstarted = Register(events_rxstarted_val).init(0x40028000 + 0x14C);

    //////////////////////////
    ///EVENTS_TXSTARTED
    const events_txstarted_val = packed struct {
        ///EVENTS_TXSTARTED [0:0]
        ///UART transmitter has started
        events_txstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///UART transmitter has started
    pub const events_txstarted = Register(events_txstarted_val).init(0x40028000 + 0x150);

    //////////////////////////
    ///EVENTS_TXSTOPPED
    const events_txstopped_val = packed struct {
        ///EVENTS_TXSTOPPED [0:0]
        ///Transmitter stopped
        events_txstopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transmitter stopped
    pub const events_txstopped = Register(events_txstopped_val).init(0x40028000 + 0x158);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u5 = 0,
        ///ENDRX_STARTRX [5:5]
        ///Shortcut between event ENDRX and task STARTRX
        endrx_startrx: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///ENDRX_STOPRX [6:6]
        ///Shortcut between event ENDRX and task STOPRX
        endrx_stoprx: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused7: u25 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x40028000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        ///CTS [0:0]
        ///Enable or disable interrupt for event CTS
        cts: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///NCTS [1:1]
        ///Enable or disable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///RXDRDY [2:2]
        ///Enable or disable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused3: u1 = 0,
        ///ENDRX [4:4]
        ///Enable or disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused5: u2 = 0,
        ///TXDRDY [7:7]
        ///Enable or disable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ENDTX [8:8]
        ///Enable or disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///ERROR [9:9]
        ///Enable or disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Enable or disable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused18: u1 = 0,
        ///RXSTARTED [19:19]
        ///Enable or disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Enable or disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused21: u1 = 0,
        ///TXSTOPPED [22:22]
        ///Enable or disable interrupt for event TXSTOPPED
        txstopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused23: u9 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x40028000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        ///CTS [0:0]
        ///Write '1' to enable interrupt for event CTS
        cts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///NCTS [1:1]
        ///Write '1' to enable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXDRDY [2:2]
        ///Write '1' to enable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u1 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u2 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to enable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to enable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused18: u1 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u1 = 0,
        ///TXSTOPPED [22:22]
        ///Write '1' to enable interrupt for event TXSTOPPED
        txstopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused23: u9 = 0,
    };
    const intenset_val_write = packed struct {
        ///CTS [0:0]
        ///Write '1' to enable interrupt for event CTS
        cts: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///NCTS [1:1]
        ///Write '1' to enable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///RXDRDY [2:2]
        ///Write '1' to enable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u1 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u2 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to enable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///ERROR [9:9]
        ///Write '1' to enable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to enable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused18: u1 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to enable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to enable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u1 = 0,
        ///TXSTOPPED [22:22]
        ///Write '1' to enable interrupt for event TXSTOPPED
        txstopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused23: u9 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x40028000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        ///CTS [0:0]
        ///Write '1' to disable interrupt for event CTS
        cts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///NCTS [1:1]
        ///Write '1' to disable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///RXDRDY [2:2]
        ///Write '1' to disable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused3: u1 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u2 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to disable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to disable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused18: u1 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused21: u1 = 0,
        ///TXSTOPPED [22:22]
        ///Write '1' to disable interrupt for event TXSTOPPED
        txstopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused23: u9 = 0,
    };
    const intenclr_val_write = packed struct {
        ///CTS [0:0]
        ///Write '1' to disable interrupt for event CTS
        cts: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///NCTS [1:1]
        ///Write '1' to disable interrupt for event NCTS
        ncts: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///RXDRDY [2:2]
        ///Write '1' to disable interrupt for event RXDRDY
        rxdrdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused3: u1 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u2 = 0,
        ///TXDRDY [7:7]
        ///Write '1' to disable interrupt for event TXDRDY
        txdrdy: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///ERROR [9:9]
        ///Write '1' to disable interrupt for event ERROR
        _error: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused10: u7 = 0,
        ///RXTO [17:17]
        ///Write '1' to disable interrupt for event RXTO
        rxto: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused18: u1 = 0,
        ///RXSTARTED [19:19]
        ///Write '1' to disable interrupt for event RXSTARTED
        rxstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///TXSTARTED [20:20]
        ///Write '1' to disable interrupt for event TXSTARTED
        txstarted: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused21: u1 = 0,
        ///TXSTOPPED [22:22]
        ///Write '1' to disable interrupt for event TXSTOPPED
        txstopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused23: u9 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x40028000 + 0x308);

    //////////////////////////
    ///ERRORSRC
    const errorsrc_val_read = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///PARITY [1:1]
        ///Parity error
        parity: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///FRAMING [2:2]
        ///Framing error occurred
        framing: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        ///BREAK [3:3]
        ///Break condition
        _break: packed enum(u1) {
            ///Read: error not present
            not_present = 0,
            ///Read: error present
            present = 1,
        } = .not_present,
        _unused4: u28 = 0,
    };
    const errorsrc_val_write = packed struct {
        ///OVERRUN [0:0]
        ///Overrun error
        overrun: u1 = 0,
        ///PARITY [1:1]
        ///Parity error
        parity: u1 = 0,
        ///FRAMING [2:2]
        ///Framing error occurred
        framing: u1 = 0,
        ///BREAK [3:3]
        ///Break condition
        _break: u1 = 0,
        _unused4: u28 = 0,
    };
    ///Error source Note : this register is read / write one to clear.
    pub const errorsrc = RegisterRW(errorsrc_val_read, errorsrc_val_write).init(0x40028000 + 0x480);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable UARTE
        enable: packed enum(u4) {
            ///Disable UARTE
            disabled = 0,
            ///Enable UARTE
            enabled = 8,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable UART
    pub const enable = Register(enable_val).init(0x40028000 + 0x500);

    //////////////////////////
    ///BAUDRATE
    const baudrate_val = packed struct {
        ///BAUDRATE [0:31]
        ///Baud rate
        baudrate: packed enum(u32) {
            ///1200 baud (actual rate: 1205)
            baud1200 = 0x0004F000,
            ///2400 baud (actual rate: 2396)
            baud2400 = 0x0009D000,
            ///4800 baud (actual rate: 4808)
            baud4800 = 0x0013B000,
            ///9600 baud (actual rate: 9598)
            baud9600 = 0x00275000,
            ///14400 baud (actual rate: 14401)
            baud14400 = 0x003AF000,
            ///19200 baud (actual rate: 19208)
            baud19200 = 0x004EA000,
            ///28800 baud (actual rate: 28777)
            baud28800 = 0x0075C000,
            ///31250 baud
            baud31250 = 0x00800000,
            ///38400 baud (actual rate: 38369)
            baud38400 = 0x009D0000,
            ///56000 baud (actual rate: 55944)
            baud56000 = 0x00E50000,
            ///57600 baud (actual rate: 57554)
            baud57600 = 0x00EB0000,
            ///76800 baud (actual rate: 76923)
            baud76800 = 0x013A9000,
            ///115200 baud (actual rate: 115108)
            baud115200 = 0x01D60000,
            ///230400 baud (actual rate: 231884)
            baud230400 = 0x03B00000,
            ///250000 baud
            baud250000 = 0x04000000,
            ///460800 baud (actual rate: 457143)
            baud460800 = 0x07400000,
            ///921600 baud (actual rate: 941176)
            baud921600 = 0x0F000000,
            ///1Mega baud
            baud1m = 0x10000000,
            _zero = 0,
        } = ._zero,
    };
    ///Baud rate. Accuracy depends on the HFCLK source selected.
    pub const baudrate = Register(baudrate_val).init(0x40028000 + 0x524);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///HWFC [0:0]
        ///Hardware flow control
        hwfc: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enabled
            enabled = 1,
        } = .disabled,
        ///PARITY [1:3]
        ///Parity
        parity: packed enum(u3) {
            ///Exclude parity bit
            excluded = 0x0,
            ///Include even parity bit
            included = 0x7,
            _zero = 0,
        } = ._zero,
        ///STOP [4:4]
        ///Stop bits
        stop: packed enum(u1) {
            ///One stop bit
            one = 0,
            ///Two stop bits
            two = 1,
        } = .one,
        _unused5: u3 = 0,
        ///PARITYTYPE [8:8]
        ///Even or odd parity type
        paritytype: packed enum(u1) {
            ///Even parity
            even = 0,
            ///Odd parity
            odd = 1,
        } = .even,
        _unused9: u23 = 0,
    };
    ///Configuration of parity and hardware flow control
    pub const config = Register(config_val).init(0x40028000 + 0x56C);
};

///Pulse width modulation unit 3
pub const pwm3 = struct {

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4002D000 + 0x004);

    //////////////////////////
    ///TASKS_SEQSTART[%s]
    const tasks_seqstart_val = packed struct {
        ///TASKS_SEQSTART [0:0]
        ///Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
        tasks_seqstart: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Description collection: Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running.
    pub const tasks_seqstart = RegisterRW(void, tasks_seqstart_val).initRange(0x4002D000 + 0x008, 4, 2);

    //////////////////////////
    ///TASKS_NEXTSTEP
    const tasks_nextstep_val = packed struct {
        ///TASKS_NEXTSTEP [0:0]
        ///Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
        tasks_nextstep: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running.
    pub const tasks_nextstep = RegisterRW(void, tasks_nextstep_val).init(0x4002D000 + 0x010);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///Response to STOP task, emitted when PWM pulses are no longer generated
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Response to STOP task, emitted when PWM pulses are no longer generated
    pub const events_stopped = Register(events_stopped_val).init(0x4002D000 + 0x104);

    //////////////////////////
    ///EVENTS_SEQSTARTED[%s]
    const events_seqstarted_val = packed struct {
        ///EVENTS_SEQSTARTED [0:0]
        ///First PWM period started on sequence n
        events_seqstarted: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: First PWM period started on sequence n
    pub const events_seqstarted = Register(events_seqstarted_val).initRange(0x4002D000 + 0x108, 4, 2);

    //////////////////////////
    ///EVENTS_SEQEND[%s]
    const events_seqend_val = packed struct {
        ///EVENTS_SEQEND [0:0]
        ///Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
        events_seqend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter
    pub const events_seqend = Register(events_seqend_val).initRange(0x4002D000 + 0x110, 4, 2);

    //////////////////////////
    ///EVENTS_PWMPERIODEND
    const events_pwmperiodend_val = packed struct {
        ///EVENTS_PWMPERIODEND [0:0]
        ///Emitted at the end of each PWM period
        events_pwmperiodend: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Emitted at the end of each PWM period
    pub const events_pwmperiodend = Register(events_pwmperiodend_val).init(0x4002D000 + 0x118);

    //////////////////////////
    ///EVENTS_LOOPSDONE
    const events_loopsdone_val = packed struct {
        ///EVENTS_LOOPSDONE [0:0]
        ///Concatenated sequences have been played the amount of times defined in LOOP.CNT
        events_loopsdone: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Concatenated sequences have been played the amount of times defined in LOOP.CNT
    pub const events_loopsdone = Register(events_loopsdone_val).init(0x4002D000 + 0x11C);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        ///SEQEND0_STOP [0:0]
        ///Shortcut between event SEQEND[0] and task STOP
        seqend0_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///SEQEND1_STOP [1:1]
        ///Shortcut between event SEQEND[1] and task STOP
        seqend1_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_SEQSTART0 [2:2]
        ///Shortcut between event LOOPSDONE and task SEQSTART[0]
        loopsdone_seqstart0: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_SEQSTART1 [3:3]
        ///Shortcut between event LOOPSDONE and task SEQSTART[1]
        loopsdone_seqstart1: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE_STOP [4:4]
        ///Shortcut between event LOOPSDONE and task STOP
        loopsdone_stop: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused5: u27 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x4002D000 + 0x200);

    //////////////////////////
    ///INTEN
    const inten_val = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Enable or disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Enable or disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Enable or disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Enable or disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Enable or disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Enable or disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Enable or disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Disable
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    ///Enable or disable interrupt
    pub const inten = Register(inten_val).init(0x4002D000 + 0x300);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to enable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to enable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Write '1' to enable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Write '1' to enable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Write '1' to enable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Write '1' to enable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to enable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to enable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND0 [4:4]
        ///Write '1' to enable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND1 [5:5]
        ///Write '1' to enable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///PWMPERIODEND [6:6]
        ///Write '1' to enable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        ///LOOPSDONE [7:7]
        ///Write '1' to enable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4002D000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND0 [4:4]
        ///Write '1' to disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///SEQEND1 [5:5]
        ///Write '1' to disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///PWMPERIODEND [6:6]
        ///Write '1' to disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        ///LOOPSDONE [7:7]
        ///Write '1' to disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused8: u24 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED0 [2:2]
        ///Write '1' to disable interrupt for event SEQSTARTED[0]
        seqstarted0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQSTARTED1 [3:3]
        ///Write '1' to disable interrupt for event SEQSTARTED[1]
        seqstarted1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND0 [4:4]
        ///Write '1' to disable interrupt for event SEQEND[0]
        seqend0: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///SEQEND1 [5:5]
        ///Write '1' to disable interrupt for event SEQEND[1]
        seqend1: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///PWMPERIODEND [6:6]
        ///Write '1' to disable interrupt for event PWMPERIODEND
        pwmperiodend: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        ///LOOPSDONE [7:7]
        ///Write '1' to disable interrupt for event LOOPSDONE
        loopsdone: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused8: u24 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4002D000 + 0x308);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:0]
        ///Enable or disable PWM module
        enable: packed enum(u1) {
            ///Disabled
            disabled = 0,
            ///Enable
            enabled = 1,
        } = .disabled,
        _unused1: u31 = 0,
    };
    ///PWM module enable register
    pub const enable = Register(enable_val).init(0x4002D000 + 0x500);

    //////////////////////////
    ///MODE
    const mode_val = packed struct {
        ///UPDOWN [0:0]
        ///Selects up mode or up-and-down mode for the counter
        updown: packed enum(u1) {
            ///Up counter, edge-aligned PWM duty cycle
            up = 0,
            ///Up and down counter, center-aligned PWM duty cycle
            up_and_down = 1,
        } = .up,
        _unused1: u31 = 0,
    };
    ///Selects operating mode of the wave counter
    pub const mode = Register(mode_val).init(0x4002D000 + 0x504);

    //////////////////////////
    ///COUNTERTOP
    const countertop_val = packed struct {
        ///COUNTERTOP [0:14]
        ///Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used.
        countertop: u15 = 1023,
        _unused15: u17 = 0,
    };
    ///Value up to which the pulse generator counter counts
    pub const countertop = Register(countertop_val).init(0x4002D000 + 0x508);

    //////////////////////////
    ///PRESCALER
    const prescaler_val = packed struct {
        ///PRESCALER [0:2]
        ///Prescaler of PWM_CLK
        prescaler: packed enum(u3) {
            ///Divide by 1 (16 MHz)
            div_1 = 0,
            ///Divide by 2 (8 MHz)
            div_2 = 1,
            ///Divide by 4 (4 MHz)
            div_4 = 2,
            ///Divide by 8 (2 MHz)
            div_8 = 3,
            ///Divide by 16 (1 MHz)
            div_16 = 4,
            ///Divide by 32 (500 kHz)
            div_32 = 5,
            ///Divide by 64 (250 kHz)
            div_64 = 6,
            ///Divide by 128 (125 kHz)
            div_128 = 7,
        } = .div_1,
        _unused3: u29 = 0,
    };
    ///Configuration for PWM_CLK
    pub const prescaler = Register(prescaler_val).init(0x4002D000 + 0x50C);

    //////////////////////////
    ///DECODER
    const decoder_val = packed struct {
        ///LOAD [0:1]
        ///How a sequence is read from RAM and spread to the compare register
        load: packed enum(u2) {
            ///1st half word (16-bit) used in all PWM channels 0..3
            common = 0,
            ///1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3
            grouped = 1,
            ///1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3
            individual = 2,
            ///1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP
            wave_form = 3,
        } = .common,
        _unused2: u6 = 0,
        ///MODE [8:8]
        ///Selects source for advancing the active sequence
        mode: packed enum(u1) {
            ///SEQ[n].REFRESH is used to determine loading internal compare registers
            refresh_count = 0,
            ///NEXTSTEP task causes a new value to be loaded to internal compare registers
            next_step = 1,
        } = .refresh_count,
        _unused9: u23 = 0,
    };
    ///Configuration of the decoder
    pub const decoder = Register(decoder_val).init(0x4002D000 + 0x510);

    //////////////////////////
    ///LOOP
    const loop_val = packed struct {
        ///CNT [0:15]
        ///Number of playbacks of pattern cycles
        cnt: packed enum(u16) {
            ///Looping disabled (stop at the end of the sequence)
            disabled = 0,
        } = .disabled,
        _unused16: u16 = 0,
    };
    ///Number of playbacks of a loop
    pub const loop = Register(loop_val).init(0x4002D000 + 0x514);
};

///Serial Peripheral Interface Master with EasyDMA 3
pub const spim3 = struct {

    //////////////////////////
    ///TASKS_START
    const tasks_start_val = packed struct {
        ///TASKS_START [0:0]
        ///Start SPI transaction
        tasks_start: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Start SPI transaction
    pub const tasks_start = RegisterRW(void, tasks_start_val).init(0x4002F000 + 0x010);

    //////////////////////////
    ///TASKS_STOP
    const tasks_stop_val = packed struct {
        ///TASKS_STOP [0:0]
        ///Stop SPI transaction
        tasks_stop: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Stop SPI transaction
    pub const tasks_stop = RegisterRW(void, tasks_stop_val).init(0x4002F000 + 0x014);

    //////////////////////////
    ///TASKS_SUSPEND
    const tasks_suspend_val = packed struct {
        ///TASKS_SUSPEND [0:0]
        ///Suspend SPI transaction
        tasks_suspend: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Suspend SPI transaction
    pub const tasks_suspend = RegisterRW(void, tasks_suspend_val).init(0x4002F000 + 0x01C);

    //////////////////////////
    ///TASKS_RESUME
    const tasks_resume_val = packed struct {
        ///TASKS_RESUME [0:0]
        ///Resume SPI transaction
        tasks_resume: packed enum(u1) {
            ///Trigger task
            trigger = 1,
            _zero = 0,
        } = ._zero,
        _unused1: u31 = 0,
    };
    ///Resume SPI transaction
    pub const tasks_resume = RegisterRW(void, tasks_resume_val).init(0x4002F000 + 0x020);

    //////////////////////////
    ///EVENTS_STOPPED
    const events_stopped_val = packed struct {
        ///EVENTS_STOPPED [0:0]
        ///SPI transaction has stopped
        events_stopped: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///SPI transaction has stopped
    pub const events_stopped = Register(events_stopped_val).init(0x4002F000 + 0x104);

    //////////////////////////
    ///EVENTS_ENDRX
    const events_endrx_val = packed struct {
        ///EVENTS_ENDRX [0:0]
        ///End of RXD buffer reached
        events_endrx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer reached
    pub const events_endrx = Register(events_endrx_val).init(0x4002F000 + 0x110);

    //////////////////////////
    ///EVENTS_END
    const events_end_val = packed struct {
        ///EVENTS_END [0:0]
        ///End of RXD buffer and TXD buffer reached
        events_end: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of RXD buffer and TXD buffer reached
    pub const events_end = Register(events_end_val).init(0x4002F000 + 0x118);

    //////////////////////////
    ///EVENTS_ENDTX
    const events_endtx_val = packed struct {
        ///EVENTS_ENDTX [0:0]
        ///End of TXD buffer reached
        events_endtx: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///End of TXD buffer reached
    pub const events_endtx = Register(events_endtx_val).init(0x4002F000 + 0x120);

    //////////////////////////
    ///EVENTS_STARTED
    const events_started_val = packed struct {
        ///EVENTS_STARTED [0:0]
        ///Transaction started
        events_started: packed enum(u1) {
            ///Event not generated
            not_generated = 0,
            ///Event generated
            generated = 1,
        } = .not_generated,
        _unused1: u31 = 0,
    };
    ///Transaction started
    pub const events_started = Register(events_started_val).init(0x4002F000 + 0x14C);

    //////////////////////////
    ///SHORTS
    const shorts_val = packed struct {
        _unused0: u17 = 0,
        ///END_START [17:17]
        ///Shortcut between event END and task START
        end_start: packed enum(u1) {
            ///Disable shortcut
            disabled = 0,
            ///Enable shortcut
            enabled = 1,
        } = .disabled,
        _unused18: u14 = 0,
    };
    ///Shortcuts between local events and tasks
    pub const shorts = Register(shorts_val).init(0x4002F000 + 0x200);

    //////////////////////////
    ///INTENSET
    const intenset_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenset_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to enable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to enable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to enable interrupt for event END
        end: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to enable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to enable interrupt for event STARTED
        started: packed enum(u1) {
            ///Enable
            set = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Enable interrupt
    pub const intenset = RegisterRW(intenset_val_read, intenset_val_write).init(0x4002F000 + 0x304);

    //////////////////////////
    ///INTENCLR
    const intenclr_val_read = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Read: Disabled
            disabled = 0,
            ///Read: Enabled
            enabled = 1,
        } = .disabled,
        _unused20: u12 = 0,
    };
    const intenclr_val_write = packed struct {
        _unused0: u1 = 0,
        ///STOPPED [1:1]
        ///Write '1' to disable interrupt for event STOPPED
        stopped: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused2: u2 = 0,
        ///ENDRX [4:4]
        ///Write '1' to disable interrupt for event ENDRX
        endrx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused5: u1 = 0,
        ///END [6:6]
        ///Write '1' to disable interrupt for event END
        end: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused7: u1 = 0,
        ///ENDTX [8:8]
        ///Write '1' to disable interrupt for event ENDTX
        endtx: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused9: u10 = 0,
        ///STARTED [19:19]
        ///Write '1' to disable interrupt for event STARTED
        started: packed enum(u1) {
            ///Disable
            clear = 1,
            _zero = 0,
        } = ._zero,
        _unused20: u12 = 0,
    };
    ///Disable interrupt
    pub const intenclr = RegisterRW(intenclr_val_read, intenclr_val_write).init(0x4002F000 + 0x308);

    //////////////////////////
    ///STALLSTAT
    const stallstat_val = packed struct {
        ///TX [0:0]
        ///Stall status for EasyDMA RAM reads
        tx: packed enum(u1) {
            ///No stall
            nostall = 0,
            ///A stall has occurred
            stall = 1,
        } = .nostall,
        ///RX [1:1]
        ///Stall status for EasyDMA RAM writes
        rx: packed enum(u1) {
            ///No stall
            nostall = 0,
            ///A stall has occurred
            stall = 1,
        } = .nostall,
        _unused2: u30 = 0,
    };
    ///Stall status for EasyDMA RAM accesses. The fields in this register is set to STALL by hardware whenever a stall occurres and can be cleared (set to NOSTALL) by the CPU.
    pub const stallstat = Register(stallstat_val).init(0x4002F000 + 0x400);

    //////////////////////////
    ///ENABLE
    const enable_val = packed struct {
        ///ENABLE [0:3]
        ///Enable or disable SPIM
        enable: packed enum(u4) {
            ///Disable SPIM
            disabled = 0,
            ///Enable SPIM
            enabled = 7,
        } = .disabled,
        _unused4: u28 = 0,
    };
    ///Enable SPIM
    pub const enable = Register(enable_val).init(0x4002F000 + 0x500);

    //////////////////////////
    ///FREQUENCY
    const frequency_val = packed struct {
        ///FREQUENCY [0:31]
        ///SPI master data rate
        frequency: packed enum(u32) {
            ///125 kbps
            k125 = 0x02000000,
            ///250 kbps
            k250 = 0x04000000,
            ///500 kbps
            k500 = 0x08000000,
            ///1 Mbps
            m1 = 0x10000000,
            ///2 Mbps
            m2 = 0x20000000,
            ///4 Mbps
            m4 = 0x40000000,
            ///8 Mbps
            m8 = 0x80000000,
            ///16 Mbps
            m16 = 0x0A000000,
            ///32 Mbps
            m32 = 0x14000000,
            _zero = 0,
        } = ._zero,
    };
    ///SPI frequency. Accuracy depends on the HFCLK source selected.
    pub const frequency = Register(frequency_val).init(0x4002F000 + 0x524);

    //////////////////////////
    ///CONFIG
    const config_val = packed struct {
        ///ORDER [0:0]
        ///Bit order
        order: packed enum(u1) {
            ///Most significant bit shifted out first
            msb_first = 0,
            ///Least significant bit shifted out first
            lsb_first = 1,
        } = .msb_first,
        ///CPHA [1:1]
        ///Serial clock (SCK) phase
        cpha: packed enum(u1) {
            ///Sample on leading edge of clock, shift serial data on trailing edge
            leading = 0,
            ///Sample on trailing edge of clock, shift serial data on leading edge
            trailing = 1,
        } = .leading,
        ///CPOL [2:2]
        ///Serial clock (SCK) polarity
        cpol: packed enum(u1) {
            ///Active high
            active_high = 0,
            ///Active low
            active_low = 1,
        } = .active_high,
        _unused3: u29 = 0,
    };
    ///Configuration register
    pub const config = Register(config_val).init(0x4002F000 + 0x554);

    //////////////////////////
    ///CSNPOL
    const csnpol_val = packed struct {
        ///CSNPOL [0:0]
        ///Polarity of CSN output
        csnpol: packed enum(u1) {
            ///Active low (idle state high)
            low = 0,
            ///Active high (idle state low)
            high = 1,
        } = .low,
        _unused1: u31 = 0,
    };
    ///Polarity of CSN output
    pub const csnpol = Register(csnpol_val).init(0x4002F000 + 0x568);

    //////////////////////////
    ///PSELDCX
    const pseldcx_val = packed struct {
        ///PIN [0:4]
        ///Pin number
        pin: u5 = 31,
        ///PORT [5:5]
        ///Port number
        port: u1 = 1,
        _unused6: u25 = 0,
        ///CONNECT [31:31]
        ///Connection
        connect: packed enum(u1) {
            ///Disconnect
            disconnected = 1,
            ///Connect
            connected = 0,
        } = .disconnected,
    };
    ///Pin select for DCX signal
    pub const pseldcx = Register(pseldcx_val).init(0x4002F000 + 0x56C);

    //////////////////////////
    ///DCXCNT
    const dcxcnt_val = packed struct {
        ///DCXCNT [0:3]
        ///This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes.
        dcxcnt: u4 = 0,
        _unused4: u28 = 0,
    };
    ///DCX configuration
    pub const dcxcnt = Register(dcxcnt_val).init(0x4002F000 + 0x570);

    //////////////////////////
    ///ORC
    const orc_val = packed struct {
        ///ORC [0:7]
        ///Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT.
        orc: u8 = 0,
        _unused8: u24 = 0,
    };
    ///Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT
    pub const orc = Register(orc_val).init(0x4002F000 + 0x5C0);
};
